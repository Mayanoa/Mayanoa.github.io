<!DOCTYPE html>
<html lang="zh">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#66ccff>
  <title>C#学习笔记-面向对象 | Eureka的喵窝</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="Eureka">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.4.4',
    localsearch:{
      "enable": false,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'null'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/theme-lx@0.4.4/source/dist/css/main.min.css">
  
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/theme-lx@0.4.4/source/dist/js/jquery.jside.menu.min.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 6.3.0"></head>
<body>
<div class="single">

<div id="page">
<div class="header">
  <div id="lx-aside" style="background-image: url(/images/post_cover.jpg)" data-stellar-background-ratio="0.5">
    <div class="overlay">
      
      <div class="page-title">
        <div class="avatar"><a href="/"><img src="/images/avatar.jpg" alt="Eureka"></a></div>
        <span>2022-12-13</span>
        <h2>C#学习笔记-面向对象</h2>
        
        <div class="social-links">
</div>
      </div>
    </div>
  </div>
</div>
<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <img src="/2022/12/13/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E5%B0%81%E9%9D%A2.png" class="" title="From 孤独摇滚">
<span id="more"></span> 

<h3 id="003-使用输出语句和Debug模式调试程序-x2F-004-中断模式下的窗口介绍"><a href="#003-使用输出语句和Debug模式调试程序-x2F-004-中断模式下的窗口介绍" class="headerlink" title="003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍"></a>003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍</h3><h4 id="断点的设置与中断模式窗口"><a href="#断点的设置与中断模式窗口" class="headerlink" title="断点的设置与中断模式窗口"></a><strong>断点的设置与中断模式窗口</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">设置断点的四种方法：</span><br><span class="line">1.右击代码⾏，选择breakpoint(断点) -&gt; insert breakpoint（插⼊断点）。</span><br><span class="line">2.光标定位到代码⾏，选择菜单上的Debug(调试)-&gt;Toggle Breakpoint(切换断点)。</span><br><span class="line">3.光标定位到代码⾏，按下F9键，在此按下F9是取消断点。</span><br><span class="line">4.在需要添加断点的⾏⾸位置，直接单击，再次单击取消断点。</span><br><span class="line">//运行程序时，会在断点的位置停下，此时可以通过窗口查看当前代码中各变量对应的值便于程序调试。</span><br><span class="line">//显示出现的各变量的值均是当前所运行的方法中变量的值。</span><br><span class="line">//调⽤堆栈窗⼝下可以观察到当前代码执⾏到哪⼀⾏了，且可以看到这个代码的是被什么语句调⽤的。</span><br><span class="line">//即时窗⼝可以输⼊⼀些命令，查看变量的值，修改变量的值，可以输⼊表达式查看结果。</span><br></pre></td></tr></table></figure>

<h3 id="005-逐语句和逐过程（中断模式）"><a href="#005-逐语句和逐过程（中断模式）" class="headerlink" title="005-逐语句和逐过程（中断模式）"></a>005-逐语句和逐过程（中断模式）</h3><h4 id="逐语句和逐过程"><a href="#逐语句和逐过程" class="headerlink" title="逐语句和逐过程"></a><strong>逐语句和逐过程</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在中断模式下我们可以单步执⾏代码，单步执⾏带有有两种：逐过程和逐语句。</span><br><span class="line">两类单步执行都是⼀条语句⼀跳语句的执⾏，区别在于：</span><br><span class="line">逐过程遇到函数，不会进⼊函数内部⽽把函数当成⼀条语句去执⾏。</span><br><span class="line">而逐语句会进入函数内部并在函数内逐条执行代码。</span><br></pre></td></tr></table></figure>

<h3 id="006-关于程序中的异常-x2F-007-使用try-catch-finally语句处理异常"><a href="#006-关于程序中的异常-x2F-007-使用try-catch-finally语句处理异常" class="headerlink" title="006-关于程序中的异常 &#x2F; 007-使用try-catch-finally语句处理异常"></a>006-关于程序中的异常 &#x2F; 007-使用try-catch-finally语句处理异常</h3><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">异常是在运⾏期间代码中产⽣的错误。</span><br><span class="line">异常发⽣的时候，程序会终⽌掉，然后异常后⾯的代码都⽆法执⾏。</span><br></pre></td></tr></table></figure>

<h4 id="异常的处理：try-catch-finally语句"><a href="#异常的处理：try-catch-finally语句" class="headerlink" title="异常的处理：try catch finally语句"></a><strong>异常的处理：try catch finally语句</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try //放置可能出现异常的代码。</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">catch( &lt;exceptionType&gt; e ) //放置异常类型，例如IndexOutOfRangeException。</span><br><span class="line">&#123;</span><br><span class="line">... //出现异常时如何处理（执行什么语句）。</span><br><span class="line">&#125; //catch可以并列放置多个异常类型。</span><br><span class="line">finally //无论代码是否出现异常，都会执行后续的代码。</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">//其中catch块可以有0或者多个，finally可以有0或者1个。</span><br><span class="line">//如果没有catch块，必须有finally块。</span><br><span class="line">//没有finally块，必须有catch块，catch块和finally块可以同时存在。</span><br><span class="line">//在检测用户输入是否符合要求的场合，可以使用while循环+try catch的组合。</span><br><span class="line">//此时在try的代码块的最后加入break直接终止跳出循环，运行到break说明try内的代码没有报错。</span><br><span class="line">//如果运行不到break说明报错了，此时执行catch语句进行处理再回到try代码块循环。</span><br></pre></td></tr></table></figure>

<h3 id="011-怎么定义一个类-x2F-012-创建对象和对象的使用"><a href="#011-怎么定义一个类-x2F-012-创建对象和对象的使用" class="headerlink" title="011-怎么定义一个类 &#x2F; 012-创建对象和对象的使用"></a>011-怎么定义一个类 &#x2F; 012-创建对象和对象的使用</h3><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><strong>类的定义</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Customer //class+类名：定义一个类。</span><br><span class="line">&#123;</span><br><span class="line">public string name;</span><br><span class="line">public string address;</span><br><span class="line">public int age;</span><br><span class="line">public string buyTime; //添加变量，类似于定义一个结构体，权限默认public。</span><br><span class="line">public void Show() //声明一个打印顾客信息的函数。</span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(&quot;名字:&quot;+name);</span><br><span class="line">Console.WriteLine(&quot;年龄:&quot;+age);</span><br><span class="line">Console.WriteLine(&quot;地址:&quot;+address);</span><br><span class="line">Console.WriteLine(&quot;购买时间:&quot;+buyTime);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a><strong>对象的创建与使用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassName myClass = new ClassName();</span><br><span class="line">Customer c1 =new Customer(); //对象也是一种变量，声明一个对象并初始化。</span><br><span class="line">c1.name = ’siki‘； //给c1对象里面的变量赋值。</span><br><span class="line">c1.show(); //调用c1对象中的函数。</span><br></pre></td></tr></table></figure>

<h3 id="013-车辆类和向量类的定义和使用-x2F-014-public和private访问权限控制"><a href="#013-车辆类和向量类的定义和使用-x2F-014-public和private访问权限控制" class="headerlink" title="013-车辆类和向量类的定义和使用 &#x2F; 014-public和private访问权限控制"></a>013-车辆类和向量类的定义和使用 &#x2F; 014-public和private访问权限控制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符：public /private</span><br><span class="line">通过private修饰定义的变量仅能在类当中去声明和访问。</span><br><span class="line">//习惯上所有数据的声明都是用private。</span><br><span class="line">//使private可以在外界访问的方法是在类中构造一个赋值作用的public函数。</span><br><span class="line">//prvate的优势就是可以通过get获取/set设置类的方法对数据进行校验判断。</span><br></pre></td></tr></table></figure>

<h3 id="015-什么是构造函数"><a href="#015-什么是构造函数" class="headerlink" title="015-什么是构造函数"></a>015-什么是构造函数</h3><h4 id="构造函数的语法"><a href="#构造函数的语法" class="headerlink" title="构造函数的语法"></a><strong>构造函数的语法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">构造对象时候，对象的初始化过程是⾃动完成的。</span><br><span class="line">但是在初始化对象的过程中有的时候需要做⼀些额外的⼯作。</span><br><span class="line">例如需要初始化对象存储的数据，构造函数就是⽤于初始化数据的函数。</span><br><span class="line">声明基本的构造函数的语法就是声明⼀个和所在类同名的⽅法，但是该⽅法没有返回类型。</span><br><span class="line">public class MyClass</span><br><span class="line">&#123;</span><br><span class="line">public MyClass() //没有返回值，public后直接接一个和类myclass名称相同的函数，括号内是函数的参数。</span><br><span class="line">&#123;</span><br><span class="line">这个构造函数的函数体 //一般是初始化时直接给构造的对象赋值，初始化时直接调用函数完成赋值。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//构造函数可以存在多个（需要参数不同），存在多个构造函数时根据参数的类型进行重载。</span><br><span class="line">//构造函数在构造方法时默认一定会执行一次。</span><br><span class="line">//创建类时可以不写构造函数，此时系统会执行默认构造函数（无参无效果）。</span><br><span class="line">//如果声明了一个有参的构造函数，声明时就不能不加参数。</span><br><span class="line">//构造函数赋值时可以用this.字段来表示当前对象避免参数和字段重名的问题。</span><br></pre></td></tr></table></figure>

<h3 id="017-属性-x2F-018-属性和匿名类型"><a href="#017-属性-x2F-018-属性和匿名类型" class="headerlink" title="017-属性 &#x2F; 018-属性和匿名类型"></a>017-属性 &#x2F; 018-属性和匿名类型</h3><h4 id="通过属性完成对象的赋值和调用"><a href="#通过属性完成对象的赋值和调用" class="headerlink" title="通过属性完成对象的赋值和调用"></a><strong>通过属性完成对象的赋值和调用</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int MyIntProp </span><br><span class="line">//类似于函数的设置方式，MyIntProp是函数的名字，可以自由取名，但一般是字段首字母大写。</span><br><span class="line">&#123;</span><br><span class="line">get //代表获取对象字段的具体值。</span><br><span class="line">&#123;</span><br><span class="line">/get code //例如return age。</span><br><span class="line">&#125;</span><br><span class="line">set</span><br><span class="line">&#123;</span><br><span class="line">set code //例如 age = value，此处的value是固定的。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xiaoming.age = 14; //使用时直接通过.name这样的属性方式进行赋值，不调用具体函数。</span><br><span class="line">console.writeline(xiaoming.age) //直接获取并输出赋值后的数据信息。</span><br><span class="line">//相当于使用同一个属性直接完成了字段的赋值与调用，是两种函数组合的简写形式。</span><br><span class="line">//set code部分同样是可以加入if语句来对赋值进行检验处理。</span><br><span class="line">//get和set部分同样可以在前面加入private来限制数据的访问权限。</span><br><span class="line">//属性可以仅提供⼀个set块或者get块，未必两个都要有。</span><br><span class="line">public int Age&#123;get;set;&#125; </span><br><span class="line">//在类中使用该代码，系统会自动创建public int age的代码，之后的get/set可以直接设置数据的访问权限。</span><br></pre></td></tr></table></figure>

<h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a><strong>匿名类型</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建变量（对象的时候），必须指定类型，但其实也可以不去指定类型，而是使⽤var声明⼀个匿名类型。</span><br><span class="line">使⽤var声明的匿名类型，当初始化的时候，这个变量的类型就被确定下来，并且以后不可以修改。</span><br><span class="line">var var1 = 34; //因为初始化赋值是34，var1会被系统自动设置为int类型，且无法再做类型的修改。</span><br></pre></td></tr></table></figure>

<h3 id="020-值类型和引用类型-x2F-023-对象引用的改变"><a href="#020-值类型和引用类型-x2F-023-对象引用的改变" class="headerlink" title="020-值类型和引用类型 &#x2F; 023-对象引用的改变"></a>020-值类型和引用类型 &#x2F; 023-对象引用的改变</h3><h4 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a><strong>值类型和引用类型</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类型被分为两种：</span><br><span class="line">值类型(整数，bool，struct，char，⼩数)</span><br><span class="line">引⽤类型（string 数组 ⾃定义的类，内置的类）</span><br><span class="line">值类型只需要⼀段单独的内存，⽤于存储实际的数据（单独定义的时候放在栈中）。</span><br><span class="line">引⽤类型需要两段内存：第⼀段存储实际的数据，它总是位于堆中；第⼆段是⼀个引⽤，指向数据在堆中的存放位置。</span><br><span class="line">注意使⽤引⽤类型赋值时，其实是赋值的引⽤类型的引⽤。</span><br><span class="line">因此在两个变量均指向同一个引用时，修改其中一个引用对应的具体值，另一个变量的值也会发生同样的变化。</span><br></pre></td></tr></table></figure>

<h3 id="024-什么是继承-x2F-025-继承的代码演示"><a href="#024-什么是继承-x2F-025-继承的代码演示" class="headerlink" title="024-什么是继承 &#x2F; 025-继承的代码演示"></a>024-什么是继承 &#x2F; 025-继承的代码演示</h3><h4 id="类的继承代码"><a href="#类的继承代码" class="headerlink" title="类的继承代码"></a><strong>类的继承代码</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyDerivedClass : MyBaseclass //创建类时，在类的名字后面加上一个冒号并接上需要继承的父类。</span><br><span class="line">&#123;</span><br><span class="line">functions and data members here </span><br><span class="line">//此时DerivedClass已经继承了父类的所有内容，代码块中可以加入自己独有的代码。</span><br><span class="line">&#125;</span><br><span class="line">//父类使用private权限修饰变量时，子类没办法直接调用，因此需要把父类的private修改成protected。</span><br><span class="line">//protected意义为可以在其他类里面调用，但不能在主程序里调用。</span><br></pre></td></tr></table></figure>

<h3 id="027-this和base关键字"><a href="#027-this和base关键字" class="headerlink" title="027-this和base关键字"></a>027-this和base关键字</h3><h3 id="this和base"><a href="#this和base" class="headerlink" title="this和base"></a><strong>this和base</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this和base关键字的作用：1.代码编辑器提供变量的提示；2.可以用于区分局部变量和字段。</span><br><span class="line">主要是可以区分需要调用的函数或者变量是父类还是子类里的（会出现重名的情况不好区分）。</span><br><span class="line">在需要对父类的某个函数进行重写时（两个函数名称相同），调用时就可以用this来明确调用的是子类的代码。</span><br></pre></td></tr></table></figure>

<h3 id="028-关于虚方法Virtual"><a href="#028-关于虚方法Virtual" class="headerlink" title="028-关于虚方法Virtual"></a>028-关于虚方法Virtual</h3><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a><strong>虚方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">public virtual string VirtualMethod() //在访问修饰符和返回值之前加入virtual后，方法成为虚方法。</span><br><span class="line">&#123;</span><br><span class="line">return &quot;Method is called in base class&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyDerivedClass:MyBaseClass //构造一个子类对象继承自mybaseclass。</span><br><span class="line">&#123;</span><br><span class="line">public override string VirtualMethod() //声明一个与父类中重名的函数，virtual改为override。</span><br><span class="line">&#123;</span><br><span class="line">return &quot;Method is called in derivedclass.&quot;; //函数中的代码与父类中不同，相当于重写了该函数。</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过virtual和override重写方法后，子类对象在调用该方法后默认执行重写后的函数语句。</span><br></pre></td></tr></table></figure>

<h3 id="029-隐藏方法"><a href="#029-隐藏方法" class="headerlink" title="029-隐藏方法"></a>029-隐藏方法</h3><h4 id="隐藏方法"><a href="#隐藏方法" class="headerlink" title="隐藏方法"></a><strong>隐藏方法</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">public int MyMethod() //使用隐藏方法时，父类不作任何改动。</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyDerivedClass :MyBaseClass</span><br><span class="line">&#123;</span><br><span class="line">public new void MyMethod() //子类在构造同名的方法时，在访问修饰符和返回类型之间加入new。</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//加入new意味着方法被重新构造，此时子类调用该方法后，执行的也是修改（new）后的代码。</span><br></pre></td></tr></table></figure>
      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover next lx-cover-sm" style="background-image: url(/images/footer-l.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="/2022/12/14/%E6%A1%8C%E6%B8%B8%E4%BB%8B%E7%BB%8D-%E5%8F%8C%E5%AD%90%E6%98%9F/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>桌游介绍：《双...</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover prev lx-cover-sm" style="background-image: url(/images/footer-r.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="/2022/12/12/C-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>C#学习笔记-...</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>

</div>
<div class="comment"><div id="comments"></div></div>
<footer>
  <div>
  Copyright &copy; 2022.<a href="/">Eureka的喵窝</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

</div>

<button class="hamburger hamburger--arrow-r" type="button" title="menu">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button>
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpg" alt="Eureka"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>Eureka</p>
          <span class="tagline">人生到头来就是妥协。</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>首页</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>归档</a></li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-th-list fa-fw"></i>分类</span>
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%A1%8C%E6%B8%B8/">桌游</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>页面</span>
        <ul>
          <li><a href="/about/">关于本人</a></li>
        <li><a href="/GameRecord/">游戏历程</a></li>
        <li><a href="/AnimeAndNovelRecord/">小说&amp;动画历程</a></li>
        <li><a href="/VisualStayUp/">熬夜可视化</a></li>
        <li><a href="/plan/">近期计划</a></li>
        <li><a href="/PTCG/">PTCG卡查</a></li>
        <li><a href="/weekplan/">周计划</a></li>
        <li><a href="/GuestBook/">留言簿</a></li>
        </ul>
    </li>
    
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="https://cdn.jsdelivr.net/npm/theme-lx@0.4.4/source/dist/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>



</body>
</html>
