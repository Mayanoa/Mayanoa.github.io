<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/Imgset/favicon.ico"><link rel="icon" href="/Imgset/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Eureka"><meta name="keywords" content=""><meta name="description" content="003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍断点的设置与中断模式窗口123456789设置断点的四种方法：1.右击代码⾏，选择breakpoint(断点) -&gt; insert breakpoint（插⼊断点）。2.光标定位到代码⾏，选择菜单上的Debug(调试)-&gt;Toggle Breakpoint(切换断点)。3.光标定位到代码⾏，按"><meta property="og:type" content="article"><meta property="og:title" content="C#学习笔记-面向对象"><meta property="og:url" content="http://example.com/2022/12/13/%E7%AC%94%E8%AE%B0/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html"><meta property="og:site_name" content="Eureka的喵窝"><meta property="og:description" content="003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍断点的设置与中断模式窗口123456789设置断点的四种方法：1.右击代码⾏，选择breakpoint(断点) -&gt; insert breakpoint（插⼊断点）。2.光标定位到代码⾏，选择菜单上的Debug(调试)-&gt;Toggle Breakpoint(切换断点)。3.光标定位到代码⾏，按"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/Imgpost/%E7%AC%94%E8%AE%B0/C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1cover.jpg"><meta property="article:published_time" content="2022-12-12T16:00:00.000Z"><meta property="article:modified_time" content="2023-04-06T13:18:52.424Z"><meta property="article:author" content="Eureka"><meta property="article:tag" content="编程"><meta property="article:tag" content="C#"><meta property="article:tag" content="Unity"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://example.com/Imgpost/%E7%AC%94%E8%AE%B0/C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1cover.jpg"><title>C#学习笔记-面向对象 - Eureka的喵窝</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"example.com",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!1,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Eureka的喵窝</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>档案</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/Record/GameRecord/"><span>游戏历程</span> </a><a class="dropdown-item" href="/Record/Anime&amp;NovelRecord/"><span>动画&小说历程</span> </a><a class="dropdown-item" href="/Record/GuestBook/"><span>留言簿</span> </a><a class="dropdown-item" href="/books/"><span>豆瓣书列</span></a></div></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/Imgpost/%E7%AC%94%E8%AE%B0/C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1cover.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">C#学习笔记-面向对象</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-12-13 00:00" pubdate>2022年12月13日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 86 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">C#学习笔记-面向对象</h1><div class="markdown-body"><span id="more"></span><h3 id="003-使用输出语句和Debug模式调试程序-x2F-004-中断模式下的窗口介绍"><a href="#003-使用输出语句和Debug模式调试程序-x2F-004-中断模式下的窗口介绍" class="headerlink" title="003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍"></a>003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍</h3><h4 id="断点的设置与中断模式窗口"><a href="#断点的设置与中断模式窗口" class="headerlink" title="断点的设置与中断模式窗口"></a><strong>断点的设置与中断模式窗口</strong></h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">设置断点的四种方法：<br><span class="hljs-number">1</span>.右击代码⾏，选择<span class="hljs-built_in">breakpoint</span>(断点) -&gt; insert breakpoint（插⼊断点）。<br><span class="hljs-number">2</span>.光标定位到代码⾏，选择菜单上的<span class="hljs-built_in">Debug</span>(调试)-&gt;Toggle <span class="hljs-built_in">Breakpoint</span>(切换断点)。<br><span class="hljs-number">3</span>.光标定位到代码⾏，按下F9键，在此按下F9是取消断点。<br><span class="hljs-number">4</span>.在需要添加断点的⾏⾸位置，直接单击，再次单击取消断点。<br><span class="hljs-comment">//运行程序时，会在断点的位置停下，此时可以通过窗口查看当前代码中各变量对应的值便于程序调试。</span><br><span class="hljs-comment">//显示出现的各变量的值均是当前所运行的方法中变量的值。</span><br><span class="hljs-comment">//调⽤堆栈窗⼝下可以观察到当前代码执⾏到哪⼀⾏了，且可以看到这个代码的是被什么语句调⽤的。</span><br><span class="hljs-comment">//即时窗⼝可以输⼊⼀些命令，查看变量的值，修改变量的值，可以输⼊表达式查看结果。</span><br></code></pre></td></tr></table></figure><h3 id="005-逐语句和逐过程（中断模式）"><a href="#005-逐语句和逐过程（中断模式）" class="headerlink" title="005-逐语句和逐过程（中断模式）"></a>005-逐语句和逐过程（中断模式）</h3><h4 id="逐语句和逐过程"><a href="#逐语句和逐过程" class="headerlink" title="逐语句和逐过程"></a><strong>逐语句和逐过程</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">在中断模式下我们可以单步执⾏代码，单步执⾏带有有两种：逐过程和逐语句。<br>两类单步执行都是⼀条语句⼀跳语句的执⾏，区别在于：<br>逐过程遇到函数，不会进⼊函数内部⽽把函数当成⼀条语句去执⾏。<br>而逐语句会进入函数内部并在函数内逐条执行代码。<br></code></pre></td></tr></table></figure><h3 id="006-关于程序中的异常-x2F-007-使用try-catch-finally语句处理异常"><a href="#006-关于程序中的异常-x2F-007-使用try-catch-finally语句处理异常" class="headerlink" title="006-关于程序中的异常 &#x2F; 007-使用try-catch-finally语句处理异常"></a>006-关于程序中的异常 &#x2F; 007-使用try-catch-finally语句处理异常</h3><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">异常是在运⾏期间代码中产⽣的错误。<br>异常发⽣的时候，程序会终⽌掉，然后异常后⾯的代码都⽆法执⾏。<br></code></pre></td></tr></table></figure><h4 id="异常的处理：try-catch-finally语句"><a href="#异常的处理：try-catch-finally语句" class="headerlink" title="异常的处理：try catch finally语句"></a><strong>异常的处理：try catch finally语句</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">try <span class="hljs-regexp">//</span>放置可能出现异常的代码。<br>&#123;<br>...<br>&#125;<br>catch( &lt;exceptionType&gt; e ) <span class="hljs-regexp">//</span>放置异常类型，例如IndexOutOfRangeException。<br>&#123;<br>... <span class="hljs-regexp">//</span>出现异常时如何处理（执行什么语句）。<br>&#125; <span class="hljs-regexp">//</span>catch可以并列放置多个异常类型。<br>finally <span class="hljs-regexp">//</span>无论代码是否出现异常，都会执行后续的代码。<br>&#123;<br>&#125;<br><span class="hljs-regexp">//</span>其中catch块可以有<span class="hljs-number">0</span>或者多个，finally可以有<span class="hljs-number">0</span>或者<span class="hljs-number">1</span>个。<br><span class="hljs-regexp">//</span>如果没有catch块，必须有finally块。<br><span class="hljs-regexp">//</span>没有finally块，必须有catch块，catch块和finally块可以同时存在。<br><span class="hljs-regexp">//</span>在检测用户输入是否符合要求的场合，可以使用<span class="hljs-keyword">while</span>循环+try catch的组合。<br><span class="hljs-regexp">//</span>此时在try的代码块的最后加入<span class="hljs-keyword">break</span>直接终止跳出循环，运行到<span class="hljs-keyword">break</span>说明try内的代码没有报错。<br><span class="hljs-regexp">//</span>如果运行不到<span class="hljs-keyword">break</span>说明报错了，此时执行catch语句进行处理再回到try代码块循环。<br></code></pre></td></tr></table></figure><h3 id="011-怎么定义一个类-x2F-012-创建对象和对象的使用"><a href="#011-怎么定义一个类-x2F-012-创建对象和对象的使用" class="headerlink" title="011-怎么定义一个类 &#x2F; 012-创建对象和对象的使用"></a>011-怎么定义一个类 &#x2F; 012-创建对象和对象的使用</h3><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><strong>类的定义</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Customer <span class="hljs-comment">//class+类名：定义一个类。</span><br>&#123;<br>public <span class="hljs-built_in">string</span> name;<br>public <span class="hljs-built_in">string</span> address;<br>public <span class="hljs-built_in">int</span> age;<br>public <span class="hljs-built_in">string</span> buyTime; <span class="hljs-comment">//添加变量，类似于定义一个结构体，权限默认public。</span><br>public void <span class="hljs-constructor">Show()</span> <span class="hljs-comment">//声明一个打印顾客信息的函数。</span><br>&#123;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;名字:&quot;</span>+<span class="hljs-params">name</span>)</span>;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;年龄:&quot;</span>+<span class="hljs-params">age</span>)</span>;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;地址:&quot;</span>+<span class="hljs-params">address</span>)</span>;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;购买时间:&quot;</span>+<span class="hljs-params">buyTime</span>)</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a><strong>对象的创建与使用</strong></h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ClassName myClass = <span class="hljs-keyword">new</span> <span class="hljs-type">ClassName</span>();<br>Customer c1 =<span class="hljs-keyword">new</span> <span class="hljs-type">Customer</span>(); <span class="hljs-comment">//对象也是一种变量，声明一个对象并初始化。</span><br>c1.name = ’siki‘； <span class="hljs-comment">//给c1对象里面的变量赋值。</span><br>c1.show(); <span class="hljs-comment">//调用c1对象中的函数。</span><br></code></pre></td></tr></table></figure><h3 id="013-车辆类和向量类的定义和使用-x2F-014-public和private访问权限控制"><a href="#013-车辆类和向量类的定义和使用-x2F-014-public和private访问权限控制" class="headerlink" title="013-车辆类和向量类的定义和使用 &#x2F; 014-public和private访问权限控制"></a>013-车辆类和向量类的定义和使用 &#x2F; 014-public和private访问权限控制</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">访问修饰符：<span class="hljs-keyword">public</span> /<span class="hljs-keyword">private</span><br>通过<span class="hljs-keyword">private</span>修饰定义的变量仅能在类当中去声明和访问。<br><span class="hljs-comment">//习惯上所有数据的声明都是用private。</span><br><span class="hljs-comment">//使private可以在外界访问的方法是在类中构造一个赋值作用的public函数。</span><br><span class="hljs-comment">//prvate的优势就是可以通过get获取/set设置类的方法对数据进行校验判断。</span><br></code></pre></td></tr></table></figure><h3 id="015-什么是构造函数"><a href="#015-什么是构造函数" class="headerlink" title="015-什么是构造函数"></a>015-什么是构造函数</h3><h4 id="构造函数的语法"><a href="#构造函数的语法" class="headerlink" title="构造函数的语法"></a><strong>构造函数的语法</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">构造对象时候，对象的初始化过程是⾃动完成的。<br>但是在初始化对象的过程中有的时候需要做⼀些额外的⼯作。<br>例如需要初始化对象存储的数据，构造函数就是⽤于初始化数据的函数。<br>声明基本的构造函数的语法就是声明⼀个和所在类同名的⽅法，但是该⽅法没有返回类型。<br>public class MyClass<br>&#123;<br>public MyClass() <span class="hljs-regexp">//</span>没有返回值，public后直接接一个和类myclass名称相同的函数，括号内是函数的参数。<br>&#123;<br>这个构造函数的函数体 <span class="hljs-regexp">//</span>一般是初始化时直接给构造的对象赋值，初始化时直接调用函数完成赋值。<br>&#125;<br>&#125;<br><span class="hljs-regexp">//</span>构造函数可以存在多个（需要参数不同），存在多个构造函数时根据参数的类型进行重载。<br><span class="hljs-regexp">//</span>构造函数在构造方法时默认一定会执行一次。<br><span class="hljs-regexp">//</span>创建类时可以不写构造函数，此时系统会执行默认构造函数（无参无效果）。<br><span class="hljs-regexp">//</span>如果声明了一个有参的构造函数，声明时就不能不加参数。<br><span class="hljs-regexp">//</span>构造函数赋值时可以用this.字段来表示当前对象避免参数和字段重名的问题。<br></code></pre></td></tr></table></figure><h3 id="017-属性-x2F-018-属性和匿名类型"><a href="#017-属性-x2F-018-属性和匿名类型" class="headerlink" title="017-属性 &#x2F; 018-属性和匿名类型"></a>017-属性 &#x2F; 018-属性和匿名类型</h3><h4 id="通过属性完成对象的赋值和调用"><a href="#通过属性完成对象的赋值和调用" class="headerlink" title="通过属性完成对象的赋值和调用"></a><strong>通过属性完成对象的赋值和调用</strong></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> MyIntProp <br><span class="hljs-comment">//类似于函数的设置方式，MyIntProp是函数的名字，可以自由取名，但一般是字段首字母大写。</span><br>&#123;<br>get <span class="hljs-comment">//代表获取对象字段的具体值。</span><br>&#123;<br>/get code <span class="hljs-comment">//例如return age。</span><br>&#125;<br>set<br>&#123;<br>set code <span class="hljs-comment">//例如 age = value，此处的value是固定的。</span><br>&#125;<br>&#125;<br>xiaoming.age = <span class="hljs-number">14</span>; <span class="hljs-comment">//使用时直接通过.name这样的属性方式进行赋值，不调用具体函数。</span><br>console.<span class="hljs-built_in">writeline</span>(xiaoming.age) <span class="hljs-comment">//直接获取并输出赋值后的数据信息。</span><br><span class="hljs-comment">//相当于使用同一个属性直接完成了字段的赋值与调用，是两种函数组合的简写形式。</span><br><span class="hljs-comment">//set code部分同样是可以加入if语句来对赋值进行检验处理。</span><br><span class="hljs-comment">//get和set部分同样可以在前面加入private来限制数据的访问权限。</span><br><span class="hljs-comment">//属性可以仅提供⼀个set块或者get块，未必两个都要有。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> Age&#123;get;set;&#125; <br><span class="hljs-comment">//在类中使用该代码，系统会自动创建public int age的代码，之后的get/set可以直接设置数据的访问权限。</span><br></code></pre></td></tr></table></figure><h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a><strong>匿名类型</strong></h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">创建变量（对象的时候），必须指定类型，但其实也可以不去指定类型，而是使⽤<span class="hljs-built_in">var</span>声明⼀个匿名类型。<br>使⽤<span class="hljs-built_in">var</span>声明的匿名类型，当初始化的时候，这个变量的类型就被确定下来，并且以后不可以修改。<br><span class="hljs-built_in">var</span> <span class="hljs-built_in">var1</span> = <span class="hljs-number">34</span>; //因为初始化赋值是<span class="hljs-number">34</span>，<span class="hljs-built_in">var1</span>会被系统自动设置为int类型，且无法再做类型的修改。<br></code></pre></td></tr></table></figure><h3 id="020-值类型和引用类型-x2F-023-对象引用的改变"><a href="#020-值类型和引用类型-x2F-023-对象引用的改变" class="headerlink" title="020-值类型和引用类型 &#x2F; 023-对象引用的改变"></a>020-值类型和引用类型 &#x2F; 023-对象引用的改变</h3><h4 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a><strong>值类型和引用类型</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">类型被分为两种：<br>值类型(整数，<span class="hljs-built_in">bool</span>，<span class="hljs-keyword">struct</span>，<span class="hljs-built_in">char</span>，⼩数)<br>引⽤类型（<span class="hljs-built_in">string</span> 数组 ⾃定义的类，内置的类）<br>值类型只需要⼀段单独的内存，⽤于存储实际的数据（单独定义的时候放在栈中）。<br>引⽤类型需要两段内存：第⼀段存储实际的数据，它总是位于堆中；第⼆段是⼀个引⽤，指向数据在堆中的存放位置。<br>注意使⽤引⽤类型赋值时，其实是赋值的引⽤类型的引⽤。<br>因此在两个变量均指向同一个引用时，修改其中一个引用对应的具体值，另一个变量的值也会发生同样的变化。<br></code></pre></td></tr></table></figure><h3 id="024-什么是继承-x2F-025-继承的代码演示"><a href="#024-什么是继承-x2F-025-继承的代码演示" class="headerlink" title="024-什么是继承 &#x2F; 025-继承的代码演示"></a>024-什么是继承 &#x2F; 025-继承的代码演示</h3><h4 id="类的继承代码"><a href="#类的继承代码" class="headerlink" title="类的继承代码"></a><strong>类的继承代码</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">class MyDerivedClass : MyBaseclass <span class="hljs-regexp">//</span>创建类时，在类的名字后面加上一个冒号并接上需要继承的父类。<br>&#123;<br>functions and data members here <br><span class="hljs-regexp">//</span>此时DerivedClass已经继承了父类的所有内容，代码块中可以加入自己独有的代码。<br>&#125;<br><span class="hljs-regexp">//</span>父类使用private权限修饰变量时，子类没办法直接调用，因此需要把父类的private修改成protected。<br><span class="hljs-regexp">//</span>protected意义为可以在其他类里面调用，但不能在主程序里调用。<br></code></pre></td></tr></table></figure><h3 id="027-this和base关键字"><a href="#027-this和base关键字" class="headerlink" title="027-this和base关键字"></a>027-this和base关键字</h3><h3 id="this和base"><a href="#this和base" class="headerlink" title="this和base"></a><strong>this和base</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>和base关键字的作用：<span class="hljs-number">1.</span>代码编辑器提供变量的提示；<span class="hljs-number">2.</span>可以用于区分局部变量和字段。<br>主要是可以区分需要调用的函数或者变量是父类还是子类里的（会出现重名的情况不好区分）。<br>在需要对父类的某个函数进行重写时（两个函数名称相同），调用时就可以用<span class="hljs-keyword">this</span>来明确调用的是子类的代码。<br></code></pre></td></tr></table></figure><h3 id="028-关于虚方法Virtual"><a href="#028-关于虚方法Virtual" class="headerlink" title="028-关于虚方法Virtual"></a>028-关于虚方法Virtual</h3><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a><strong>虚方法</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBaseClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> <span class="hljs-title">VirtualMethod</span>() <span class="hljs-comment">//在访问修饰符和返回值之前加入virtual后，方法成为虚方法。</span></span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Method is called in base class&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass</span>:<span class="hljs-title">MyBaseClass</span> <span class="hljs-comment">//构造一个子类对象继承自mybaseclass。</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">VirtualMethod</span>() <span class="hljs-comment">//声明一个与父类中重名的函数，virtual改为override。</span></span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Method is called in derivedclass.&quot;</span>; <span class="hljs-comment">//函数中的代码与父类中不同，相当于重写了该函数。</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//通过virtual和override重写方法后，子类对象在调用该方法后默认执行重写后的函数语句。</span><br></code></pre></td></tr></table></figure><h3 id="029-隐藏方法"><a href="#029-隐藏方法" class="headerlink" title="029-隐藏方法"></a>029-隐藏方法</h3><h4 id="隐藏方法"><a href="#隐藏方法" class="headerlink" title="隐藏方法"></a><strong>隐藏方法</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBaseClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyMethod</span>() <span class="hljs-comment">//使用隐藏方法时，父类不作任何改动。</span></span><br>&#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass</span> :<span class="hljs-title">MyBaseClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>() <span class="hljs-comment">//子类在构造同名的方法时，在访问修饰符和返回类型之间加入new。</span></span><br>&#123;<br>&#125;<br>&#125;<br><span class="hljs-comment">//加入new意味着方法被重新构造，此时子类调用该方法后，执行的也是修改（new）后的代码。</span><br></code></pre></td></tr></table></figure><h3 id="030-抽象类和密封类"><a href="#030-抽象类和密封类" class="headerlink" title="030-抽象类和密封类"></a>030-抽象类和密封类</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Building</span> <span class="hljs-comment">//在创建类的最前面添加abstract表示构造抽象类。</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">CalculateHeatingCost</span>()</span>; <span class="hljs-comment">//抽象类下可以构造抽象方法，语法一样。</span><br>&#125;<br><span class="hljs-comment">//抽象方法就是没有具体函数体的方法。</span><br></code></pre></td></tr></table></figure><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a><strong>密封类</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">sealed FinalClass <span class="hljs-regexp">//</span>sealed表示设置为密封类，同理还有密封方法。<br>&#123;<br><span class="hljs-regexp">//</span> etc<br>&#125;<br>对于类，密封表示不能继承该类；对于⽅法，密封表示不能重写该⽅法。<br><span class="hljs-regexp">//</span>密封的作用主要是代码中防止类和方法被多次重写而变得混乱。<br></code></pre></td></tr></table></figure><h3 id="031-子类的构造函数"><a href="#031-子类的构造函数" class="headerlink" title="031-子类的构造函数"></a>031-子类的构造函数</h3><h4 id="子类的构造函数"><a href="#子类的构造函数" class="headerlink" title="子类的构造函数"></a><strong>子类的构造函数</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>():<span class="hljs-title">base</span>() <span class="hljs-comment">//在构造函数后面加冒号和父类，调用父类的默认构造函数。</span></span><br>&#123;<br><span class="hljs-comment">//do something</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//这里:base()的代码不写也会默认先调用父类的构造函数。</span><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyDerivedClass</span><br>&#123;<br><span class="hljs-keyword">public</span> MyDerivedClass(<span class="hljs-built_in">string</span> name):base(name) <span class="hljs-comment">//调用有具体参数的父类构造函数。</span><br>&#123;<br><span class="hljs-comment">//do something</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//相当于先调用了父类的有参构造函数。</span><br></code></pre></td></tr></table></figure><h3 id="032-修饰符和怎么访问别的项目下的类"><a href="#032-修饰符和怎么访问别的项目下的类" class="headerlink" title="032-修饰符和怎么访问别的项目下的类"></a>032-修饰符和怎么访问别的项目下的类</h3><h4 id="访问其他项目下的类"><a href="#访问其他项目下的类" class="headerlink" title="访问其他项目下的类"></a><strong>访问其他项目下的类</strong></h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">三个步骤：<br><span class="hljs-number">1.</span>在需要引用其他项目的项目下添加其他项目的引用。<br><span class="hljs-number">2.</span>在项目最开始的代码引入需要引用的项目的命名空间。<br><span class="hljs-number">3.</span>把需要引用的类的访问权限设置为<span class="hljs-keyword">public</span>。<br></code></pre></td></tr></table></figure><h3 id="033-其他修饰符和readonly"><a href="#033-其他修饰符和readonly" class="headerlink" title="033-其他修饰符和readonly"></a>033-其他修饰符和readonly</h3><h4 id="只读修饰符readonly"><a href="#只读修饰符readonly" class="headerlink" title="只读修饰符readonly"></a><strong>只读修饰符readonly</strong></h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">只读修饰符<span class="hljs-keyword">readonly</span>：声明只读字段。<br>只读字段可以在声明或构造函数中初始化，每个类或结构的实例都有⼀个独⽴的副本。<br>可以与<span class="hljs-keyword">static</span>⼀起使⽤，声明静态只读字段。<br>静态只读字段可以在声明或静态构造函数中初始化，静态常量字段只有⼀个副本。<br>简单来说就是只能在声明和构造函数中赋值，不能后期再对只读的字段进行值的修改。<br></code></pre></td></tr></table></figure><h3 id="034-static静态的"><a href="#034-static静态的" class="headerlink" title="034-static静态的"></a>034-static静态的</h3><h4 id="静态修饰符"><a href="#静态修饰符" class="headerlink" title="静态修饰符"></a><strong>静态修饰符</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">使⽤<span class="hljs-keyword">static</span>修饰的类为静态类，静态类所有成员都必须是静态的，不能与<span class="hljs-keyword">abstract</span>、<span class="hljs-keyword">sealed</span>⼀起使⽤。<br><span class="hljs-keyword">static</span>可以修饰⽅法、字段、属性或事件，始终通过类名⽽不是实例名称访问静态成员，静态字段只有⼀个副本。<br>静态类不能被实例化。<br>简单来说就是被<span class="hljs-keyword">static</span>修饰的方法/属性只能通过类访问而不能通过实例访问。<br>例如某个类下边有若干个静态属性和通常属性，在实例化该类时，创建的类不能赋值静态属性。<br></code></pre></td></tr></table></figure><h3 id="035-什么是接口-x2F-036-接口的继承"><a href="#035-什么是接口-x2F-036-接口的继承" class="headerlink" title="035-什么是接口 &#x2F; 036-接口的继承"></a>035-什么是接口 &#x2F; 036-接口的继承</h3><h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a><strong>接口的声明</strong></h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IFlyHandler</span> //一般接口的名字使用<span class="hljs-symbol">I</span>字母开头，表示是接口而不是类。<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> Fly(); <span class="hljs-comment">//接口里面会有一个空的方法。</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Type1Enemy:<span class="hljs-symbol">IFlyHandler</span></span> //调用接口，类似于继承的代码。<br>&#123;<br>&#125;<br>定义⼀个接⼝在语法上跟定义⼀个抽象类完全相同，但不允许提供接⼝中任何成员的实现⽅式.<br>⼀般情况下，接⼝只能包含⽅法，属性，索引器和事件的声明。<br>接⼝不能有构造函数，也不能有字段，接⼝也不允许运算符重载。<br>接⼝定义中不允许声明成员的修饰符，接⼝成员都是公有的。<br></code></pre></td></tr></table></figure><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a><strong>接口的继承</strong></h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">A</span><br>&#123;<br><span class="hljs-built_in">void</span> Method1();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">B</span>:<span class="hljs-symbol">A</span> //相当于拥有了<span class="hljs-symbol">interfaceA</span>接口的方法，所以需要实现<span class="hljs-symbol">method1</span>和<span class="hljs-symbol">method2</span>的方法。<br>&#123;<br><span class="hljs-built_in">void</span> Method2();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="043-什么是列表和列表的创建添加遍历访问"><a href="#043-什么是列表和列表的创建添加遍历访问" class="headerlink" title="043-什么是列表和列表的创建添加遍历访问"></a>043-什么是列表和列表的创建添加遍历访问</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">当有很多类型⼀样的数据的时候，⼀般使⽤数组来进⾏管理。<br>但是这样有个缺点就是数组的⼤⼩是固定的。<br>如果很多类型⼀样的数据⽐如游戏得分，可以用集合类来进⾏管理，⽐如列表<span class="hljs-built_in">List</span>。<br>使⽤列表<span class="hljs-built_in">List</span>可以很⽅便的添加数据，删除数据，以及其他对数据的操作。<br></code></pre></td></tr></table></figure><h4 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a><strong>列表的创建</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; scoreList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//创建一个叫scorelist的数据集合，需要指定集合的数据类型。</span><br><span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;()&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//给list添加三个数据。</span><br><span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;()&#123;<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>&#125;<br><span class="hljs-keyword">var</span> scoreList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br></code></pre></td></tr></table></figure><h3 id="列表数据的添加"><a href="#列表数据的添加" class="headerlink" title="列表数据的添加"></a><strong>列表数据的添加</strong></h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">scoreList</span>.Add(<span class="hljs-number">12</span>); //使用add方法添加<span class="hljs-number">12</span>这个数据。<br><span class="hljs-attribute">scoreList</span>.Add(<span class="hljs-number">45</span>);<br></code></pre></td></tr></table></figure><h3 id="列表数据的访问"><a href="#列表数据的访问" class="headerlink" title="列表数据的访问"></a><strong>列表数据的访问</strong></h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.writeline(scorelist[<span class="hljs-number">3</span>]); <span class="hljs-comment">//和数组一样通过索引进行访问。</span><br>socrelist.<span class="hljs-built_in">count</span>; <br><span class="hljs-comment">//count是list的一个属性，表示list中的数据个数，可以用count结合for循环对list进行遍历。</span><br></code></pre></td></tr></table></figure><h3 id="044-关于列表的内部数据管理"><a href="#044-关于列表的内部数据管理" class="headerlink" title="044-关于列表的内部数据管理"></a>044-关于列表的内部数据管理</h3><h4 id="列表的容量"><a href="#列表的容量" class="headerlink" title="列表的容量"></a><strong>列表的容量</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">List.Capacity; <span class="hljs-regexp">//</span>和count一样是list的一个属性，表示list当前可以存放的数据个数即容量。<br><span class="hljs-regexp">//</span>注意capacity和count的区别，count是列表内的数据个数，而capacity是存放数据的个数上限。<br></code></pre></td></tr></table></figure><h3 id="045-列表的一些常见操作"><a href="#045-列表的一些常见操作" class="headerlink" title="045-列表的一些常见操作"></a>045-列表的一些常见操作</h3><h4 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a><strong>列表的遍历</strong></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span>循环，遍历所有的索引，通过索引访问列表中的元素。<br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i=<span class="hljs-number">0</span>;i&lt;list.Count;i++)</span></span><br>&#123;<br><span class="hljs-comment">//循环体list[i]</span><br>&#125;<br>foreach遍历<br><span class="hljs-function"><span class="hljs-title">foreach</span><span class="hljs-params">(int temp in list)</span></span>  <span class="hljs-comment">//依次取得list中的每⼀个元素赋值给temp，并执⾏循环体。</span><br>&#123;<br><span class="hljs-comment">//循环体 temp</span><br>&#125;<br><span class="hljs-comment">//和数组的遍历没有区别。</span><br></code></pre></td></tr></table></figure><h4 id="列表的常见操作"><a href="#列表的常见操作" class="headerlink" title="列表的常见操作"></a><strong>列表的常见操作</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.list.capacity; <span class="hljs-regexp">//</span>获取list的容量。<br><span class="hljs-number">2</span>.list.add(); <span class="hljs-regexp">//</span>给list添加数据。<br><span class="hljs-number">3</span>.list[index]; <span class="hljs-regexp">//</span>通过索引给访问list的具体数据。<br><span class="hljs-number">4</span>.list.insert([index],数据); <span class="hljs-regexp">//</span>在指定索引前面插入一个数据。<br><span class="hljs-regexp">//</span>注意索引还是从<span class="hljs-number">0</span>开始的。<br><span class="hljs-number">5</span>.list.remove(数据); <span class="hljs-regexp">//</span>删除list中第一个与输入数据相同的数据。<br><span class="hljs-number">6</span>.list.removeat([index]); <span class="hljs-regexp">//</span>删除list中相应索引的数据。<br><span class="hljs-number">7</span>.list.indexof(数据); <span class="hljs-regexp">//</span>查询list中第一个对应数据所在的索引，如果没有匹配数据会返回-<span class="hljs-number">1</span>。<br><span class="hljs-number">8</span>.list.LastIndexOf(数据); <span class="hljs-regexp">//</span>从后往前查询第一个对应数据所在的索引。<br><span class="hljs-number">9</span>.list.sort(); <span class="hljs-regexp">//</span>对列表中元素从小到大进行排序。<br></code></pre></td></tr></table></figure><h3 id="046-泛型-x2F-泛型类"><a href="#046-泛型-x2F-泛型类" class="headerlink" title="046-泛型&#x2F;泛型类"></a>046-泛型&#x2F;泛型类</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp">定义⼀个泛型类就是指的是，定义⼀个类，这个类中某些字段的类型是不确定的。<br>这些类型可以在类构造的时候确定下来。<br>举例:创建⼀个类处理<span class="hljs-built_in">int</span>类型和<span class="hljs-built_in">double</span>类型的相加。<br><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-comment">//习惯性后边加个中括号&lt;T&gt;</span><br>&#123;<br><span class="hljs-keyword">private</span> T a; <br><span class="hljs-keyword">private</span> T b; <span class="hljs-comment">//a和b的类型都是T类型了。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassA</span>(<span class="hljs-params">T a,T b</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.a = a ;<br><span class="hljs-keyword">this</span>.b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetSum</span>()</span><br>&#123;<br><span class="hljs-built_in">dynamic</span> num1 = a;<br><span class="hljs-built_in">dynamic</span> num2 = b; <span class="hljs-comment">//声明两个dynamic类型的a和b然后相加。</span><br><span class="hljs-built_in">dynamic</span> result = num1 + num2;<br><span class="hljs-keyword">return</span> (T)result; <span class="hljs-comment">//将dynamic类型的相加结果强制转换为T类型。</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//在声明类时把T直接替换为需要的类型，再调用getsum()函数即可实现自己指定数据类型的函数效果。</span><br></code></pre></td></tr></table></figure><h3 id="048-泛型方法"><a href="#048-泛型方法" class="headerlink" title="048-泛型方法"></a>048-泛型方法</h3><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><strong>泛型方法</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">GetSum</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a,T b</span>)</span><br>&#123;<br><span class="hljs-built_in">dynamic</span> num1 = a;<br><span class="hljs-built_in">dynamic</span> num2 = b;<br><span class="hljs-built_in">dynamic</span> result = num1 + numb; <span class="hljs-comment">//和泛型类的定义基本一致。</span><br><span class="hljs-keyword">return</span> (T) result;<br>&#125;<br>GetSum&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">23</span>,<span class="hljs-number">12</span>);<br>GetSum&lt;<span class="hljs-built_in">double</span>&gt;(<span class="hljs-number">23.2</span>,<span class="hljs-number">12</span>); <span class="hljs-comment">//调用时指定好T位置的类型然后正常使用方法即可。</span><br></code></pre></td></tr></table></figure><h3 id="049-创建自己的MyList列表-x2F-050-通过索引器访问列表里面的数据"><a href="#049-创建自己的MyList列表-x2F-050-通过索引器访问列表里面的数据" class="headerlink" title="049-创建自己的MyList列表 &#x2F; 050-通过索引器访问列表里面的数据"></a>049-创建自己的MyList列表 &#x2F; 050-通过索引器访问列表里面的数据</h3><h4 id="Mylist"><a href="#Mylist" class="headerlink" title="Mylist"></a><strong>Mylist</strong></h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mylist</span>&lt;T&gt; <span class="hljs-comment">//声明一个mylist类。</span><br>&#123;<br><span class="hljs-keyword">private</span> T[] data = <span class="hljs-keyword">new</span> T[<span class="hljs-number">0</span>]; <span class="hljs-comment">//初始化一个T类型名称为data的数组。</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化时连带着声明数组目前的元素个数，默认为0。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> capacity <span class="hljs-comment">//声明一个名称为capacity的方法。</span><br>&#123;<br>get<br>&#123;<br><span class="hljs-keyword">return</span> data.length; <span class="hljs-comment">//返回data数组的长度。</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> <span class="hljs-comment">//声明一个名称为count的方法。</span><br>&#123;<br>get<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> add(T item)<br>&#123;<br><span class="hljs-keyword">if</span> (data.length == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断data数组的长度是否为0。</span><br>&#123;<br>data =<span class="hljs-keyword">new</span> T[<span class="hljs-number">4</span>]; <span class="hljs-comment">//如果长度为0，重设一个长度为4的数组。</span><br>&#125;<br><span class="hljs-keyword">if</span> (data.length == <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断当前数组是不是已经满了。</span><br>&#123;<br>T[] temp = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">count</span> * <span class="hljs-number">2</span>]; <span class="hljs-comment">//重新创建一个长度为count两倍的临时数组。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt;data.length;i++)<br>&#123;<br>temp [i] = data[i];<br>&#125;<br>data = temp; <span class="hljs-comment">//将数据迁移完毕的temp数组再重新赋值给data，完成数据迁移。</span><br>&#125;<br>data[<span class="hljs-keyword">count</span>] = item; <span class="hljs-comment">//将需要添加的元素赋值给数值等同于count的索引，表明在最后添加了一组数据。</span><br><span class="hljs-keyword">count</span>++; <span class="hljs-comment">//添加完毕后，count也需要自增一次。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span> [<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>] <span class="hljs-comment">//创建索引器。</span><br>get<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断索引是否越界了。</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> system.argumentoutofrangeexception(”参数超出范围了“); <span class="hljs-comment">//抛异常。</span><br>&#125;<br><span class="hljs-keyword">return</span> data[<span class="hljs-keyword">index</span>];<br>&#125;<br>set<br>&#123;<br>data[<span class="hljs-keyword">index</span>] = value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> insert(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>, T item)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断索引是否越界了。</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> system.argumentoutofrangeexception(”参数超出范围了“); <span class="hljs-comment">//抛异常。</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i =<span class="hljs-keyword">count</span><span class="hljs-number">-1</span>;i&gt;<span class="hljs-keyword">index</span><span class="hljs-number">-1</span>;i--)<br>&#123;<br><span class="hljs-built_in">date</span> [i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">date</span>[i] <span class="hljs-comment">//index后面的数据每个向后移一位。</span><br>&#125;<br><span class="hljs-built_in">date</span> [<span class="hljs-keyword">index</span>] = item;  <span class="hljs-comment">//在index索引位插入item数据。</span><br><span class="hljs-keyword">count</span>++; <span class="hljs-comment">//count自增。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> removeat(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断索引是否越界了。</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> system.argumentoutofrangeexception(”参数超出范围了“); <span class="hljs-comment">//抛异常。</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i =<span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>;i&lt;<span class="hljs-keyword">count</span>;i++)<br>&#123;<br><span class="hljs-built_in">date</span> [i<span class="hljs-number">-1</span>] = data[i]; <span class="hljs-comment">//数据前移。</span><br>&#125;<br><span class="hljs-keyword">count</span>--; <span class="hljs-comment">//count自减。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> indexof(T item)<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">-1</span>; <span class="hljs-comment">//默认值设置为-1。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">count</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span> (item.equals(data[i])) <span class="hljs-comment">//equals方法判断两个值是否相等。</span><br>&#123;<br><span class="hljs-keyword">index</span> = i; <span class="hljs-comment">//将index赋值为找到的索引。</span><br><span class="hljs-keyword">break</span>; <span class="hljs-comment">//中断循环</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span>; <span class="hljs-comment">//返回index。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> sort()<br>&#123;<br>array.sort(data,<span class="hljs-number">0</span>,<span class="hljs-keyword">count</span>) <span class="hljs-comment">//调用array.sort方法将data数组的第0个索引到第count个索引进行排序。</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="052-Equals方法-x2F-课程完结"><a href="#052-Equals方法-x2F-课程完结" class="headerlink" title="052-Equals方法 &#x2F; 课程完结"></a>052-Equals方法 &#x2F; 课程完结</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">a.equal<span class="hljs-params">(b)</span>; <span class="hljs-string">//</span>判断a和b是否相等，如果是返回<span class="hljs-literal">true</span>，如果不是返回<span class="hljs-literal">false</span>。<br><span class="hljs-string">//</span>对于对象（引用类型），比较的是内存地址，因此即使看起来相等还是会返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AC%94%E8%AE%B0/" class="category-chain-item">笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E7%BC%96%E7%A8%8B/">#编程</a> <a href="/tags/C/">#C#</a> <a href="/tags/Unity/">#Unity</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2022/12/14/%E6%A1%8C%E6%B8%B8/%E6%A1%8C%E6%B8%B8%E4%BB%8B%E7%BB%8D-%E5%8F%8C%E5%AD%90%E6%98%9F/" title="桌游介绍：《双子星》"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">桌游介绍：《双子星》</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2022/12/12/%E7%AC%94%E8%AE%B0/C-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="C#学习笔记-编程基础"><span class="hidden-mobile">C#学习笔记-编程基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> & Eureka & <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>