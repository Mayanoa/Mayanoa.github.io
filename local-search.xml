<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>年度游戏总结（2023）</title>
    <link href="/2023/04/06/%E6%9D%82%E8%B0%88/2023%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/06/%E6%9D%82%E8%B0%88/2023%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p align="justify">　　2023年大概率会分比较多的精力放在TCG实体卡牌上，电子游戏玩的估计会少一点，为了避免年底再花很多时间去写总结，所以选择用以月度总结的方式来给一整年的电子游戏经历做个总结了。<h2 id="B级-可以一玩"><a href="#B级-可以一玩" class="headerlink" title="B级 [可以一玩]"></a>B级 [可以一玩]</h2><h3 id="索尼克-未知边境"><a href="#索尼克-未知边境" class="headerlink" title="索尼克 未知边境"></a>索尼克 未知边境</h3><p align="justify">点评：本来只是冲着索尼克这个IP和高速跑酷的玩法才入的游戏，没想到实际玩下来远超预期，系列传统的关卡制跑酷作为优质的填充物，与清单式开放世界的游戏类型有机地结合在了一起，为索尼克这个历史悠久的老IP注入了新的活力。地图中大量的跑酷轨道和加速机关巧妙地串联起地图中地各个重要节点并起到了指引的作用，可以看作是一种比较新鲜的做法，也让玩家在地图探索的过程中时刻有足以吸引注意力的游戏内容，使得跑图体验不至于变得比较枯燥。游戏的音乐和战斗演出保持了一贯的高水准，尤其每个章节最后的BOSS战在演出上的设计都很出彩。经典跑酷关卡在路线和镜头方面的设计在兼顾新玩家体验的同时，也给到了较大的操作空间，很适合没有接触过索尼克系列的新玩家来体验体验。个人的评级没有给到更高是因为本作确实还存在一些不足之处，比较明显的问题就是在主机端方面的优化没做好，玩家所处位置远处的各种跑酷机关经常是不会加载出来，一定要玩家自己靠过去再凭空加载出现，而很多收集点偏偏又是需要在较远的距离观察机关的路径才能知道要怎么过去，非常影响全收集的进度和体验。作为清单式开放游戏，游戏的主线推进过于公式化，大地图的填充内容也有限，所以探索地图的驱动力做得也不太够，希望未来索尼克系列可以在本作的基础上做出更多的改进和提升吧。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2023%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E7%B4%A2%E5%B0%BC%E5%85%8B.jpg"></p><h3 id="天堂的陌生人-最终幻想起源"><a href="#天堂的陌生人-最终幻想起源" class="headerlink" title="天堂的陌生人 最终幻想起源"></a>天堂的陌生人 最终幻想起源</h3><p align="justify">点评：本作三个DLC的推出得实在太墨迹，最后一个DLC的推出时间都快是游戏正式发售一年后了，考虑到三个DLC的内容量确实是比较丰富，所以还是等到现在游戏正式完结之后再做点评。本作推出初期就差评如潮，游戏的实体碟价格也崩盘了，从一年后的完全体来看，个人感觉是个优点缺点都非常突出的游戏。缺点就是游戏的卖相实在是稀碎，画面不仅梦回PS3，大量高对比度的色彩运用让部分地图的游玩体验简直成为了灾难，不管是亮的地图还是暗的地图，玩久了都感觉眼睛不舒服。游戏的动作系统底子非常好，不同职业机制各有特色，灵魂护盾和魔力槽的资源设计完成度也非常高，但就动作体验来说，本作依然保持了TeamNinja一贯的高水准。后续更新的三个DLC和仁王如出一辙，DLC1做成负重模式让玩家自选DEBUFF拿更强的装备，DLC2推出一个爬塔式的深层迷宫，DLC3增加迷宫层数并加剧数值膨胀，总之又是把游戏推向了刷刷刷的装备驱动，需要玩家通过继承词条和各种不同的强化做出一套Build，把输出拉满直接秒了BOSS，我做全成就的过程中做了一套斩铁剑，一发满蓄斩铁剑直接就是六位数的伤害，搭配替身术的免伤机制，在40层以内没有任何一个BOSS能扛得住四刀。虽然通过暴力的数值提升秒各种BOSS很爽，但游戏优秀的动作系统也因此形同虚设，个人不太喜欢这种强数值导向的游戏设计，期待TeamNinja未来推出更侧重于传统ACT的优质动作游戏，别老惦记刷刷刷和数值膨胀了。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2023%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B3%E8%B5%B7%E6%BA%90.jpg"></p><h3 id="罗德岛战记-蒂德莉特的奇境冒险"><a href="#罗德岛战记-蒂德莉特的奇境冒险" class="headerlink" title="罗德岛战记 蒂德莉特的奇境冒险"></a>罗德岛战记 蒂德莉特的奇境冒险</h3><p align="justify">点评：大概10个小时就能全通的恶魔城Like游戏，不管是地图设计还是武器设计都明显有恶魔城的既视感。本作的特色在于两种精灵属性的自由切换，玩家在精灵加护下可以完全吸收同属性的攻击并转化为自己的蓝量，使得相当一部分BOSS战都是初见摸清出招规律和属性后直接就站在BOSS技能里洗澡狂飙魔法了，在恶魔城Like类游戏里感觉是很大胆也很新鲜的设计。本作的BOSS设计普遍还不错，但常规敌人的设计相比之下就少了些花样，关卡流程中会掺杂一些利用弓箭机制完成的解谜和简单的跳跳乐，实际体验下来反而不是很好，有些断节奏，部分需要利用弓箭折射机制完成的机关解谜如果摸不到处理方式，玩起来会很烦躁。由于流程实在太短，本作的玩法深度较浅，即使是BOSSRUSH玩法也就是用不间断的魔法数值碾压十来个BOSS，因此仅能当作是一次性不间断打完的调剂类小游戏来看待，适合在游戏荒的时候完全不看攻略花一个周末的时间打个通关，体验会比较不错。<p><p align="justify">　<h3 id="Omno"><a href="#Omno" class="headerlink" title="Omno"></a>Omno</h3><p align="justify">点评：全流程大概也就5个小时左右的独立游戏，玩法偏向于3D平台跳跃，深度一般，关卡中会穿插一些解谜环节，但复杂度和难度都非常低。游戏的基调会有些偏向于单机版本的《风之旅人》，一样都是跨越各种不同的地貌环境找朝圣之路顺带着看看风景。本作的画面和音乐在独立游戏中算是比较高的水准，但玩法层面并没有做出什么新意，实际玩下来就感觉特别平淡，没有什么突出的游戏性。游戏性的匮乏某种意义上也算不上坏事，适合在不想玩偏重度的、考验操作的游戏时，可以试着玩玩这款游戏调节一下身心。<p><p align="justify">　]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主机游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#学习笔记-坦克大战</title>
    <link href="/2023/01/11/%E7%AC%94%E8%AE%B0/C-%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/"/>
    <url>/2023/01/11/%E7%AC%94%E8%AE%B0/C-%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h3 id="03-类型转换"><a href="#03-类型转换" class="headerlink" title="03-类型转换"></a>03-类型转换</h3><h4 id="数据的强制转换"><a href="#数据的强制转换" class="headerlink" title="数据的强制转换"></a><strong>数据的强制转换</strong></h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">把<span class="hljs-keyword">a</span>赋值给b时，如果b的数据类型更大，会自动转换。<br>如果b的数据类型要比<span class="hljs-keyword">a</span>小，需要使用强制转换，通过（数据类型）的方式转换。<br>例如：<span class="hljs-keyword">a</span> = int(c)<br></code></pre></td></tr></table></figure><h4 id="类的强制转换"><a href="#类的强制转换" class="headerlink" title="类的强制转换"></a><strong>类的强制转换</strong></h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Father f <span class="hljs-operator">=</span> new Son()<span class="hljs-comment">;</span><br>Son s <span class="hljs-operator">=</span> (Son)f<span class="hljs-comment">; //把父类型的f强制转换为子类型。</span><br>Son s <span class="hljs-operator">=</span> f as Son<span class="hljs-comment">; //强制转换类时更常用的写法。</span><br>注意必须把父类声明为子类时才能强制转换，声明完全父类的类是不能强制转换成子类的。<br></code></pre></td></tr></table></figure><h3 id="04-多线程：线程的创建"><a href="#04-多线程：线程的创建" class="headerlink" title="04-多线程：线程的创建"></a>04-多线程：线程的创建</h3><h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a><strong>线程的创建</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> ChildThreadMethod <span class="hljs-comment">//创建一个名称为childThread的子线程方法。</span><br>&#123;<br>console.<span class="hljs-keyword">writeline</span>(<span class="hljs-string">&quot;childthread running&quot;</span>);<br>&#125;<br><br>Thread childThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ThreadStart(ChildThreadMethod));<br> <span class="hljs-comment">//在main函数里声明一个名为start的子线程。</span><br>childThread.Start(); <span class="hljs-comment">//启动线程。</span><br></code></pre></td></tr></table></figure><h3 id="05-多线程：线程的同步执行"><a href="#05-多线程：线程的同步执行" class="headerlink" title="05-多线程：线程的同步执行"></a>05-多线程：线程的同步执行</h3><h4 id="线程的暂停"><a href="#线程的暂停" class="headerlink" title="线程的暂停"></a><strong>线程的暂停</strong></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//令线程暂停1毫秒。</span><br>childthrad.<span class="hljs-built_in">abort</span>(); <span class="hljs-comment">//强制终止子线程。</span><br></code></pre></td></tr></table></figure><h3 id="08-设置窗体的生成位置"><a href="#08-设置窗体的生成位置" class="headerlink" title="08-设置窗体的生成位置"></a>08-设置窗体的生成位置</h3><h4 id="设置窗体的生成位置"><a href="#设置窗体的生成位置" class="headerlink" title="设置窗体的生成位置"></a><strong>设置窗体的生成位置</strong></h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.StartPosition = FormStartPosition.CenterScreen; <br><span class="hljs-comment">//调用startposition方法设置窗体的生成位置。</span><br><span class="hljs-keyword">this</span>.StartPosition = FormStartPosition.Manual;<br><span class="hljs-keyword">this</span>.Location = new Point(<span class="hljs-number">200</span>, <span class="hljs-number">500</span>);<br><span class="hljs-comment">//人工设置窗体的生成坐标，以屏幕左上角为原点，像素计量。</span><br></code></pre></td></tr></table></figure><h3 id="09-如何绘制直线和字符串"><a href="#09-如何绘制直线和字符串" class="headerlink" title="09-如何绘制直线和字符串"></a>09-如何绘制直线和字符串</h3><h4 id="绘制直线和字符串"><a href="#绘制直线和字符串" class="headerlink" title="绘制直线和字符串"></a><strong>绘制直线和字符串</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Graphics g = this.<span class="hljs-constructor">CreateGraphics()</span>; <span class="hljs-comment">//声明一个绘制图形的画布。</span><br>Pen p = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Pen(Color.Black)</span>; <span class="hljs-comment">//声明一个颜色为黑色的画笔。</span><br>g.<span class="hljs-constructor">DrawLine(<span class="hljs-params">p</span>, <span class="hljs-params">new</span> Point(0, 0)</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">Point(100, 100)</span>); <span class="hljs-comment">//声明需要绘制一条直线并给出横线的起止坐标。</span><br><span class="hljs-comment">//注意图形的绘制需要放在paint事件下面而不是窗体程序的生成事件下面。</span><br>g.<span class="hljs-constructor">DrawString(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-params">new</span> Font(<span class="hljs-string">&quot;Arial&quot;</span>, 20)</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">SolidBrush(Color.Black)</span>, <span class="hljs-keyword">new</span> <span class="hljs-constructor">Point(100, 100)</span>);<br><span class="hljs-comment">//声明需要绘制一个字符串，分别需要给到字体、笔刷（粗细/颜色）和绘制左边。</span><br></code></pre></td></tr></table></figure><h3 id="10-如何绘制图片"><a href="#10-如何绘制图片" class="headerlink" title="10-如何绘制图片"></a>10-如何绘制图片</h3><h4 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a><strong>绘制图片</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Image image = Properties.Resources.Boss; <span class="hljs-comment">//调用properties命名空间下的resource资源。</span><br>Graphics g = this.<span class="hljs-constructor">CreateGraphics()</span>;<br>g.<span class="hljs-constructor">DrawImage(<span class="hljs-params">image</span>, <span class="hljs-params">new</span> Point(200, 200)</span>); <span class="hljs-comment">//绘制指定的图片。</span><br>Bitmap image2 = Properties.Resources.Star1; <span class="hljs-comment">//也可以用bitmap类型来接收图片资源。</span><br>image2.<span class="hljs-constructor">MakeTransparent(Color.Black)</span>; <span class="hljs-comment">//bitmap有maketransparent方法，作用是将某个颜色处理为透明。</span><br>g.<span class="hljs-constructor">DrawImage(<span class="hljs-params">image2</span>, 100, 100)</span>; <span class="hljs-comment">//坐标也可以直接用两个数字隔开来声明。</span><br></code></pre></td></tr></table></figure><h3 id="11-设计游戏高宽和标题"><a href="#11-设计游戏高宽和标题" class="headerlink" title="11-设计游戏高宽和标题"></a>11-设计游戏高宽和标题</h3><h4 id="设置游戏宽高和标题"><a href="#设置游戏宽高和标题" class="headerlink" title="设置游戏宽高和标题"></a><strong>设置游戏宽高和标题</strong></h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">可以在designer的代码下面修改窗体程序的高度宽度以及标题。<br>高度与宽度：ClientSize<br>窗体标题：<span class="hljs-built_in">text</span><br></code></pre></td></tr></table></figure><h3 id="12-开发游戏框架"><a href="#12-开发游戏框架" class="headerlink" title="12-开发游戏框架"></a>12-开发游戏框架</h3><h4 id="设计游戏的基本框架"><a href="#设计游戏的基本框架" class="headerlink" title="设计游戏的基本框架"></a><strong>设计游戏的基本框架</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> Thread t;<br>t = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ThreadStart(GameMainThread)); <span class="hljs-comment">//在Main方法中声明GameMainThread类型的线程。</span><br>t.Start(); <span class="hljs-comment">//开启t线程。</span><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GameMainThread</span>() <span class="hljs-comment">//设置GameMainThread类型线程的命名逻辑。</span></span><br>&#123;<br>GameFrameWork.Start(); <span class="hljs-comment">//线程启动后，运行GameFrameWork类中的start方法。</span><br><span class="hljs-built_in">int</span> sleeptime = <span class="hljs-number">1000</span> / <span class="hljs-number">60</span>; <span class="hljs-comment">//设定一个游戏刷新的帧率。</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>GameFrameWork.Update(); <span class="hljs-comment">//设计一个死循环，持续运行update刷新方法。</span><br>Thread.Sleep(sleeptime); <span class="hljs-comment">//每运行一次update以后程序休眠帧率时间，保证程序正常运行。</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Form1_FormClosed</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, FormClosedEventArgs e</span>)</span><br>&#123;<br>t.Abort(); <span class="hljs-comment">//设置一个关闭程序窗体的事件，在关闭窗体后，终止t线程的运行，完全终止程序。</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">GameFrameWork</span> <span class="hljs-comment">//声明一格GameFrameWork名称的框架，包含游戏开始和持续刷新的两个人方法。</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span><br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-分析类的结构和绘制背景图"><a href="#13-分析类的结构和绘制背景图" class="headerlink" title="13-分析类的结构和绘制背景图"></a>13-分析类的结构和绘制背景图</h3><h4 id="绘制背景图"><a href="#绘制背景图" class="headerlink" title="绘制背景图"></a><strong>绘制背景图</strong></h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf">private Graphics g<span class="hljs-comment">;</span><br><span class="hljs-attribute">g</span> <span class="hljs-operator">=</span> this.CreateGraphics()<span class="hljs-comment">;</span><br>GameFrameWork.g <span class="hljs-operator">=</span> g<span class="hljs-comment">;</span><br>GameFrameWork.g.Clear(Color.Black)<span class="hljs-comment">; //clear方法是将整个画布涂成某个颜色。</span><br><br>class GameFrameWork<br>&#123;<br>public static Graphics g<span class="hljs-comment">; //在GameFrameWork里面声明一个名称为g的画布。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-编程设计好的类的代码"><a href="#14-编程设计好的类的代码" class="headerlink" title="14-编程设计好的类的代码"></a>14-编程设计好的类的代码</h3><h4 id="父类：GameObject"><a href="#父类：GameObject" class="headerlink" title="父类：GameObject"></a><strong>父类：GameObject</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GameObject</span> <span class="hljs-comment">//声明抽象父类GameObject。</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X &#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y &#123;<span class="hljs-keyword">get</span>;<span class="hljs-keyword">set</span>;&#125; <span class="hljs-comment">//提供设置坐标的方法。</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Image <span class="hljs-title">GetImage</span>()</span>; <br><span class="hljs-comment">//声明获取自身图形的方法，由于获取不到图片，定义为抽象方法。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawSelf</span>() <span class="hljs-comment">//声明绘制自身图形的方法。</span></span><br>&#123;<br>Graphics g = GameFrameWork.g;<br>g.DrawImage(GetImage(), X, Y);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="子类：MoveThing"><a href="#子类：MoveThing" class="headerlink" title="子类：MoveThing"></a><strong>子类：MoveThing</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">enum</span> Direction <span class="hljs-comment">//声明一个表示图形朝向的枚举。</span><br>&#123;<br>Up,<br>Down,<br>Left,<br>Right<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MoveThing</span> : <span class="hljs-title">GameObject</span> <span class="hljs-comment">//声明表示可移动的物体的类，继承父类GameObject。</span><br>&#123;<br><span class="hljs-keyword">public</span> Bitmap BitmapUP &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-keyword">public</span> Bitmap BitmapDown &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-keyword">public</span> Bitmap BitmapLeft &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-keyword">public</span> Bitmap BitmapRight &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; <span class="hljs-comment">//声明表示可移动物体四个方向的图片。</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Speed &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; <span class="hljs-comment">//声明物体的移动速度。</span><br><span class="hljs-keyword">public</span> Direction Dir &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; <span class="hljs-comment">//声明物体的当前朝向。</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Image <span class="hljs-title">GetImage</span>() <span class="hljs-comment">//重写抽象父类获取自身图像的方法。</span></span><br>&#123;<br>Bitmap bitmap = <span class="hljs-literal">null</span>; <span class="hljs-comment">//先设置一个默认值为null的bitmap图形。</span><br><span class="hljs-keyword">switch</span>(Dir)<br>&#123;<br><span class="hljs-keyword">case</span> Direction.Up:<br>bitmap = BitmapUP;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Direction.Down:<br>bitmap = BitmapDown;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Direction.Left:<br>bitmap = BitmapLeft;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Direction.Right:<br>bitmap = BitmapRight;<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-comment">//通过switch语句根据Dir表示的方向来对bitmap进行赋值，让方向和具体图像相对应。</span><br>bitmap.MakeTransparent(Color.Black); <span class="hljs-comment">//对bitmap进行透明化处理。</span><br><span class="hljs-keyword">return</span> bitmap; <span class="hljs-comment">//返回最后得到的bitmap。</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="子类：NotMoveThing"><a href="#子类：NotMoveThing" class="headerlink" title="子类：NotMoveThing"></a><strong>子类：NotMoveThing</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">NotMoveThing</span> : <span class="hljs-title">GameObject</span> <span class="hljs-comment">//表示不可移动的物体，继承自父类。</span><br>&#123;<br><span class="hljs-keyword">public</span> Image Img &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; <span class="hljs-comment">//声明物体的图形。</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">override</span> Image <span class="hljs-title">GetImage</span>() <span class="hljs-comment">//改写父类的抽象方法， 把物体的图像返回出来。</span></span><br>&#123;<br><span class="hljs-keyword">return</span> Img;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="15-绘制地图"><a href="#15-绘制地图" class="headerlink" title="15-绘制地图"></a>15-绘制地图</h3><h4 id="地图绘制"><a href="#地图绘制" class="headerlink" title="地图绘制"></a><strong>地图绘制</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">GameObjectManager</span><br>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;NotMoveThing&gt; Walllist = <span class="hljs-keyword">new</span> List&lt;NotMoveThing&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>()</span><br>&#123;<br><span class="hljs-keyword">foreach</span>(NotMoveThing nm <span class="hljs-keyword">in</span> Walllist)<br>&#123;<br>nm.DrawSelf();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreateMap</span>()</span><br>&#123;<br>CreatWall(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>,Walllist);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CreatWall</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x,<span class="hljs-built_in">int</span> y,<span class="hljs-built_in">int</span> count, List&lt;NotMoveThing&gt; Walllist</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> xpositon = x * <span class="hljs-number">30</span>;<br><span class="hljs-built_in">int</span> ypositon = y * <span class="hljs-number">30</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = ypositon;i&lt;ypositon+count*<span class="hljs-number">30</span>;i+=<span class="hljs-number">15</span>)<br>&#123;<br>NotMoveThing wall1 = <span class="hljs-keyword">new</span> NotMoveThing(xpositon, i, Resources.wall);<br>NotMoveThing wall2= <span class="hljs-keyword">new</span> NotMoveThing(xpositon+<span class="hljs-number">15</span>, i, Resources.wall);<br>Walllist.Add(wall1);<br>Walllist.Add(wall2);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写于2023到来之际</title>
    <link href="/2022/12/29/%E6%9D%82%E8%B0%88/%E5%86%99%E4%BA%8E2023%E5%88%B0%E6%9D%A5%E4%B9%8B%E9%99%85/"/>
    <url>/2022/12/29/%E6%9D%82%E8%B0%88/%E5%86%99%E4%BA%8E2023%E5%88%B0%E6%9D%A5%E4%B9%8B%E9%99%85/</url>
    
    <content type="html"><![CDATA[<p>　　</p><blockquote><p align="justify"> 　　失败和痛苦永远是人生的主旋律，经过两年多社会的拷打，逐渐认清了自己不过是平凡到不能再平凡的普通人的现实，也逐步对真实的自己建立了更加身后的了解。</blockquote><span id="more"></span> <h2 id="“波澜壮阔”的一年"><a href="#“波澜壮阔”的一年" class="headerlink" title="“波澜壮阔”的一年"></a>“波澜壮阔”的一年</h2><p align="justify"> 　　过往每年在年终之际都会在QQ空间里写个几百字的年度总结，今年搭建了这个网站之后，能存的字数几乎没有上限了，可以放开了写。回顾整个2022年，用波澜壮阔这么一个常用成语来形容这一整年还是比较贴切的，尽管波澜壮阔这四个字得打个引号表一表讽刺的意味。读书时期，几乎生活中的一切发展都是安稳并且可知的，离开学园、来到社会后，不稳定的因素就一下子显著增多了起来，步入2022年后，开始频繁地引发着我日常生活的一次又一次动荡。性格方面，我是一个安定的人，我更习惯于按部就班地处理各项事务，但长期过于安定的状态其实也意味着人可以清晰地预知到自己的明天、下个月甚至下一年，因而又不免偶尔会感觉生活中缺少了激情，活得像一具行尸走肉，所以生活波折一点有时又可能不是一件完全的坏事。不管怎么说，2022年对我而言都是很重要的一年，仅以本篇文章做个象征意义的记录与留念吧。<h2 id="三次封控"><a href="#三次封控" class="headerlink" title="三次封控"></a>三次封控</h2><p align="justify"> 　　今年区别于往年的地方首当其冲就是经历了三次封控。自19年疫情开始，一直到今年4月上海全市封城之前，我个人几乎没有体验过任何因为疫情（及疫情防控）带来的不便，也是这一次封城让我做了头一次核酸。全域的封城持续了几乎两个月的时间，好在和家里人一起居住并且存粮也足够，再加上公司两次支援来的物资，得以顺利地度过了这一段特殊时期。6月全市恢复正常秩序的一周后，小区内再次出现病例，这一次，在小区没有被划为任何风险度的风险区的情况下，整个小区被采取了14天封控的措施，又被迫居家呆了两周。这两周封控的记忆反而是比两个月的封城更加深刻——业主们普遍接受不了14天封控的一刀切政策，纷纷来居委会门口讨要说法。街道（或者可能是区县）拉来一个不愿意透露姓名和职称的公务员与业主对峙，但与其说是对峙，不如说是单方面固守居委会这座城池，贴身带着一个警察全程龟缩在居委会内拒绝与居民对话，居委会门口则站着一左一右站着两位大护法（辅警），如同两尊门神堵在门口不让业主进入居委会内部。最让我难以忘怀的还是那位忠犬系居委会书记，千方百计地想忽悠前来讨说法地业主离开，面对居民的质问全程打各种太极，当他的“主人”放弃龟缩带着警察一起逃蹿出小区时，还用自己的身体英雄地阻挡着紧追而来的居民，真的很感人。在大多数地方都开放的情况下又被关两个星期，对很多居民是不太能接受的损失，在请愿书中也有提到由有业主因封控被裁员、因这两个星期失去重要项目的，这也是头一次让我对封控、防疫、基层、法制这些名词产生了新的思考。10月国庆结束后，公司大楼里出现病例，随即遭到封控，居家办公期间，我被判定为次密接赋了红码。这又是一次很魔幻的经历，从与阳性人员同处一栋大楼到被赋红码之间间隔了将近一个星期的时间，按照这个效率，病毒可能早已经传播了十万八千里。从各个同事的反馈来看，被判断为次密集的处置不尽相同，相关工作人员自己也搞不清楚包括红码什么时候消失在内的很多问题，现在看来也足以反应出基层有些疲于应对的状况了。<h2 id="项目解散"><a href="#项目解散" class="headerlink" title="项目解散"></a>项目解散</h2><p align="justify"> 　　另一个与往年区别较大的地方是工作，自去年末主动更换了项目组以后，今年前半年的上班体验直线上升，勉强触到了喜欢的工作+满意的工作+较多的闲暇时间+友好的同事这一理想工作的边，总之是一段非常满足的工作经历，甚至有时候会觉得这么理想这么美好的工作可能以后就再也遇不到了。不过正所谓好日子总是过不长，今年7月份，项目宣告解散，仅仅只用了一个下午的时间，一切就美好都不复存在了。<p align="justify"> 　　关于这半年多的工作经历，比起项目最终解散的结果，我更唏嘘于项目解散的过程。这个项目，我姑且称为R项目好了，两位主创都是非常有理想主义色彩的人。在抄袭为王、换皮为王的大环境下，他们希望游戏要做出自己的特色，为此带着底下的团队加入了很多同类游戏中不多见的设计。他们不喜欢游戏为了赚钱而过度地商业化，因此游戏在设计之初就做成了轻数值重玩法的构架，尽管同类游戏中的佼佼者能赚钱是因为采取了完全相反的逻辑。他们有做好游戏的决心，坚信不断打磨真的可以创作出好游戏，因此游戏在长达约一年的漫长时光里，几乎每个月都保持着极其高速的迭代，游戏从细节到玩法的构架再到经济系统都翻新了多次。他们很擅长听取意见，非常愿意和运营部门的同事进行信息交互，运营部门反馈的问题几乎都能在短期内得到解决，是我前后经历过三个项目中与运营部门关系最好也是联系最密切的项目组。在我看来，R项目之所以没有成功，很大程度上恰恰是因为他们的这份理想主义色彩——因为不想让游戏往重数值的方向发展，所以他们对于商业化相关的内容始终表现出稍显抵触的态度，拒绝让游戏的内购付费变得露骨。他们做的大量改动和尝试根本上来说都是希望在弱数值的话的前提下找到一条能维持生计的道路，遗憾的是几乎每条路最终都宣告了失败。直到游戏的最后一个版本，迫于压力，两位主创最终还是妥协了，在游戏数值加入了比较强付费压迫的数值卡点，然而游戏的框架就是非数值倾向的设计，这一次改动依然收效甚微，于是他们选择自己断腕，主动叫停了R项目。<p align="justify"> 　　我还记得在项目解散前的最后一次立绘，主策留下了一句意味深长的话：“要是我们这个重数值的版本改完了，数值一下子就好起来了，我们策划的心情只会特别复杂，因为这说明我们之前做的种种尝试都没有意义。”他到底是希望数据变好还是不希望数据变好呢？我猜可能是后者吧，比起项目关停，亲眼看见自己制作的游戏变成了自己不喜欢的样子，是一件更加残忍的事情吧。　<h2 id="剧本再现"><a href="#剧本再现" class="headerlink" title="剧本再现"></a>剧本再现</h2><p align="justify"> 　　在R项目解散后，接下来怎么办成为了我需要在一天之内就考虑清楚并给出答案的问题，无非就两条路，卷铺盖走人或者换一个项目组。感性上，我是想跑路的，但我顽固的理性还是死死地将我的脚拴住，选择换组。当时的部门主管拍板把我调到了另一个刚上线两个月的项目，这里称为D项目。来到D项目也有部分是我的个人因素，因为在换组沟通后比较强硬地表示自己不愿意去SLG类地项目，而全公司几乎没有几个非SLG类型的项目了。巧合的是D项目的主管是个老熟人，他是我入职以来第一个项目的运营总负责人，当时我选择离开第一个项目有一部分原因就是不理解他的运营思路和作风，这次再会俨然产生了冤家路窄的喜剧色彩。或许是因为这部分原因在，进入项目之始，我就对我对D项目和这位主管产生了一些疏离感，这种隐隐的距离感让我在接下来将近半年的时间里始终无法融入团队，加上这位主管自己也不是一个非常负责且擅长管理团队的人，在这半年时间里，他几乎没有给我安排过由我独立负责的工作，有相当长的时间我都变成了被抛在一遍、仅在其他同事需要时帮忙打打下手的闲杂人等。过于无聊但上班的环境又没办法专心投入学习，我只能掏出手机刷日本厕纸在工位上消磨一整天的时间，重复一天又一天。<p align="justify"> 　　另一个自己融不进团队的原因是因为D项目在一些表现上和R项目实在太像了，无论是惨烈的数据、还是游戏的买量策略、还是数据不好研发被迫在短期内放手一搏对游戏进行一次超大幅度的改版都与R项目如出一辙，犹如剧本重现。已经完整经历过这一次流程的我觉得自己已经看到了D项目必不可能成功且一定也会被关停的结局，丧失了动力，而现实也确实是按照这个剧本走的——11月底的某日，所谓的游戏大改版完成，各项数据依然稀烂，项目直接被上级叫停，一天之内团队再次分崩离析。项目解散后的第二天，我成为年底系统性裁员中被失业的一份子。再一次经历项目解散，这次非但不觉得可惜，反而是拍手叫好——R项目研发组的能力低下到有些离谱，整个项目的管理更是差劲到匪夷所思，早点关停对所有人都是一种解脱。至于我个人，接受失业的现实，先放一个寒假好好休息再想之后的事情了。<h2 id="“夺冠”"><a href="#“夺冠”" class="headerlink" title="“夺冠”"></a>“夺冠”</h2><p align="justify"> 　　当我以为待业在家至少能过一个太平点的假期时，现实还是给了我狠狠一击。12月起，防疫政策开始逐步转向，最后几乎是在一夜之间就完成了放开，宣布了疫情的结束，同时也是开始。放开后，身边各种有交流的人都纷纷中招，大家都阳了。我本以为自己不太出门或许可以拖延一下阳的时机，结果还是没能逃掉，在年底的最后一个星期感染了这个在全世界范围内肆虐的病毒，我甚至不知道我是在哪个环节感染上了这个病毒。<p align="justify"> 　　有朋友苦中作乐地把这个过程称为“夺冠”，而“夺冠”成了2022年的最后一件大事，实在是颇为讽刺。我的感染症状目前看起来是平均水平，算不上特别严重，头一天轻微咳嗽，在晚上突然加重，体温升高、持续头痛，这个过程持续了大约一天多一点，挺过这段最艰难的时光后，陆续出现肠胃不适、口干、鼻塞、流涕以及咳嗽的症状，不过都不是很严重。在写下这篇年度总结时，抗原还未转阴，但体感上差不多恢复了六七成，至于会不会有后遗症就不清楚了。我更加担心的还是家里人，尤其是家里还有两位上了年纪的老人，家里并没有提前准备血氧仪、制氧器，能做的应对和处置都非常有限，只能祈祷不要出现糟糕的情况。<h2 id="不可预知的未来"><a href="#不可预知的未来" class="headerlink" title="不可预知的未来"></a>不可预知的未来</h2><p align="justify"> 　　写到这里，对2022年的回顾就差不多结束了，没有什么大事，但对向来都是安安稳稳的我而言已经足以称得上“波澜壮阔”了。按照惯例，回顾完一整年，总是得来个新一年展望，而当我顺着这个思路，思考明年甚至是更遥远未来时，我想到的却总是一些不太美好的东西，又不由得强行掐断自己的思考。首先可以预计，在2023年中，疫情依然是一个逃不过去的永恒话题，而提到2023年的疫情，又会衍生出太多不清不楚问题——从长期来看，新冠有多少的概率引发什么表现的后遗症？重复感染的概率有多少？重复感染后症状是加重还是减弱？重复感染会发生多少次？每次间隔会是多久？病毒到底是不是仅仅会以极低的概率引发肺部的症状？病毒会朝什么方向再次变异？在互联网上，每个问题我们都可以找到多种答案，甚至对同一个问题给出不同答案的还都是那些看起来很靠谱的所谓“专家”。在当今的互联网舆论场里，一切可以有多个答案的问题都会被激化为各种各样的矛盾，人和人的分歧似乎愈发撕裂，各种各样的信息鱼龙混杂，各种说法是真是假，是善意还是恶意，早已难以分辨。在放开前，舆论场中的病毒是90%以上无症状的弱鸡，放开后的实际体验告诉我们绝大多数人都有明显的症状，因此上述这么多问题的答案或许只能等到来年看实际情况再逐一揭晓了。<p align="justify"> 　　不知道从什么时候起，对于不可琢磨的未来，我开始抱有一种悲观的态度，这种悲观不仅仅局限于我自己、我所处的这个社会，而是放大到全人类甚至整个星球。在疫情阴云笼罩的当下，这种悲观感或者说绝望感又重了一份。经济萧条，意味着来年找一份相对令人满意的工作大概率不会顺利；病毒肆虐，意味着可能未来可能还要几次“夺冠”。一切都顺利的未来或许也存在，毕竟没有特异功能，未来这种东西，谁也给不出正确的猜测。<h2 id="何去何从？"><a href="#何去何从？" class="headerlink" title="何去何从？"></a>何去何从？</h2><p align="justify"> 　　未来的外部环境不好预测，但自己要做出怎么样的改变，自己想要做哪些事情，不管外部环境如何变化，这些问题的答案都应当是确定不变的。因此最后一小段文字，写下2023年对自己的期许，希望可以再激励下明年的自己。失败和痛苦永远是人生的主旋律，经过两年多社会的拷打，逐渐认清了自己不过是平凡到不能再平凡的普通人的现实，也逐步对真实的自己建立了更加身后的了解。既然如此，现在也刚好是时候给自己明确下前进的方向了：对于事业和生活，我不能要求自己一定去取得怎样的成绩、赚多少钱、实现什么宏大的梦想，但我至少要让生活变得有盼头，做更多兴趣使然的事情，哪怕没头没尾，不管是写没人看的文章还是做没人玩的游戏，这些都至少让我的生活有了更加丰富的色彩。游戏依然是最大的兴趣爱好，在保持的同时，多抽些时间看看有趣的动画和小说作品，这就完全足够了。对于自己，怕生敏感的性格与生俱来，事到如今，没有必要也不太可能再改变，但我还是希望自己可以活得更有尊严一些，不能因为自己太好说话、不愿意与他人起冲突就经常性地退让，然后就是自己要在来年里刻意地收敛自己不良的表现欲望，有时上头之后太得瑟了，这并不是什么好事。一言以蔽之，做切合实际的、更符合自己期待的自己吧，希望明年可以顺利一些。]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《魔女旅团》系列的野心与困境</title>
    <link href="/2022/12/20/%E6%9D%82%E8%B0%88/%E9%AD%94%E5%A5%B3%E6%97%85%E5%9B%A2%E7%9A%84%E9%87%8E%E5%BF%83%E4%B8%8E%E5%9B%B0%E5%A2%83/"/>
    <url>/2022/12/20/%E6%9D%82%E8%B0%88/%E9%AD%94%E5%A5%B3%E6%97%85%E5%9B%A2%E7%9A%84%E9%87%8E%E5%BF%83%E4%B8%8E%E5%9B%B0%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>　</p><blockquote><p align="justify"> 　　顶级的剧本和叙事却没有相应的制作资源支持，作品销量不佳，中文版本胎死腹中，制作者默默无闻，游戏发售后的这两年时光里，也没有任何关于这个系列新作的情报披露，制作人泉达也本人的动向也是完全不明。</blockquote><span id="more"></span> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p align="justify">　　2022年的11月和12月对我来说大概是格外特殊的两个月，11月遭遇年底裁员赋闲在家，12月防疫政策调整后，短短一个多星期的时间，病毒就杀穿了各地，为了避免自己和家人早早在高峰期中招，不得不窝在家里再次陷入了出不了门的境遇，于是陪伴着度过闲暇时光的又只能是游戏了。这段特殊的日子里，陪伴我的游戏是《加雷利亚的地下迷宫与魔女的旅团》，这款游戏的实体限定版记忆中是几个月前买的，游戏是没有中文的日版，于是开封后就一直放在抽屉里吃灰。等待官方中文的时间实在太长，尽管近期传出了游戏将出欧美版本并且在Steam和PS5平台发行的消息，但依然看不到任何官方中文的影子，而从本作开发商兼日本游戏行业的一股泥石流日本一公司近期的情况看，本作大概率是不会出官方中文了。刚好11月的某日我在B站刷到了这款游戏全部剧情的民间视频字幕翻译，整整156P，翻译工作量拉满，最终还是忍不住开了这个天坑，应该是自打我接触主机以来第一次硬啃非中文语言的游戏。开坑之前大致上会对游戏有一些初步的了解，就我掌握的信息来看，游戏在中后期会有大量重复辛劳的刷刷刷，非常符合日本一这家公司出品的RPG的一贯尿性，通关流程大约会在120小时左右，考虑到语言不通，通关这款游戏估计要花掉相当大量的闲暇时间。12月下旬打完游戏后看了时长统计，通关历时一个月出头，约110小时，刷刷刷的量确实很惊人，最后冲刺的几天刷练度犹如坐牢，恨不得日本一赶紧本社爆破。虽然是这么说，但不得不承认游戏第一部分（大约前20-30个小时）的迷宫探索部分相当让我觉得过瘾，这种久违的感觉仿佛将我带回了19年初的寒假——那年的2月份，我还在读大学，入手PS4不到一年，入手机器之初，我在贴吧里一个RPG游戏的推荐贴子中看到了一款名为《鲁弗兰的地下迷宫与魔女的旅团》的游戏，名字很长，给我留下了深刻的印象。在PSNINE搜索该游戏后，几乎是清一色的好评，刚好那年2月，索尼开启了新年特惠，这款游戏进入了打折的列表，趁着这个机会购入后，我爆肝9天时间废寝忘食地通关了这款游戏，自此这款游戏就成为了我心目中JRPG的巅峰作品。和四年前不同的是，虽然作为续作的《加雷利亚的地下迷宫与魔女的旅团》在前期依然保障了极佳的游戏体验，但在游戏第一个BE结束，播放STAFF名单，进入第二部分后，伴随着随即生成迷宫的登场，GamePlay部分的游玩体验就开始急转直下。当我艰难地硬啃生肉通关游戏，看完最终的TrueEnd后，我看到了疫情背景下，一个开发规模有限、开发成本有限、知名度更加有限的贫穷团队的庞大野心，以及他们面临的困境。<h2 id="结缘：《鲁弗兰的地下迷宫与魔女的旅团》的成功"><a href="#结缘：《鲁弗兰的地下迷宫与魔女的旅团》的成功" class="headerlink" title="结缘：《鲁弗兰的地下迷宫与魔女的旅团》的成功"></a>结缘：《鲁弗兰的地下迷宫与魔女的旅团》的成功</h2><p align="justify">　　只要说到《加雷利亚的地下迷宫与魔女的旅团》，不可能不提到前作《鲁弗兰的地下迷宫与魔女旅团》。两部作品都是DRPG的玩法，对于多数玩家，DRPG这个名词可能会有些陌生。简单来说，DRPG是以地牢或者迷宫探索为核心玩法的RPG游戏。就定义而言，《女神异闻录5》也可以称得上是DRPG，毕竟《女神异闻录5》的核心玩法就是踏入一个个经过精心设计且高度复杂的迷宫，玩家需要在迷宫中分配好有限的资源、完成精心设计过的谜题，并合理地规划好每次在迷宫的探索进度。当然《女神异闻录5》能大获成功是基于在把迷宫探索做的足够优秀的前提下，在迷宫之外还设计大量丰富多彩、无比充实的日常要素，游戏的角色设计、剧情、美术及音乐也都是相当高的水准，和DRPG这个类型本身倒是没什么联系。事实也确实是这样，《女神异闻录5》大热的背景下，绝大多数其他的DRPG作品依然没能进入大众玩家的视野，这是因为大多数的DRPG依然保留着比较古早的状态。作为一个历史久远的游戏类型，DRPG在那个年代的出现更多是受到游戏制作技术的制约，而随着时间的推移和技术的革新，传统的走格子迷宫对RPG游戏已经不再重要，大多数游戏都开始将游戏的地图探索部分转型为更加开放的3D世界。因此，从现在的眼光来看，保留着古早风貌的DRPG游戏就显得有些不合时宜了——剧情薄弱、难度很高、节奏缓慢、玩法也很单一，大多是第一人称视角下的格子移动+打怪，因此也注定成不了主流。<p align="justify">　　之所以将开发商日本一这家公司称为日本游戏行业的一股泥石流，是因为这家公司特别喜欢以奇高的频率出各种非主流玩法的奇怪作品，并且丝毫不执著于IP概念，大量推出的作品都是没有任何根基的原创，且游戏中往往会包含一些普通玩家不太好接受的Cult类元素。能有思路清奇的这么一家公司并不是坏事，但不得不承认日本一推出的绝大多数作品都价格奇高并且不太具备游玩的价值，说得直球一点就是日本一的游戏普遍比较垃圾…但在茫茫多奇怪的非主流作品中，还是偶尔会出现一些小众而优秀的作品出现，而《魔女与百骑兵》和《鲁弗兰的地下迷宫与魔女旅团》就是其中最有代表性的两个例子。<p align="justify">　　依稀记得初次接触《鲁弗兰的地下迷宫与魔女旅团》时的绝妙游玩体验，虽说玩法是最为古典的明雷遇敌+回合制+自己创建培养角色的DRPG，但游戏独特的支援力系统及破墙的设计为这个古典的游戏类型注入了一些新鲜的体验。支援力系统作为迷宫探索中需要规划用途的点数，可以实现回城、传送、隐身等辅助迷宫探索的支援效果，而其中最为有趣的支援效果就是破墙——玩家可以消耗较少的支援力，打破迷宫的墙壁，快速穿梭于庞大的迷宫，同时挖掘出地图之中的隐藏路线和稀有宝箱。游戏的迷宫设计足够出色，随着章节剧情的推进，玩家会逐步进入一个个不同故事背景的迷宫国度，如带有童话色彩的小人国、神秘庄严派系分明的三塔、破败的王国遗迹…迷宫的环境、机制和敌人会随着主题不断变化，路线的设计相当巧妙，以至于探索庞大的迷宫完全不会角色枯燥，反而成了一种享受。战斗系统方面，鲁弗兰的节奏也比较顺滑，只要耐心地探索玩迷宫的各个角落，不刻意回避大量的战斗，正常流程下来玩家的练度基本上是足够完成游戏的主线内容的，即使是对练度要求更高的EX迷宫环节，制作组也非常贴心的设计了一个稳妥的官方逃课方案，不需要玩家花大量时间去刻意地练级。<p align="justify">　　在迷宫探索和战斗部分已经足够优秀的基础上，《鲁弗兰的地下迷宫与魔女旅团》的剧情在当时的我的心目中达到了几近巅峰的位置，即使放在今天，我认为能在剧情上能完全超越本作的日厂游戏依然寥寥无几，也就叙事上前无古人后无来者的《十三机兵防卫圈》能够稳压一头。游戏的剧情分为主角造访地下不同地下国度和地上鲁弗兰市内魔女朵洛尼亚和弟子露卡的日常生活（真的日常吗？）两个部分，两部分互相穿插，在游戏的前中期基本保持独立。地下国度的剧情使用碎片化叙事，这部分情节的直接对话寥寥无几，取而代之的是迷宫中墙壁上的留言以及捡到的字条，辅助玩家推测出地下世界中发生的种种崩坏的始末。地上鲁弗兰市的剧情则以长段的直白剧情对话展开，这部分故事的舞台几乎全程被局限在鲁弗兰市内，有立绘的角色大概两只手都能数的过来，由此留出了大量的空间去塑造好每一个登场的角色。游戏主角之一的薄暮魔女朵洛尼亚是反王道、反英雄式的恶人形象，作为一个冷酷无情、阴险狡诈的魔女，以她为核心发生的故事没有早就看腻了的勇者们凭借着相互的羁绊打倒魔王如此这般套路的桥段，在与可爱的弟子露卡发生碰撞后，演绎出了一段在满满的猎奇与黑深残中夹杂着无比动人的温情与希望的精彩故事。<p align="justify">　　单从制作来看，游戏在剧情方面的制作表现力堪称惨不忍睹，流程总长度高达约100小时的游戏里，能算是个过场CG的可能就只有三张，动态类的剧情演出也只有结局设置了一处，其余全都是对话界面中立绘的平移+简单的特效，但制作组使用了水准极高的叙事手法来弥补了短板。在游戏的前中期，故事就通过一次次的超展开铺垫了大量的伏笔、隐喻和悬念，这些伏笔和隐喻在中后期又得到连续的揭晓，最终实现了让人拍案叫绝的连环反转，使得整个游戏的剧情从头到尾都没有让人感到乏味和无聊的地方，全程保持着高度的张力，表结局最后同时也是全程唯一的一段动态剧情的演出（也就是大家常说的爬楼梯）在感染力方面几近超神。在玩家可以直接通过阅读对话了解到的主线剧情之外，游戏还铺设了另一条暗线，从另一个独特的角度讲述了一段游离于主线故事之外但又与主线密切相关的旅途，需要玩家整理在迷宫中看到的字条和墙壁留言后，再结合游戏里成就中的描述说明后才能了解个大概。关于游戏的成就，本作是做成了玩家每踏入一层迷宫就能自动解锁一个成就的模式，解锁全部成就获得白金奖杯便意味着踏破了所有的迷宫实现了游戏的通关，因此对于成就的说明不再是玩家需要达成怎么样的条件，取而代之的是一段段长度不等乍一看有些意义不明的日记片段，通关后回过头来研究才能知道这些文字里面别有一番深意，使用成就进行暗线叙事，实在是一种非常具有创意的叙事手法。<p align="justify">　　基于《鲁弗兰的地下迷宫与魔女旅团》在JRPG（包括DRPG）品类游戏中展露出的极高素质，本作不管是在日本还是国内都有相当高的评价，Bangumi评分达到8.1（196人评分），游戏时光评分8.9（581人评价），评价人数看起来很少，但在DRPG这个品类里已经算是相当之高了：同样是DRPG并且勉强在国内有一定知名度的《神狱塔 断罪玛丽2》在Bangumi只有31人评价，而在游戏时光只有114人评价，至于同品类里还算可以的《恶魔凝视》系列，在国内几乎直接就是查无此游的状态。局限于有限的制作规模、单调的玩法和冷门的品类，传统DRPG注定是极其小众的游戏，《鲁弗兰的地下迷宫与魔女旅团》如此表现，已经相当不易了。<h2 id="坎坷：《加雷利亚的地下迷宫与魔女的旅团》的困境"><a href="#坎坷：《加雷利亚的地下迷宫与魔女的旅团》的困境" class="headerlink" title="坎坷：《加雷利亚的地下迷宫与魔女的旅团》的困境"></a>坎坷：《加雷利亚的地下迷宫与魔女的旅团》的困境</h2><p align="justify">　　2019年3月，日本一正式公布了《鲁弗兰的地下迷宫与魔女旅团》的续作《加雷利亚的地下迷宫与魔女的旅团》，预计于同年7月25日正式发售，和前作完全一样，本作依然是以泉达也（制作人兼编剧）、原田雄一（角色设计）和佐藤天平（音乐）为核心的开发团队。同年5月，游戏确认延期至2020年春季发售。同年11月，游戏再次确认延期，从2020年春延期至未定，原因是进一步提升游戏品质。结合同期日本一陷入财务危机的传闻，游戏连续跳票至发售日待定难免让人怀疑游戏是否能面世。7月，日本一终于确定了游戏将于11月26日发售，自第一次公布的发售日期，延期了将近一年半的时间。2021年9月，在游戏发售将近一年后，日本一宣布游戏将移植至NS平台。2022年7月，日本一宣布本作将推出英文版并在PS5和Steam平台发售，10月，确定了英文版预定在2023年2月发售。游戏曾在2020年有过官方确认本作将会推出中文语言版本的消息，然而自2020年11月以来已经过去两年的时间，官中依然杳无音讯，大抵是胎死腹中了。<p align="justify">　　当一款游戏几经跳票到发售日未定的时候，其实就说明制作过程中遇到了比较大的问题，因此当作品正式发售后，往往就会出现问题，《赛博朋克2077》的多次跳票后的灾难性表现尤为典型，遗憾的是《加雷利亚的地下迷宫与魔女的旅团》没能逃过一劫。打开游戏后一直玩到第一次跳出STAFF名单也就是游戏的第一部分后，我觉得这款游戏不仅继承了前作的优点并且还大胆的加入了各种新探索辅助能力，包括水下地图、瘴气空间等，进一步强化了迷宫探索环节的趣味性。进入游戏的第二部分后，游戏体验就开始出现了极为明显的落差，与之密切相关的是一个匪夷所思的设计——随机迷宫。<p align="justify">　　并不是没有主打随机迷宫的游戏，RPG的大类中，有一个更为小众的RRPG品类，随机生成的迷宫中会出现各种随机性事件、玩家需要因地制宜调整游玩策略是这类游戏的特色。随机迷宫其实不是坏事，DRPG与Rouglike元素也并非完全不能结合，可《加雷利亚的地下迷宫与魔女的旅团》却把二者的结合做成了1+1<2的负面效果。自第二部分开始，游戏几乎放弃了迷宫的精细化设计，取而代之的是两个连续的，总层数超过100层的随机迷宫，每个迷宫从头到尾都是完全一致的一套布景，完全丢失了前作中各个地下国度的环境氛围特色。随机迷宫的随机仅限于地形的随机生成和地图上随机出现的蓝色感叹号事件，踩上去就是干巴巴的一个二选一选对了给几个并不稀有的物品，完全没有专门走过去踩一下的价值，自此本应是充满趣味的迷宫探索于是变成了无穷无尽的走格子作业。<p align="justify">　　平心而论，只是少两个精心设计的迷宫并不是相当难以接受的事情，但在第二部分的游戏过程中，我明显感觉到游戏的流程设置得相当突兀，像是缺少了什么。在两个迷宫之间，玩家需要重新回到第一部分探索的迷宫中重拿奇品，游戏的流程被处理为走到迷宫中的某个点后直接被传送到一个独立的小空间，这些独立空间里有其他迷宫中不曾出现的独立BGM，但除了奇品以外没有任何东西，玩家直接开箱拿走之后回城就会触发长段剧情，如此连续循环多次，节奏非常怪异。每次在迷宫中开箱时，会出现流程中从未见过的新角色（有着独立的Live2D立绘）并说出意义不明的台词，并跳出一个名称和奇品完全不符的成就（在第一部分里，所有的成就和奇品名称都是对应的）。玩到这里，基本上是可以推测这部分内容是因为种种原因没能完成制作的废案，本作最初的规划应当是和前作一样区分多个世界，每个世界设置一部分碎片剧情的，但没办法实现，最终只能堆叠一些已经做好的素材粗暴地放在连迷宫都算不上的区域里。缩水的还不仅仅是迷宫设计，本作的BOSS战也一样缩了水，游戏从头到尾几乎没有几个有独立立绘的BOSS，普遍是把小怪拿来加点数值直接当BOSS的强制战斗，前作里那些令人印象深刻的BOSS战（如三塔的爱丽丝和魔王）在本作中是完全见不到了。<p align="justify">　　第二部分通关后，游戏进入类似于前作后日谈的第三部分。最初玩家需要挑战一个完成度还算不错的四层固定迷宫，前三层迷宫里，每层都会有一场强制战斗拦住玩家的去路。这三场BOSS战难度偏高，刷了好一会儿练度才通关，这只是灾难的开始。通过该迷宫后，玩家会进入一个名为创世迷宫的超级随机迷宫，一共有3651层。<p align="justify">　　很难想象制作组是在什么样的精神状态下掏出了这么一个无穷无尽的3651大迷宫，在这个迷宫中，每隔365层会有一个固有的记录点，偶尔会随机出现存档点供玩家保存进度。3651层迷宫里几乎全部敌人都在之前流程中出现过，仅仅是调整了数值，仅有的新机制坍塌和楼层DEBUFF依然不具备什么趣味性，无穷无尽的爬楼将玩游戏变成了一场苦修。对此攻略给到的方法是全程使用作用为特定步数内不会刷新敌人的道具，保证爬楼过程总全程不遇敌以避免翻车。据初版玩家的说法，创世迷宫算上刷道具的时间大概约20个小时，没有任何正反馈，唯一的想法就是想把日本一本社爆破了。<p align="justify">　　大概制作组也知道创世迷宫的反响很差，于是在后续的版本更新做出了调整，添加了可以观测到本层是否有存档点和跳关电梯的能力。前者可以让玩家避免辛辛苦苦爬击几百层遇不到存档点的窘境，后者则大幅加快了迷宫的攻略速度（进入电梯可以直接跳过若干层数，最多可以直接跳300层）。从我个人的体验来看，本该是20小时的攻略流程，我只用了3个多小时就完成了，先前流程中产出的道具也完全足够爬完创世迷宫，不需要再额外去刷。虽然创世迷宫的爬楼时间大幅缩短，但刷刷刷最终还是没能逃掉，3651层的最终BOSS依然需要合理地构筑一组技能搭配合理且练度在10转左右的人偶队伍才能顺利通过，为此需要在低概率下刷满5本经验结魂书和5本最强的战斗结魂书（以及这些书的星级降低支援力的消耗），然后再给人偶队伍反复地刷级到10转的等级练度，期间还要注意人偶的转生顺序和技能搭配，突出一个艰辛。如此狂气的作业量，即使是已经对刷刷刷有较强耐性的我都感觉到有些难顶。<p align="justify">　　根据从各个游戏论坛中看到的说法，解包发现本作那段突兀的独立空间获取奇品的流程确实是计划做成七个不同的迷宫，并且第三部分原本是还有一个固定迷宫最后被删减了。不太好说是否属实，但从游戏的实际表现来看，确实有一定的可信度。综合来说，《加雷利亚的地下迷宫与魔女的旅团》有着比前作更丰富多彩的职业选择和更灵活的技能搭配，设计了更多迷宫探索的机制，硬件上完全不输前作。然而因为开发过程中不为人知的困难并经历长时间的延期后，制作组没能给扎实的硬件配备上与之相匹配的软件——自第二部分起，僵硬的随机迷宫和稀少的BOSS让新增的内容完全没有用武之地，游戏的第一部分与之后的流程几乎脱节，对比前作，这是一种显而易见的倒退。<p align="justify">　　游戏性的倒退和内容的删减还不足以完全反应本作的困境，作为《鲁弗兰的地下迷宫与魔女旅团》面世四年后的续作，《加雷利亚的地下迷宫与魔女的旅团》在剧情的表现力上与前作依然保持了相当惊人的一致：游戏全程依然是只有三张CG和一段动画演出，其余依然全都是对话界面中立绘的平移+简单的特效。在今天，还在使用如此原始的演出模式的手游都很少见了。小众的游戏品类、贫穷的游戏制作、延期了一年之多的发售日期、倒退的游戏玩法…种种的负面因素加持下，游戏PS4版首周销量没有破万，NS版首周销量不到3000，中文化基本宣告难产，因此在国内也不再有前作的热度，Bangumi只有39人评分，几乎找不到中文版本的攻略和剧情解析。好在喜欢本作的玩家厨力爆表，有大佬翻译了整整126P全部主线游戏流程的剧情，让我能读完本作庞大且富有野心的故事，另外有几篇游戏心得专栏也给我提供了相当大的帮助，没有他们的指引，真的很难通过创世迷宫的历练。　<h2 id="展望：《魔女旅团》系列的野心与未来"><a href="#展望：《魔女旅团》系列的野心与未来" class="headerlink" title="展望：《魔女旅团》系列的野心与未来"></a>展望：《魔女旅团》系列的野心与未来</h2><p align="justify">　　写了这么多都没有提及《加雷利亚的地下迷宫与魔女的旅团》的剧情，不是因为没什么可说的，正相反，大有可言。负责剧本的泉达也在《魔女与百骑兵》和《鲁弗兰的地下迷宫与魔女旅团》中构建了一套以魔女为核心的世界体系，为魔女系列奠定了荒诞、扭曲但又透露着温情和善意的基调，这套世界观在《加雷利亚的地下迷宫与魔女的旅团》中得到了继承和进一步的发扬光大。本作剧情一如既往地夹杂着在令人感到不适和勉强可以接受之间反复横跳的黑深残猎奇桥段以及泉达也个人特色的黄段子和性骚扰，但主旨依然是真挚动人的温情与希望，正如游戏最开始的旁白描述——异想天开、不可思议、被坎坷命运引导着的人们所展开的爱与勇气的冒险物语。与前作相比，《加雷利亚的地下迷宫与魔女的旅团》的故事不再局限于同一个世界，有立绘的登场角色大幅增加，故事变得更加宏大。当作品的世界观和故事规模扩大后，对编剧的笔力自然也会有更高的要求，这一次泉达也还是没有让系列粉丝失望。本作的剧情体验有点像先前提及的《十三机兵防卫圈》：两款游戏都是前期在日常中夹杂着不知所云的迷之超展开，都是中后期通过时间的闪回逐层揭晓前期超展开背后的悬念，回收埋藏在日常段落中的大量伏笔，最后也都留下了既视感相近并且有些意味深长的结局。宏大的故事规模之下，泉达也借游戏中某名重要角色之口，大幅扩充了魔女系列的基础世界观，牵扯到上位二十六环世界、世界树一族等等极其宏伟的概念。不像前作把主线故事收的干净利落，本作还留下了一些悬念，其中最令人好奇的就是本作中某位角色与前作中某位角色的关系以及发生于二者之间的某个事件，虽然二者的关系通过一些隐晦的线索基本上挑明了，但因为涉及到同系列的另两部作品，泉达也还是做了留白处理。根据游戏设定集的说明，泉达也心目中的魔女世界似乎远远比玩家在游戏里看到的更加系统也更加庞杂，受限于剧本的故事性和篇幅，没有办法把全部细节和设定输入游戏的剧本内，在他构建的这套世界观下，二十六环世界和世界树一族的故事还有大量的空白，足以见得魔女系列的叙事野心之大。<p align="justify">　　然而《加雷利亚的地下迷宫与魔女的旅团》在制作过程上遭遇的重重障碍和最终成品在玩法上的遗憾总是让我不禁担忧起魔女系列的未来，虽然《加雷利亚的地下迷宫与魔女的旅团》的剧本综合来看并不逊色于前作，但不得不承认剧情的表现还是存在着不少的瑕疵。除了先前提到的剧情演出表现贫瘠、制作组贫穷到CG不能多放几张以外，本作宏大的剧情在很多涉及到角色之间情感的展开上并没有做到足够的铺垫，弱化了对玩家情绪的调动。角色确实变得多了很多，但因此也缺少了细致的塑造，尤其是本作魔女组织月之协会中这么多有独立立绘的魔女，与她们直接相关的剧情却相当之少。在写这篇文章时，翻到机核某篇评测文章底下某位用户的评论：<blockquote><p align="justify">　　而在中后期游戏设计大幅缩水的情况，这个野心如此之大的剧本还能几乎没有妥协地全部做完少有删减感，真的是非常不容易。而且我和你对剧情的感受是相似的，所以我完全理解你说的因为想到亲人而哭得稀里哗啦是怎么回事。这个剧情完全对得起那个“爱与勇气的冒险谭”的副标题，甚至我不夸张地觉得这剧情要是拍成番或者做成纯AVG会在接下来被无数人吹捧成二次元十年最佳剧情候选，只可惜出身不好，摊上了一个穷公司和没什么人会碰的小众门类。<p></blockquote><p align="justify">　　吹到二次元十年最佳剧情候选的高度未免有些太过，出身不好摊上穷公司和没什么人会碰的小众门类倒确实是正中靶心。经过《魔女旅团》系列两作加起来200小时的游玩历程，本作的编剧兼制作人泉达也在我心目中已经上升到了游戏编剧天花板的地位，至少称得上是一名才华横溢的剧本家，但不管是国内网站还是外网，都几乎搜不到有关他的任何信息。顶级的剧本和叙事却没有相应的制作资源支持，作品销量不佳，中文版本胎死腹中，制作者默默无闻，游戏发售后的这两年时光里，也没有任何关于这个系列新作的情报披露，制作人泉达也本人的动向也是完全不明。魔女系列是否还能有下文，是否还能看到这个庞杂世界观下新的绝望中散发着希望的动人故事，一切都成了未知数。作为一名玩家，对此完全是无能为力，只能弱弱地希望今后泉达也还能给粉丝们带来优秀的作品，能提供的支持也只有出了之后购入一份限定版了。提到限定版，我还记得当年在通关数字版的《鲁弗兰的地下迷宫与魔女旅团》后一直想购入一份实体版收藏，但由于游戏出货量少且非常冷门，国内各平台几乎都找不到实体碟的售卖，只能作罢。之后某一天在偶尔才会一去的游戏实体店里的某个角落里发现了本作的实体限定版，如此冷门的游戏居然能在普遍是只有大众游戏的实体店里找到，当时我觉得一定是缘分，直接买了下来带走回家，我想这也是我对这个游戏系列抱有如此之深的感情的缘故吧。<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p align="justify">　　这篇杂谈写到这里，已经是超过8000字的篇幅了。想写的东西确实挺多，在没有大纲的情况下断断续续写了一天多的时间，想到什么写什么，没什么中心主题，不知不觉中就到了这么大的篇幅。和先前两篇作品相关的杂谈不一样，这次重点是介绍这个游戏游戏的发展和我所期盼的未来，于是写的时候最后是选择刻意回避掉了剧情的具体内容，毕竟这么精彩的剧情要是把核心设计剧透给他人，真的会觉得太过可惜。<p align="justify">　　至于《加雷利亚的地下迷宫与魔女的旅团》，本作让我感触最深的不是真结局中最后几乎一个小时时长的动态剧情演出，也不是剧本所着重刻画的家人之间的亲情，而是在出现在游戏开篇、结尾等多处被反复提及的某个经典寓言故事，中文语境下，这个故事还延伸出了杀鸡取卵这个四字成语。引用游戏里开篇的一段自白和结尾的一段发问，留下一条对自己的疑问，作为本篇杂谈的收尾吧：<blockquote><p align="justify">　　无知且愚蠢的欲望会招来毁灭，是这样的一个预言——但是我无法理解。这个女人很滑稽吗？不顾一切危险的挑战是愚蠢的吗？追求更多的幸福是一种罪过吗？比起这些，我…能够忍住不去撕开鸡的肚子吗？撕开的话，会被当成愚蠢之人遭受非难吗？<p></blockquote><blockquote><p align="justify">　　你有将鸡的肚子撕开的觉悟吗？金蛋这种东西可能根本不存在——无法认识的眼前的幸福，而试图追求更多的幸福，这便是人类深重的罪孽了…即使如此，也要做吗？<p></blockquote><p align="justify">　　我们能忍住不去撕开鸡的肚子吗？我们应该忍住不去撕开鸡的肚子吗？当下金蛋的鸡出现在我的面前时，我想，我大概也是会忍不住撕开鸡肚的、贪得无厌的那类人吧。]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主机游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>年度游戏总结（2022）</title>
    <link href="/2022/12/19/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2022/12/19/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p align="justify">　　以前很喜欢每打完游戏就在空间里晒下白金截图和游玩感想，随着年纪慢慢变大，莫名就不太想在QQ发动态了，又没有别的地方发这种游戏总结式的小文章，游玩感想这个例行环节也就停了。如今有了个人博客，想想还是把这个环节捡起来。精力有限，每打完一个游戏就发一篇长文不太现实，所以考虑以一年或者半年为单位做一个系统性的总结，包括基于个人主观感受下的游戏评分和简单的点评加感想。<p align="justify">　　今年疫情频繁反复，上半年有相当一部分时间在家里度过，比较闲，所以上半年打了挺多游戏，还填掉了很多陈年老坑的白金，比如《怪物猎人世界 冰原》。下半年分了一些精力在很多别的地方（其实主要是看厕纸），打游戏的时间少了挺多的，所以打的游戏数量比起上半年要稍少一些。接下来按照时间先后顺序来总结总结今年玩下来的这些游戏，每款游戏会给一个游戏品质的评级和一段小小的点评。点评范围仅限于今年新玩的、或是之前有玩过一小会儿但还有很多内容没打的游戏。之前已经基本打完、今年仅仅是补一些奖杯的游戏（例如《死亡搁浅 导演剪辑版》、《偶像大师 星耀季节》等）不在点评范围内。<h2 id="S级-倾情推荐"><a href="#S级-倾情推荐" class="headerlink" title="S级 [倾情推荐]"></a>S级 [倾情推荐]</h2><h3 id="艾尔登法环（ELDEN-RING™）"><a href="#艾尔登法环（ELDEN-RING™）" class="headerlink" title="艾尔登法环（ELDEN RING™）"></a><strong><font color=Red>艾尔登法环（ELDEN RING™）</font></strong></h3><p align="justify">点评：基本提前钦定为鬼GN2022年度游戏了，经典魂系战斗玩法和开放世界的结合是非常大胆的尝试，也确实做出了自己的特色和效果。法环的世界广阔，大地图的场景宏大，奇幻感十足，地图中各种元素的填充也比较饱满，传统封闭箱庭地图的设计依然在线，探索趣味十足，是今年最让我感到自己沉迷进去了的游戏作品，值得一个GOTY。游戏发售后有一段时间，外部对本作的争议比较大，确实个人玩下来也发现游戏内有很多缺点，尤其是战斗交互方面，法环的战斗体验要明显弱于FS社的前几部游戏作品，体现在敌人和玩家的性能差异略为悬殊，招式中出现了大量反直觉的快慢刀和伤害判定，很多敌人的AI设计偷懒，使用了很粗糙的读指令。玩家的战技招式对比普攻又太过强大，导致很多情况下战斗变成了强力战技的无限复读，少了很多以往和BOSS互动拆招的刺激感。另外游戏后期过了雪山后地图有比较明显的赶工痕迹，从圣树开始数值也有些爆炸。总之《艾尔登法环》离完美确实还有距离，但不能否认，即使存在各种缺陷和遗憾，依然是今年新发售作品中最好玩、最值得一玩、综合游戏体验最好的游戏之一，那么问题来了，DLC到底要到什么时候才公布？<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E8%80%81%E5%A4%B4%E7%8E%AF.jpg"></p><h2 id="A级-比较推荐"><a href="#A级-比较推荐" class="headerlink" title="A级 [比较推荐]"></a>A级 [比较推荐]</h2><h3 id="莉迪＆苏瑞的炼金工房-～不可思议绘画的炼金术士～"><a href="#莉迪＆苏瑞的炼金工房-～不可思议绘画的炼金术士～" class="headerlink" title="莉迪＆苏瑞的炼金工房 ～不可思议绘画的炼金术士～"></a>莉迪＆苏瑞的炼金工房 ～不可思议绘画的炼金术士～</h3><p align="justify">点评：不可思议系列的最后一作，游戏很早以前就买了，然后就搁置了有半年才正式开坑。因为是同一个系列，本作和系列第一作苏菲的炼金工房整体风貌相近（毕竟是同一个画师负责人设），系列前两作出现的人物如前作主角苏菲、菲莉斯等也都会在本作中出现，看到认识的角色在新作中出现感到挺亲切的。玩法方面，本作炼金的核心从苏菲的拼锅变成了捣鼓触媒，初上手还是感觉有一点复杂，不过熟悉以后感觉也不是非常繁琐，勉强还算有趣。不可思议系列的剧情一直是比较欢快的基调，本作剧情依然发挥平稳，虽没有令人印象深刻的情节，但全程保持四平八稳，能写一个完整故事的JRPG，放在现在已经算有点难得了，而且玩到后期还有点小感动的。唯一有些不满的就是强力稀有特性正常玩到通关基本上都拿不到几个，想要大量强力特性几乎是要逼着玩家去买DLC，有些气人。奖杯有难度杯要打隐藏BOSS，我参考攻略准备了特别多的特性和装备，期间还走了很多弯路，比如一开始都没搞明白装备的品质和强度无关，花了一整天下午的时间循环炼金提品质，最后只能回档，最后发现只是拿个奖杯根本不需要准备这么多，完全是被攻略给唬住了。总结就是本作的剧情、玩法和情怀要素都对得起不可思议系列最后一作的名号（后边的苏菲2可以算新系列了），是一部相当合格的系列收尾作品。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E8%8E%89%E8%BF%AA.jpg"></p><h3 id="宇宙机器人无线控制器使用指南"><a href="#宇宙机器人无线控制器使用指南" class="headerlink" title="宇宙机器人无线控制器使用指南"></a>宇宙机器人无线控制器使用指南</h3><p align="justify">点评：PS5自带展示手柄新功能（主要是震动效果反馈）的免费首发演示游戏，恰到好处地在有限的时长里演示了PS5新手柄支持的各种功能，同时兼顾了3D平台跳跃玩法的趣味性，挺好玩的。给出比较高的评价不仅仅是因为游戏有趣，更是因为这款免费游戏中加入了大量索尼这个品牌的彩蛋，历代的各种游戏设备作为收集品陈列在游戏自带的展览馆里，虽然我远远还称不上老玩家，但一路从PSP到PSV，再从PS4到PS5这么玩过来，看到这么多过去的游戏设备还是被狠狠感动了一把，真的是对索尼品牌的最强致敬了，索狗落泪。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%9C%BA%E5%99%A8%E4%BA%BA.jpg"></p><h3 id="逃出生天（A-Way-Out）"><a href="#逃出生天（A-Way-Out）" class="headerlink" title="逃出生天（A Way Out）"></a>逃出生天（A Way Out）</h3><p align="justify">点评：数字版打折以后和好基友一起入的游戏，同样作为分屏双人合作游戏，本作在玩法丰富度和游戏体验上肯定是不如之后的《双人成行》来得那么好，但依然保持了相当高的制作水准。游戏最大的亮点在于镜头切换和最后关头剧情的反转，医院关卡中两名角色的运镜和视角切换突出一个极其牛逼，而故事最后有一个情理之中意料之外的超级反转，在我看来，游戏最后一关的内容相当直接升华了整个游戏。当然，本作的美术、音乐和双人互动玩法也都基本全程保持在线的水准，也就中间有几个类Click的玩法环节稍微玩得有点懵逼，其余体验全程都很好。如果喜欢《双人成行》这样分屏玩法的双人合作游戏，那我觉得《逃出升天》也是绝对不能错过的佳作。最后按照惯例扯一嘴奖杯，本作和《双人成行》一样是全彩蛋杯的构成，没有流程杯，以至于打的时候还没通关就白金了…参考攻略照着做就行，没什么难度，经典的好玩好白的模范游戏。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E9%80%83%E5%87%BA%E5%8D%87%E5%A4%A9.jpg"></p><h3 id="战神3-高清重制版"><a href="#战神3-高清重制版" class="headerlink" title="战神3 高清重制版"></a>战神3 高清重制版</h3><p align="justify">点评：2022年才去玩战神3确实是有点太迟了，然后玩了发现…好像比战神4还要更好玩。对比战神4，战神3更倾向于比较纯粹的动作游戏，本作使用了线性的关卡+强制战点的经典ACT游戏流程，中间夹杂一些轻量级的解谜，这种设计反而更契合我的偏好，游戏流程偏短，基本上是全程很爽地打到通关，杂兵敌人的处决以及BOSS战流程的演出依然是顶中顶，魄力十足，特别点名表扬宙斯的BOSS战。能理解战神4为了扩大受众面改成了数值元素更重的ARPG玩法+大地图探索模式，但玩下来总会感觉流程中大量的换皮精英怪尤其是五颜六色的山怪、还有数量奇多的找你妹收集元素弱化了游玩时的爽快动作体验，而战神3的样貌反而才是我期望看到的。本作有泰坦难度通关和打完全部挑战的难度杯，讲真其实也不是很难，一周目我开泰坦难度打下来感觉难度刚好，敌人出招普遍有规律可循，有一定挑战性但并不是完全打不过，几个难的挑战也都有诀窍。游戏通关都用不了10个小时，玩一遍不吃亏不上当，建议有空可以体验体验这款上上个世代的经典动作游戏。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%88%98%E7%A5%9E.jpg"></p><h3 id="Dreams-Universe™"><a href="#Dreams-Universe™" class="headerlink" title="Dreams Universe™"></a>Dreams Universe™</h3><p align="justify">点评：很难用文字比较具体地去评价《Dreams Universe™》这款不太算是游戏的游戏，这款游戏集成了类似于游戏引擎的开发工具，并自带大量的素材，因此可以看作是一款游戏编辑器。创作者们使用游戏内的工具制作好各种素材、完成一部能游玩的完整游戏后，可以通过自带的社区系统分享给其他用户，而其他用户也可以通过游戏内的各种频道去体验他人制作的游戏并留下自己的评价，或者在他人的基础上再对游戏进行二次创作和改动。《Dreams Universe™》自带的工具非常强大，支持创作各种类型各种玩法的游戏，其中很多游戏的质量、可玩性以及创意都非常牛逼，完全拥有优秀独立游戏的质量，即使到现在我还能回忆起里面的一款2D节奏平台跳跃游戏和一款俯视角射击游戏，真的都非常好玩，如果对独立游戏或者游戏创作感兴趣，那我觉得去体验体验本作一定会是很不错的选择。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/Dreams.jpg"></p><h3 id="神狱塔-断罪玛丽-终章"><a href="#神狱塔-断罪玛丽-终章" class="headerlink" title="神狱塔 断罪玛丽 终章"></a>神狱塔 断罪玛丽 终章</h3><p align="justify">点评：神狱塔系列的最终作，本作回收了很多之前的伏笔，交代清楚了神狱塔系列的世界观和背景，并且最终给了主角们一个相当圆满的结局。本作的DRPG玩法基本延续前作，没什么很明显的变化（虽然多了个意义不明的抱脸怪），迷宫设计方面，因为是把海量角色分割成了三队放在一个迷宫里分开进行探索，单个迷宫的规模设计得非常庞大（尤其是中期的两个迷宫），推起来会觉得比较累，但也能称得上尽兴。综合在地雷社作品里较高的游戏性+发挥稳定没什么硬伤完全不犯病的剧本+独特的世界观+系列一贯优秀的人设，总体而言，虽然肯定是不及鲁弗兰这样神作级别的作品，但也算是今年玩下来为数不多能让我觉得满意的优秀作品了。另外就是本作集成了前两作包括特典Gal番外的全部剧情，并新增了新的后日谈TrueEnd，诚意是拉满的，如果对神狱塔这个系列感兴趣，可以直接入本作把前两作的剧情看完了再玩终章的内容，不会有什么门槛。本作奖杯设计延续2代，大多数都是流程杯，勉强可以进白金神作的范畴，唯一稍微麻烦一点的大概也就是好感度全满的杯要来回不停送大量礼物，但也花不了多少时间，属于比较理想的奖杯设计。最后吐槽下，这游戏在国内也太冷门了，bangumi站上连个评分都没有，某宝上就一家店卖中文版，还因为疫情原因延迟发货了好几个月，要不是店家恰好发了条信息，我还以为老版跑路了。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E7%A5%9E%E7%8B%B1%E5%A1%94.jpg"></p><h3 id="最终幻想7-重制版-INTERmission"><a href="#最终幻想7-重制版-INTERmission" class="headerlink" title="最终幻想7 重制版 INTERmission"></a>最终幻想7 重制版 INTERmission</h3><p align="justify">点评：FF7RE本体很久以前就打完了，今年买了PS5之后新买了份实体版游戏来体验一下这个PS5独占的DLC。间章DLC体量一般，流程一共只有两章，故事很短，Gameplay与本篇几乎完全独立，讲真都可以当个新游戏拿来卖了，制作依然是和本体一样很精良，战斗设计有点往ACT的方向靠但依然优秀，新角色尤非的可玩性非常高，如果能操作起来，打起来会特别爽。本篇追加了一个新的BOSS维斯，是DLC奖杯中的最大难点，有一说一，个人不太喜欢这个BOSS的设计，机制上在迫使玩家在前两个阶段就要完成击杀，否则就会进异常难打的惩罚阶段，最后不得不抄作业用铁壁滑铲空翻踢+双倍大魔法的固定策略才打过去。FF7重制版对即时动作和回合策略玩法的结合真的很精妙，DLC在这方面发挥稳定，很推荐在HARD难度下好好体验体验。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B3.jpg"></p><h3 id="师傅（Sifu）"><a href="#师傅（Sifu）" class="headerlink" title="师傅（Sifu）"></a>师傅（Sifu）</h3><p align="justify">点评：首先感谢好基友送上的实体限定版游戏，《师傅》是今年玩下来综合质量最高的独立游戏。作为一款比较纯粹的动作游戏，《师傅》的动作系统说不上有多出色，深度也不是很高，但搓招的手感、战斗的演出和节奏都绝对是一流水准。本作取材于中国武术，极好地演绎出了中国武术的风味，外国团队能做成这样真的觉得很难得。游戏一共就五关的流程，速度快的话几小时就能通关一遍，受制作规模限制，敌人的种类还是非常少，来来回回就几种普通和精英敌人排列组合，好在制作组也知道这一点，把流程控制在五关的小规模，玩家得以在感到疲劳之前就差不多能把游戏打完，回避了重复感偏强的问题。简单来说，《师傅》是一款麻雀虽小五脏俱全并且懂得扬长避短的优秀独立游戏，推荐给动作游戏和受苦游戏的爱好者们。游戏有一个流程中不能死太多次的难度杯，在最新版本中应该是加入了可以作弊的辅助模式，所以奖杯癌们完全不必担心，安心体验游戏就好。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E5%B8%88%E5%82%85.jpg"></p><h3 id="小魔女诺贝塔"><a href="#小魔女诺贝塔" class="headerlink" title="小魔女诺贝塔"></a>小魔女诺贝塔</h3><p align="justify">点评：少见的萌系3D魂like，初次玩会感觉画面和战斗都略显粗糙，但在逐步上手解锁其他三种魔法后，就感觉游戏体验明显好起来了，挺好玩。本作的核心玩法是强射击元素的魔法系统，即消耗魔力释放魔法攻击敌人，魔法可以蓄力释放产生打出更强的效果（例如冰魔法蓄力后可以锁定视野中出现的敌人发动全体冰雹攻击），而魔力作为大量消耗的资源，需要通过近战手段（普攻、闪避或者弹反）来获取，如果在蓄力状态吸收魔力，还可以更快完成蓄力释放蓄力魔法，是一套整体感很强并且各种元素都齐全的战斗系统。个人玩过鲜少在魂like游戏里见到这种强调射击元素，所以游戏体验是比较新鲜的。游戏的另一个亮点是在有限的制作体量下，BOSS战的演出和招式设计质量非常高 ，一共七个BOSS，几乎所有BOSS都能给我留下比较深刻的印象，最终BOSS虽然设计上挺套路，但演出效果还是感觉非常惊艳，打起来体验也很好。地图的设计比较一般，场景略粗糙，流程偏短，剧情姑且可以算是完整吧，但几乎都是站桩对话然后点到为止（配音还挺棒读的），只能说是小团队+小成本制作确实整不出什么好活来了，也能理解。游戏有几个刷子奖杯（用近战吸魔达成300次咏唱等等），需要花一个小时刻意刷一刷。另外有一个进阶难度通关的奖杯，由于二周目默认继承一周目的难度，而游戏设计上难度不能向上调节，所以不存在二周目带着一身神装直接速通进阶难度的情况，想要白金强烈建议一周目直接开进阶难度，真没难到哪里去。特别需要注意几个关卡限定触发杯和收集杯都有可能错过，最好提前看下攻略了解下触发条件和收集品的位置，不然只能下周目来过了，尤其注意第五关连续击杀封印体的条件杯，第一次打死这个怪以后是不允许回家补给的，我就是被这个地方坑了，被迫多打将近一个周目。最后提一嘴，这游戏因为某些不可描述的原因，风评确实不好，只能说很遗憾，个人一向主张把作品和制作者分开，这里也仅仅是单纯评价作品，不评价作品背后这些场外的事情。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E5%B0%8F%E9%AD%94%E5%A5%B3.jpg"></p><h3 id="加雷利亚的地下迷宫与魔女的旅团"><a href="#加雷利亚的地下迷宫与魔女的旅团" class="headerlink" title="加雷利亚的地下迷宫与魔女的旅团"></a>加雷利亚的地下迷宫与魔女的旅团</h3><p align="justify">点评：等了一千年最后也没等来官方中文（明明发售前承诺说会有的），日本一真该本社爆破一下。目前看情况大概率是不会有了，刚好B站看到全部主线剧情的录制和民间翻译咬咬牙还是把坑开了。本作在前作的基础上完善了魔女系列几作的基本世界观和一些核心设定（例如彷徨之魂也就是玩家的誓约），虽然故事中没有明说，两作在暗处也有一定的照应，这点还是挺好的。剧情依然是本作的最大亮点，在前作鲁弗兰的基础上，本作依然讲述了一个相对完整、带有大量伏笔和反转，以及固有的略邪典和猎奇色彩的优秀故事，并且大幅扩展了故事的背景舞台以及登场人物，可以明显感觉到在剧情方面，制作人兼剧本作者泉达也下了很大的功夫，并且也有相当大的野心。遗憾的是，有鲁弗兰珠玉在前，加雷利亚的GamePlay明显逊色了太多。游戏前30小时的体验在大量新能力和优秀地图设计的加持下几乎可以超越鲁弗兰，但故事进入第二部分，引入随机迷宫的概念后，GamePlay逐渐开始失控，最后甚至掏出了长达3651层的超级随机迷宫，把作业量放大到了极致。虽然经过补丁更新后，3651层的爬楼时长已经大幅简化，但刷结魂书、刷结魂书星级、刷多次的人偶转生、刷通关必须要的委托道具，等等等等，依然还有仿佛无穷无尽的刷刷刷在折磨着想要通关看完TE的玩家。流程中的第二部分中会出现一段非常突兀的流程，里面会有独立的BGM和角色Live2D，基本上可以推测是有规划但因种种原因没能完成制作的游戏流程的废案，而随机迷宫包括3651的引入可能也是因为相同的原因不得已而为之，结合游戏多次延期发售的事实，大概率是游戏在开发过程中遇到了一些困难，只能说是非常遗憾了。个人非常喜欢魔女旅团这个系列的故事、美术以及游戏设计，所以也专门为此写了一篇文章作为留念，也希望魔女旅团系列（或者魔女系列也行）在未来还能有更加精彩、完成度更高的续作，只要日本一愿意出，我就必定会支持的。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E5%8A%A0%E9%9B%B7%E5%88%A9%E4%BA%9A.png"></p><h2 id="B级-可以一玩"><a href="#B级-可以一玩" class="headerlink" title="B级 [可以一玩]"></a>B级 [可以一玩]</h2><h3 id="神狱塔-断罪玛丽2"><a href="#神狱塔-断罪玛丽2" class="headerlink" title="神狱塔 断罪玛丽2"></a>神狱塔 断罪玛丽2</h3><p align="justify">点评：《神狱塔》系列的第二作，说是第二作，但和系列第一作并不是时间顺序上的前后关系，某种意义上，《神狱塔 断罪玛丽2》反而更像是前作。《神狱塔》系列三作都是一套经典玩法，没啥区别就不多谈了，重点说下剧情，本作的剧情最好是和系列第一作同步一起看，这样可以比较直观地感受到两作之间剧情发展的差异，体会到剧情设计上的巧思。本作有一个相当值得称道的构思就是在打完游戏本体、播完片尾后，会直接衔接播放第一作的开场动画，然后解锁第一作重制版的游戏内容，玩家需要继续游玩重制版才能解锁本作真正的结局，套娃套出花来了这是。不算特别拉跨的Gameplay、发挥良好的剧本，给个B级没什么问题，没给到A主要还是因为给到系列最终作了。 <p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E7%A5%9E%E7%8B%B1%E5%A1%942.jpg"></p><h3 id="Furi"><a href="#Furi" class="headerlink" title="Furi"></a>Furi</h3><p align="justify">点评：某群友倾情安利多次（其实就是想让我使劲儿受苦）的游戏，特色是全程一共就十场BOSS战，每两场BOSS之间插一段步行+剧情，没有任何杂鱼战或者其他玩法类的内容。由于仅有BOSS战，每个BOSS确实都是花心思设计过的，人设、招式以及演出都拉满了，个个都能留下相当深刻的印象，时隔快一年我都还能记住每个BOSS的形象和尾杀招式。本作是俯视角弹幕射击+简单近战格斗的切换玩法，BOSS会有若干段血条，每一段血条可以看作一个阶段，招式会发生变化，最后一个阶段会进入弹幕密集到发指的尾杀环节。玩家也会有若干条命，每次血条见底后，BOSS会恢复当前阶段的所有血量，回溯到当前阶段开始时重新作战，相应的玩家在每次打掉BOSS一个阶段后，自己也会回复当前血条的所有生命，一来一回，有时一场BOSS战会来回拉锯相当长的时间。本作远程近战两套玩法的手感都非常扎实，狂怒难度下挑战性十足，每场BOSS都需要一定时间去熟悉招式节奏、摸索躲避方法，玩到后面感觉像是在玩节奏游戏。不过也正是因为如此，每场BOSS战的流程变得非常固定，BOSS在什么时候使用会什么招式、招式长啥样、玩家要怎么应对几乎完全是固化的一套流程，熟悉以后就完全是在背板，几乎没有随机性可言，多玩反而会降低游戏体验。本作有困难难度S评价和计时模式限时通关的难度杯，S评价有SL大法，计时模式的时间要求不是很极限，有大约20分钟左右的余裕，只要能把10个BOSS的出招背板背好，还是可以达成这两个杯的。这游戏之前上过会免，所以P9上标了个5%完美的噩梦难度，打完以后成就感还是相当足的。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/Furi.jpg"></p><h3 id="控制（Control）"><a href="#控制（Control）" class="headerlink" title="控制（Control）"></a>控制（Control）</h3><p align="justify">点评：今年游戏荒时趁着烩面玩上的游戏，一般来说我是不太碰比较写实+射击玩法的欧美游戏的，所以这次玩《控制》确实比较难得。本作的特色在于场景氛围的营造，逼真的光影效果和大面积纯色的色彩设计带来强烈的视觉冲击，神神叨叨的剧情和奇怪的音效呈现出一种明明没什么恐怖元素但就是感到诡异的游戏体验。游戏中涵盖了相当大量的文件类收集品，涉及到很多类似于SCP档案的怪谈元素，是本作的另一个亮点。声光氛围确实牛逼，但相比之下游戏的Gameplay就有些灾难了。本作可以看作一种更加另类的3D银河恶魔城，由于主要的活动区域是纵深跨度很大的室内大楼，场景辨识度偏低，自带的地图没有很好区分场景纵深，指引效果奇差，如果没有攻略提示经常会遇到不知道往哪走怎么走的问题。战斗玩法问题很大，部分数值尤其是某些敌人的伤害设置得很不合理，玩法的丰富度和深度也相当有限，后期大量密集杂兵战处理起来非常没意思。游玩部分唯一能算加分项的可能只有烟灰缸迷宫部分，在背景音乐和场景的加持下确实是燃起来了，只是这一块流程太短了，打完只能说意犹未尽。最后提一嘴本作PS5版集成了一击必杀无敌这种辅助作弊功能，开了以后游戏就没有任何难度可言了，单纯想体验下叙事的可以考虑开了玩玩。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%8E%A7%E5%88%B6.jpg"></p><h3 id="恶魔之魂"><a href="#恶魔之魂" class="headerlink" title="恶魔之魂"></a>恶魔之魂</h3><p align="justify">点评：买PS5的主要原因就是想体验下恶魂，具体打下来的话，我是觉得恶魂的玩法、关卡设计和一些特有机制（比如世界倾向和个人倾向）以现在的目光来看都做得不是很好，游戏体验非常一般，但考虑到是老游戏移植而且基本没做改动，也能理解。恶魔之魂的意义更多是奠定了后面黑暗之魂系列的基调，黑暗之魂系列3D银河恶魔城的框架，地图的设计逻辑，入侵玩法等元素都能在恶魔之魂里找到雏形，所以恶魔之魂具有的更多是历史意义，而不是说这款游戏本身有多么多么好。恶魂的白金在不借助他人帮助的情况下，需要比较严格地按照流程依次实现世界纯白、世界纯黑、个人纯白和个人纯黑，完成相关支线事件来完成收集类奖杯，建议照着靠谱的攻略走一遍避免遗漏，重要支线错过的话只能下周目再见了。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%81%B6%E9%AD%94%E4%B9%8B%E9%AD%82.jpg"></p><h3 id="神之亵渎（Blasphemous）"><a href="#神之亵渎（Blasphemous）" class="headerlink" title="神之亵渎（Blasphemous）"></a>神之亵渎（Blasphemous）</h3><p align="justify">点评：游戏名字翻译为渎神好像听着更帅一点？一款比较中规中矩的银河恶魔城游戏，一遍打下来感觉就是没有非常突出的优点，但也没有什么特别短的短板，属于没游戏玩的时候可以拿出来一玩的游戏。硬要说哪里不好大概是部分地图的地形机制设计得过分恶意，点名批评雪山的刮风机制和部分场景的掉落即死，个人觉得类银河恶魔城游戏里出现掉落即死对游戏体验真的是毁灭性打击。其余还有一些细节体验不是很好，比如存档点不回蓝要反复自残、能力道具有装备上限要经常手动切换，都是多此一举、硬要玩家去做的不便民操作。奖杯方面有收集、支线任务和难度杯（不喝药击杀所有BOSS以及一个简单的速通挑战）。只是通关的话，这游戏的BOSS普遍不难，攻击方式比较单一，所以一周目不喝药不难完成。而要做速通就必须要舍弃收集和支线，不太适合放在一周目做，可以二周目继承一周目的档，或者直接开个新档完成，B站上有详细的路线规划可以参考。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E7%A5%9E%E4%B9%8B%E4%BA%B5%E6%B8%8E.jpg"></p><h3 id="SINce-Memories-星穹之下"><a href="#SINce-Memories-星穹之下" class="headerlink" title="SINce Memories 星穹之下"></a>SINce Memories 星穹之下</h3><p align="justify">点评：《告别回忆》系列精神续作，讲道理本作既然都出现了祖传角色稻穗信还提到了很多前作的事情，直接叫《告别回忆9》是一点问题都没有的，不知道为什么5pb要另起炉灶开个像是新IP的新标题。言归正传，本作玩下来感觉质量至少是比系列5-7代的平均水平要高的，虽然主线和支线埋下的悬念大多都是完全能准确猜到的经典展开，但各条线路的情节发展大体符合逻辑（虽然极少数地方还是会有强行降智的情节出现），除了某个不可攻略有独立立绘的女配角相关的剧情总感觉像是被砍了以外，伏笔基本上都有回收，剧本质量至少算中规中矩，优梨子和英线的观感还可以称得上不错。这次换了新画师做角色设计，个人挺喜欢这个画师的人设风格的，可以给个好评。最后强烈安利一下优梨子线的ED兼角色歌《Long For You》，网易云有，真的相当好听，游戏故事中对这首歌的清唱演绎也是个人钦定的本作最强演出。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%98%9F%E7%A9%B9%E4%B9%8B%E4%B8%8B.jpg"></p><h3 id="The-Pathless（无路之旅）"><a href="#The-Pathless（无路之旅）" class="headerlink" title="The Pathless（无路之旅）"></a>The Pathless（无路之旅）</h3><p align="justify">点评：超出预期的优秀开放世界解谜作品，美术风格独树一帜，射箭加速的手感丝滑，BOSS战的演出效果也很惊艳。美中不足的地方是作为一个主打解谜的开放世界游戏，对开放世界的填充还是略微单薄了些，用于解谜的机制偏少，导致越到后面重复度越高，漫山遍野找红光，谜题普遍不难，来来回回就那么几个套路，作业感特别强，找久了眼睛也不太舒服…适当加入一些其他的玩法元素做个调节感觉会更好一些。白金基本就是把游戏里全部四个区域的红光谜题过一遍就差不多了，有几个触发类型的杂项条件杯根据条件做一遍就行，并不困难，是大约10-15小时就能白金的作品。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/Pathless.jpg"></p><h3 id="迷失（Stary）"><a href="#迷失（Stary）" class="headerlink" title="迷失（Stary）"></a>迷失（Stary）</h3><p align="justify">点评：首发就进PS二档会员的猫猫模拟器，玩家在游戏里需要操纵一只猫猫在没有人类的赛博城市里冒险。游戏的制作精度是拉满了，画面、音效以及猫猫的动作设计和操作反馈都相当优秀，操作小动物尤其是可爱的猫咪，这种感受很新鲜，可是游戏的玩法却实在是过于普通，流程也特别短，作为一个3D冒险解谜游戏，相当一部分的谜题都是找你妹和Click，为数不多冒险解谜环节也是很常规的一套（比如潜行+躲避光线、需要规划下路线的追逐战等等），实在没什么新意，也不是很好玩。个人对游戏的画面没有特别高的要求，对游戏的评价还是更多基于玩法的体验层面，所以这款游戏的评价不会给高，但空闲时还是值得一玩的。最后不得不吐槽躲猫猫奖杯，要求在不碰到怪的情况跑完一次大约50秒左右的追逐战，各种方法都试过感觉就是没有技巧全看运气，反反复复试了可能有两个多小时最后运气来了才侥幸拿到这个奖杯，这种给不给全看天的奖杯，打起来体验有些微妙的，白金癌真的害死人。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E8%BF%B7%E5%A4%B1.jpg"></p><h3 id="AI-梦境档案-涅槃肇始"><a href="#AI-梦境档案-涅槃肇始" class="headerlink" title="AI:梦境档案 涅槃肇始"></a>AI:梦境档案 涅槃肇始</h3><p align="justify">点评：熟悉我的朋友都知道《AI:梦境档案》也就是本作的前作是个人入常级作品，通俗来说就是玩之前抱有高期望但玩下来非常失望的作品。因此本作自打一开始就没抱期望，结果玩下来感觉反而好了很多。本作的剧情核心设计依然是打越经典老三样，因为实在品鉴多了，其中一个核心诡计稍微玩了一会儿就大概猜出来了…虽然几个核心诡计的设计还是略显生硬，但至少没有很明显的逻辑漏洞，过程中玩的时候会察觉到很多异样感，可以看作是一种提示，总之没有像前作最后才交代一个核心设定一样坑爹，这就可以算是有所进步了。抛开剧情的话，本作在玩法层面更是进了一大步：前作最令人诟病的点就在于核心的梦界玩法没有逻辑可言，以随机选择然后反复试错为主，本而作在前作的基础上大幅强化了梦境世界探索的逻辑感，纯Click的部分大幅减少，部分梦界也做得很出色，这是我对本作评价提升的主要原因。当然了遗憾肯定是有的，本作的两条支线的感染力要明显逊色于前作，会有一些凑数感，很难打动到玩家，感觉是制作上没有花太多的心思的缘故，希望打越老师后面还能再有突破，写出更好的剧本作品吧。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%A2%A6%E5%A2%83%E6%A1%A3%E6%A1%88.jpg"></p><h3 id="记忆边境（Thymesia）"><a href="#记忆边境（Thymesia）" class="headerlink" title="记忆边境（Thymesia）"></a>记忆边境（Thymesia）</h3><p align="justify">点评：国产小体量类魂游戏，优缺点都挺明显。优点在于战斗系统做出了一些特色，双层血条以及可搭配瘟疫武器的设计在体验层面上都比较新鲜，打起来视觉效果也很帅。缺点在于体量太小，流程相当短，敌人的种类相当有限，打来打去就是那么几只精英怪，到游戏中后期重复作业感非常强，有些令人感到乏味。本作的战斗系统与其说是类魂不如说更有点偏向只狼，弹刀扮演了非常重要的角色，点了延长弹刀判定的天赋后甚至可以用祖传抖刀术轻松弹下几乎所有攻击，挺BUG的。鉴于战斗系统有特色而且手感确实不错，喜欢类魂或者ACT类游戏的玩家可以尝试尝试，游戏不是很贵。白金比较麻烦的点是全收集尤其是全药水，少数药水材料的爆率很低而且全凭运气，如果运气不好前面流程不掉药水原材料的话，通关要反复回去刷刷刷，没有技巧，全看运气，牛至这个神必材料刷了我快一晚上，真是醉了。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E8%AE%B0%E5%BF%86%E8%BE%B9%E5%A2%83.jpg"></p><h3 id="TOEM"><a href="#TOEM" class="headerlink" title="TOEM"></a>TOEM</h3><p align="justify">点评：烩面送的小品游戏，黑白色调的卡通风格玩起来比较舒适，游戏氛围很轻松，音乐也很好听。游戏的核心玩法是拍照，玩家需要操作角色按照NPC们的委托要求，在合适的地点拍出合适的照片，是比较少见的玩法模式，但本质上还是Click的变体。游戏正常流程找你妹和试错为主，但玩法层面稍显单调，在拍照玩法和卡通风格的包装加持下，反而给游玩体验多加了一层趣味感。这款游戏可以说的地方不多，是比较难得的玩起来很舒服的类Click游戏，放在大作之间玩一玩调剂一下心情，还是相当合适的。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/TOEM.jpg"></p><h2 id="C级-不太推荐"><a href="#C级-不太推荐" class="headerlink" title="C级 [不太推荐]"></a>C级 [不太推荐]</h2><h3 id="秋之回忆-5-中断的胶片"><a href="#秋之回忆-5-中断的胶片" class="headerlink" title="秋之回忆#5 中断的胶片"></a>秋之回忆#5 中断的胶片</h3><p align="justify">点评：年代相对久远的GAL作品了，既然是GAL那最核心的肯定就是剧情，至于本作的剧情…我觉得不能说不好，但是确实是不太合我胃口，我玩下来最直观的感受就是，很多直接推动剧情的情节都来自于角色之间的冲突，而这些冲突的起因往往是我理解不了的。不管是男主还是其他角色都经常莫名其妙地表现出一波低情商然后莫名其妙地吵起来，真的很难和游戏中地角色们产生共情。另外本作开局自带一个好感度拉满甚至有点过于满的青梅竹马系角色，我一直觉得如何在其他线路中比较稳妥地处理好这类开局好感爆表的角色会比较考验编剧的笔力，而本作我感觉对此处理得也不是很好，再加上本作因为年代原因画风比较复古，所以把评价放在了比较低的位置。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E8%83%B6%E7%89%87.jpg"></p><h3 id="盐与献祭（Salt-and-Sacrifice）"><a href="#盐与献祭（Salt-and-Sacrifice）" class="headerlink" title="盐与献祭（Salt and Sacrifice）"></a>盐与献祭（Salt and Sacrifice）</h3><p align="justify">点评：带着高期待首发入的游戏，作为《盐与避难所》的续作，本作的质量有些一言难尽，如果说前作是2D黑暗之魂，那本作就是融合了怪物猎人、恶魂、黑魂、只狼、仁王等各类游戏元素的梦魇缝合怪，之所以是梦魇缝合怪是因为缝合的元素几乎都不是什么好的元素，比如学习恶魂的独立关卡制地图+篝火不能传送，让游戏失去了2D银河恶魔城世界的整体感，不能传送后跑图的体验也非常差劲，再比如学习怪物猎人的素材掉落、装备制作和狩猎系统，但这套模式明显与2D魂的框架八字不合，作为狩猎目标的法师会不断换区，追逐法师的体验极其糟心，同屏里出现2-3个法师群魔乱舞更是让人血压拉满。战斗方面，本作不仅没有把掉落伤害的机制优化优化（重申一次，银河恶魔城里做掉落伤害真的是非常毁灭体验！），反而变本加厉让角色在滞空状态下没有任何保护，于是经常会出现被BOSS一套Combo产生连续滞空被一套连死的情况，非常阴间，不由得怀疑制作组是不是向鬼泣反向取经了。为了向魂看齐，本作还加入了誓约和入侵的玩法，从首发版本的体验来看，PVP的平衡性很差，有一些非常无赖的武器（比如蘑菇弓），遭到入侵时很难反制，依然是不太成功的新尝试。总之本作不太推荐一个人单独玩，真的会被气死，要玩的话建议多人联机一起开荒，应该会比单人要有意思的多。奖杯需要收集一些强化道具的收集品，参考攻略并不困难，白金难度倒是比较低的。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E7%9B%90%E4%B8%8E%E7%89%BA%E7%89%B2.jpg"></p><h3 id="The-Artful-Escape"><a href="#The-Artful-Escape" class="headerlink" title="The Artful Escape"></a>The Artful Escape</h3><p align="justify">点评：PS二档会员白嫖游戏，算是个小制作的小品级游戏，大概三个小时左右就能通关，想白金留意一下几个触发杯的条件即可。游戏的声光效果做得非常不错，美术相当漂亮，虽然画面比较闪但是意外地看着挺舒服的。比较遗憾的是游戏的Gameplay部分实在是乏善可陈，作为核心玩法的音乐QTE和平台跳跃体验下来都挺无聊，能玩下去几乎全靠画面演出和音效吊着。小品游戏要求也不能太多，花几个小时就当看场电影、听听音乐，然后顺带着白金喜加一，这样也挺好的。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E5%A5%87%E5%A6%99%E9%80%83%E4%BA%A1.jpg"></p><h3 id="影子武士3（Shadow-Warrior-3）"><a href="#影子武士3（Shadow-Warrior-3）" class="headerlink" title="影子武士3（Shadow Warrior 3）"></a>影子武士3（Shadow Warrior 3）</h3><p align="justify">点评：又一款PS二档会员白嫖的游戏，略显粗制滥造，定位是爽游，但玩起来很难觉得爽。游戏的战斗打击感几乎没有，刀砍上去的感觉像是劈在空气上，跑酷动作的判定非常怪异，部分需要高强度跑酷动作的流程打起来异常头疼，各种莫名其妙的Bug也层出不穷，相当影响体验。战斗部分密集度偏高，中后期有大量的堆怪，来来回回就那么几种怪反反复复打114514遍，连着打属实有些遭不住，人都打麻了，最多也就当个调剂性质的游戏作品图一乐了。游戏算半个白金神作，大约10小时就能白金，就是流程中需要注意藏在犄角旮旯的收集品，然后有意识地去清一下自带的挑战任务，部分挑战任务的条件挺那啥的，刷刷刷体验不佳，所以需要点耐心。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E5%BD%B1%E5%AD%90%E6%AD%A6%E5%A3%AB.jpg"></p><h3 id="麻布仔大冒险"><a href="#麻布仔大冒险" class="headerlink" title="麻布仔大冒险"></a>麻布仔大冒险</h3><p align="justify">点评：奔着多人合作入的游戏，然后发现这游戏单人玩反而比多人玩体验更好，实在有点离谱。抛开因为网络带来的延迟和卡顿问题不谈，普通关卡在设计上并不强调合作，联机的感觉像是几个人在一起闯同样的一关，并且因为生命多人玩反而让游戏容错率变得更低了。大概是因为最多支持四人游戏，多人模式没有做成类似于双人成行一样的分屏，同屏设计没有很好地指示玩家自己操作的角色的位置，联机过程中经常会出现看错自己的角色、不知道自己的角色跑哪去了这样的尴尬情况，距离拉得太远还会受到视角的影响妨碍操作，总之多人体验不好。游戏的操作上限不高，部分动作尤其是跳跃+滞空的手感比较奇怪，又因为是3D场景，部分固定视角下会出现因视觉错位对不上方位而怎么也跳不到目标位置一直摔死的糟心场面，感觉小小大星球这次的3D化尝试并不成功，不是很推荐玩。奖杯设计方面，按照惯例有累计若干个关卡无伤、若干个关卡金牌这样的难度杯，部分流程比较长的关卡需要耐心一点多试几次。最麻烦的是最后一关要求挑战金牌的奖杯，需要玩家在有限的时间内连着跑一遍15关挑战，而且仅允许一次失误，非常难，需要花大量时间练习和尝试，为了拿这个金杯我花了一个星期不到的时间，加起来有六七个小时，如果是打杯人想开坑的话可以先提前看看相关视频评估一下。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E9%BA%BB%E5%B8%83%E4%BB%94.jpg"></p><h3 id="死亡终局-轮回试炼（Death-end-re-Quest）"><a href="#死亡终局-轮回试炼（Death-end-re-Quest）" class="headerlink" title="死亡终局 轮回试炼（Death end re;Quest）"></a>死亡终局 轮回试炼（Death end re;Quest）</h3><p align="justify">点评：挺有想法的剧本和玩法，但是摊上了稀烂的低成本制作，剧情虎头蛇尾，玩法自我矛盾，关卡设计不明所以，为数不多稍微能拿出手的也就人设和音乐还算可以。说得很难听，其实倒也没烂到无药可救的地步，就是感觉明明可以做得蛮好却偏偏做成了最拉的样子，觉得非常可惜，推完结局感慨万千，特意写了一篇<a href="https://inarimoe.top/2022/10/25/%E6%AD%BB%E4%BA%A1%E7%BB%88%E5%B1%80%20%E8%BD%AE%E5%9B%9E%E8%AF%95%E7%82%BC%E7%9A%84%E5%A6%A5%E5%8D%8F/" target="_blank">长文</a>来纪念这款清奇的游戏。奖杯设计方面没有为难人的地方，基本都是流程杯，有个剧情收集杯，流程中需要多存档刻意走几个BE就行。每个角色各有一个结局杯（讲道理除女主外其他角色个人结局的存在意义无限趋近于零），必须要二周目才能通过SL全部触发一遍，有一点点阴间，好在二周目速通起来也就半天时间，虽然要重跑一遍皇宫和造船厂这两张顶级阴间地图实在有点恶心…骂归骂，这个游戏虽然烂但挺对我胃口，打完以后特意花钱收了份港版限定实体版，挺大一盒子，内容挺多，设定集的质量也挺不错，果然傻逼二刺螈的钱是真的有点好赚。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E6%AD%BB%E4%BA%A1%E7%BB%88%E5%B1%80.jpg"></p><h3 id="奈尔克与传说的炼金术士们-～新大地的炼金工房～"><a href="#奈尔克与传说的炼金术士们-～新大地的炼金工房～" class="headerlink" title="奈尔克与传说的炼金术士们 ～新大地的炼金工房～"></a>奈尔克与传说的炼金术士们 ～新大地的炼金工房～</h3><p align="justify">点评：炼金工房系列20周年纪念作品，去年就开坑了但一直拖到今年才通关白金。游戏算是个外传性质的粉丝向作品，玩法与炼金工房系列的正作有很大的区别，是经营类游戏。游戏核心相较于其他经营类游戏可能还更简单一些，大体还是发展建筑→生产材料→制造商品→贩卖商品→创造营收→进一步发展建筑这套经典循环，但实际操作起来却非常繁琐，比方说建筑物的在布置一定要沿路的设计，导致中后期想要大规模修改城镇布局突出一个难受，再比方说没有能一键解除进驻建筑的角色及工作的快捷操作，想换人还要一个个反复操作，真的特别麻烦，材料和商品的存量是否满足生产和贩卖的需求，这些重要信息没有便捷提示，让明明非常简单的流程需要花大量的时间精力去操作和计算，玩起来甚至有些痛苦。游戏的经济曲线怪异，前期穷的一个几万块钱的地标都造不起，后期产业链完善后，一个回合营收直接可以跑到三四百万，完全没有能花出去的渠道，总之经营部分的体验并不是很好。游戏的主要卖点还是系列正作中有出现的一共108名角色都会在本作中登场，各作主角也会有比较多的剧情事件互动，情怀肯定是拉满了。我个人只玩过不可思议系列，即便如此，当通关后游戏ED播出来，历代游戏的封面和CG滚动播放时，也能体会到这个系列20年以来十几部作品能持续性推出的来之不易，如果是系列老玩家相比会更加有感触。本作的奖杯设计纯刷，几乎全部都是累计杯，最麻烦的奖杯是达成500次城镇任务，没有难度，就是要花时间耐心去刷，自己摸索着玩的话，白金时间估计在60-70小时左右，如果一开始就去参考他人的城镇布局提前规划产业链，能省去相当多的时间。唯一需要注意的点是主线中的课题8，虽然不难，但如果浪费大量回合，还是可能会达不成营业额目标然后翻车的，特别注意把几个附属课题都完成掉拿人口，不然课题9的人口目标可能会达不成，本作如果达不成课题目标会Game Over，只能读之前的存档，如果GG了会浪费大量时间。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/2022%E5%B9%B4%E5%BA%A6%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/%E5%A5%88%E5%B0%94%E5%85%8B.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p align="justify">　　今年下半年起因为种种原因，推游戏的速度和热情都下降了蛮多，所以下半年玩的游戏明显变少了。一般来说，每年大量的新作旧作玩下来，会给到2-3个游戏S的评级，但今年只有《艾尔登法环》能给到S，甚至我对《艾尔登法环》的部分战斗设计还不太满意，可能是玩的游戏越来越多以后自己要求也不知不觉间变高了，也可能是名声在外的优秀作品之前基本都玩过了的缘故。明年的话，想玩的新作确实是有不少，但到底最后能玩上多少也还不好说，总之还是希望自己可以尽量保持住对电子游戏的热情吧。]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主机游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桌游介绍：《双子星》</title>
    <link href="/2022/12/14/%E6%A1%8C%E6%B8%B8/%E6%A1%8C%E6%B8%B8%E4%BB%8B%E7%BB%8D-%E5%8F%8C%E5%AD%90%E6%98%9F/"/>
    <url>/2022/12/14/%E6%A1%8C%E6%B8%B8/%E6%A1%8C%E6%B8%B8%E4%BB%8B%E7%BB%8D-%E5%8F%8C%E5%AD%90%E6%98%9F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h2><p>类型：对战类桌游<br>人数：1-2人<br>游戏时长：10-20分钟<br>配件：<br>双人玩法用游戏牌60张。<br>单人玩法用游戏牌6张。<br>计分板2块。<br>说明书1份。<br>多面骰子4枚。<br>生命值指示物2个。</p><h2 id="规则说明"><a href="#规则说明" class="headerlink" title="规则说明"></a>规则说明</h2><h3 id="游戏准备"><a href="#游戏准备" class="headerlink" title="游戏准备"></a>游戏准备</h3><p>-双方玩家各自选择自己使用的角色，拿取对应的牌堆（30张游戏牌），计分板和指示物3枚。<br>-将蓝色骰子作为护盾值放置于计分板的护盾位（初始值为2）。<br>-将绿色骰子作为魔力值放置于计分板的魔力位。<br>-将生命值指示物放置于计分板的生命值位（初始值位20）。<br>-使用硬币或其他方式决定先后手，切洗牌堆。先手玩家抽3张牌，后手玩家抽5张牌。<br>-从先手玩家开始轮流执行回合，首先将对方生命值变为0的玩家取得游戏胜利。</p><h3 id="回合流程"><a href="#回合流程" class="headerlink" title="回合流程"></a>回合流程</h3><p>-每个回合由4个连续的阶段组成，每个阶段结束后，进入下一个阶段。<br>-阶段1：护盾回复阶段。玩家将自己的护盾值调整为2点。<br>-阶段2：行动阶段。玩家在行动阶段可以以任意顺序多次执行使用卡牌和升华卡牌这两种操作。<br>使用卡牌：玩家将1张手牌放置于出牌区域，或是将升华区域内一张竖直的牌横置，然后执行该牌的效果。<br><em>注意：部分卡牌存在[使用条件]字样，有[使用条件]字样的卡牌需要满足卡面中的条件后才能使用。</em><br><em>注意：部分卡牌存在[顺应]字样，有[顺应]字样的卡牌可以在卡面中标注的时机于对手回合内使用。</em><br>升华卡牌：当玩家仍有空的升华槽位时，可以将从自己的手牌或出牌区域内选1张牌放置于升华区域。<br><em>注意：升华区域中的卡牌占用1个升华槽位，玩家废除区域中每有七张废除牌，便获得1个升华槽位。</em><br><em>注意：游戏开始时，玩家的初始升华槽位是0。</em><br><em>注意：如果将出牌区域内的卡牌升华，将卡牌横置放置。如果从手牌中升华卡牌，将卡牌竖直放置。</em><br><em>注意：升华区域内的卡牌被废除后不放置于废除区域，而是将升华区域内的该牌翻至背面朝上。</em><br><em>注意：被废除的升华卡牌无法再使用，不计入废弃牌的总数，也不会腾出新的升华槽位。</em><br><em>注意：[召唤]类型的卡牌无法升华。</em><br>-阶段3：废除阶段。玩家从手牌或出牌阶段内选择至多2张卡牌废除至废除区域。<br><em>注意：先手玩家第一回合仅能废除1张卡牌。</em><br><em>注意：被废除至废除区域的卡牌在本局游戏中不能再使用。</em><br>-阶段4：调整阶段。玩家弃光自己的手牌和出牌区域内的卡牌，抽5张牌，再将升华区域的所有牌竖直。<br><em>注意：如果牌堆剩余数量不够抽，先抽光剩余牌，然后将所有弃牌混洗成新的牌堆，抽完剩下的牌。</em><br><em>注意：全部操作结束后，若自己牌库和弃牌堆都没有任何卡牌了，触发[空场追击]，削减对手4点生命值。</em><br>-全部四个连续阶段结束，进入对手的回合。</p><h3 id="区域划分"><a href="#区域划分" class="headerlink" title="区域划分"></a>区域划分</h3><p>游戏的区域划分偏多且容易混淆，需要特别进行说明：<br>-计分板区域：用于放置3个指示物记录玩家的护盾值、魔力值以及生命值。<br>-牌堆区域：用于放置玩家抽牌时的牌堆。<br>-出牌区域：用于放置玩家使用的非[召唤]类型的牌，玩家在调整阶段需要将自己出牌区域的所有卡牌弃置。<br>-召唤区域：用于放置玩家使用的[召唤]类型的牌，召唤类型的牌持续性生效，不会在调整阶段中被弃置。<br>-升华区域：用于放置玩家升华后的卡牌，废除区域每有7张牌便解锁一个槽位。<br><em>注意：升华区域放置的卡牌有横置和竖置两种状态，横置表明当前回合已用过该卡牌且本回合不能再用了。</em><br><em>注意：升华区域放置的卡牌会固定在玩家的调整阶段竖置，换言之，升华卡牌每回合都可以被用一次。</em><br>-废除区域：玩家在非升华区域内废除的卡牌放置入废除区域，每7张为一组放置标示玩家的升华槽位数量。<br>-弃牌区域：玩家弃置卡牌后将卡牌放置入弃牌区域，牌堆无牌可抽时需要将弃牌区域洗牌作为新的牌堆。<br><em>注意：弃置和废除是不同概念，执行后分别放置于弃牌区域和废除区域，废除的牌是不会再进牌库的。</em></p><h3 id="卡面信息"><a href="#卡面信息" class="headerlink" title="卡面信息"></a>卡面信息</h3><p>-类型标识：位于左上角，表示卡牌类型。分为SWORD、MAGIC、SUPPORT和SUMMON和不净线五种。<br>SWORD：物理，具有[物理攻击]效果的卡牌。<br>MAGIC：魔法，具有[魔法攻击]效果的卡牌。<br>SUPPORT：辅助，具有回复体力值，增加魔力等辅助效果的卡牌。<br>SUMMON：召唤，使用后能持续性提供增益的卡牌，不能升华。<br>不净线：废牌，无法使用也无法升华，只能用于废除。<br>-COST：位于类型标识下方，标识卡牌的魔力值消耗。玩家使用带有COST的卡牌需要消耗相应的魔力。<br><em>&#x2F;&#x2F;注意：COST是只有[魔法]和[召唤]类型的牌才有，魔力值不够便无法使用。</em><br>-卡牌名称：标识卡牌的名称。<br>-卡牌效果：标识卡牌的具体效果。</p><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>物理攻击（X）：造成X点伤害，优先消耗对手的护盾值。<br><em>举例：5点物理伤害打在2点护盾上，护盾归0，生命值减少3点。</em><br>魔法攻击（X）：造成X点伤害，但无视对手的护盾值，直接扣减对手X点生命值。<br>召唤：[召唤]类型卡牌独有，使用后不进出牌区域而是放进召唤区域持续性产生效果。</p><h3 id="其他细则"><a href="#其他细则" class="headerlink" title="其他细则"></a>其他细则</h3><p>-玩家随时都可以查看自己的牌堆和弃牌，以及双方废除区域内的卡牌。<br>-若玩家查看自己的牌堆，需要看完后将牌堆洗牌。<br>-若玩家召唤区域内有多张牌同时产生效果，玩家自己决定效果的执行顺序。<br>-对于[顺应]效果的卡牌：玩家在对方回合内使用后也置入自己的出牌区域执行效果，在自己下个调整阶段放入弃牌堆。</p><h3 id="单人玩法"><a href="#单人玩法" class="headerlink" title="单人玩法"></a>单人玩法</h3><p>-单人游戏中玩家扮演FIRVIA，挑战CHERIONE。<br>-CHERIONE不使用常规牌库，而是使用6张单人游戏专用卡牌。<br>-游戏开始前，将6张牌混洗后以背面向上放置。<br>-在单人玩法中，玩家默认先手，且每个回合的流程和操作细则与双人游戏一致。<br>-对于对手CHERIONE，回合流程和双人游戏有一定区别，分为3个阶段。<br>-护盾回复阶段：CHERIONE将护盾调整至2点，和玩家一致。<br>-等级提升阶段1：CHERIONE的魔力等级+1。<br>-等级提升阶段2：当魔力等级首次变为1、4、7时执行。<br>-此时将一张牌背上的数字与魔力等级相同的单人游戏牌翻至正面朝上。<br><em>注意：单人玩法下，CHERIONE的魔力被称为魔力等级，而非玩家消耗用的魔力。</em><br>-行动阶段：对于已经翻至正面朝上的单人游戏牌，按照魔力等级从低到高的顺序依次执行这些牌的效果。</p><h2 id="个人简评"><a href="#个人简评" class="headerlink" title="个人简评"></a>个人简评</h2><p>比较另类的逆向DBG游戏，这个游戏是反向的DBG思路，把不要的牌从牌堆中去掉，精简牌库打出连招。<br>拿到手以后没怎么玩，单看规则摸不太清门路，只是感觉30张牌的规模，牌的种类少，策略度比较受限。<br>规则比较简单，只需要简单讲解就能理解游戏的玩法，相对适合在2人小聚会的场合拿出来玩几把。<br>官中版本的游戏说明书对一些名词和规则的讲解不是很清楚。<br>本文是在说明书的基础上按照自己的理解做了补充和释义。<br>本作是日产（风荣社）桌游，参考封面，风格非常二刺螈。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>桌游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#学习笔记-面向对象</title>
    <link href="/2022/12/13/%E7%AC%94%E8%AE%B0/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/12/13/%E7%AC%94%E8%AE%B0/C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h3 id="003-使用输出语句和Debug模式调试程序-x2F-004-中断模式下的窗口介绍"><a href="#003-使用输出语句和Debug模式调试程序-x2F-004-中断模式下的窗口介绍" class="headerlink" title="003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍"></a>003-使用输出语句和Debug模式调试程序 &#x2F; 004-中断模式下的窗口介绍</h3><h4 id="断点的设置与中断模式窗口"><a href="#断点的设置与中断模式窗口" class="headerlink" title="断点的设置与中断模式窗口"></a><strong>断点的设置与中断模式窗口</strong></h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">设置断点的四种方法：<br><span class="hljs-number">1</span>.右击代码⾏，选择<span class="hljs-built_in">breakpoint</span>(断点) -&gt; insert breakpoint（插⼊断点）。<br><span class="hljs-number">2</span>.光标定位到代码⾏，选择菜单上的<span class="hljs-built_in">Debug</span>(调试)-&gt;Toggle <span class="hljs-built_in">Breakpoint</span>(切换断点)。<br><span class="hljs-number">3</span>.光标定位到代码⾏，按下F9键，在此按下F9是取消断点。<br><span class="hljs-number">4</span>.在需要添加断点的⾏⾸位置，直接单击，再次单击取消断点。<br><span class="hljs-comment">//运行程序时，会在断点的位置停下，此时可以通过窗口查看当前代码中各变量对应的值便于程序调试。</span><br><span class="hljs-comment">//显示出现的各变量的值均是当前所运行的方法中变量的值。</span><br><span class="hljs-comment">//调⽤堆栈窗⼝下可以观察到当前代码执⾏到哪⼀⾏了，且可以看到这个代码的是被什么语句调⽤的。</span><br><span class="hljs-comment">//即时窗⼝可以输⼊⼀些命令，查看变量的值，修改变量的值，可以输⼊表达式查看结果。</span><br></code></pre></td></tr></table></figure><h3 id="005-逐语句和逐过程（中断模式）"><a href="#005-逐语句和逐过程（中断模式）" class="headerlink" title="005-逐语句和逐过程（中断模式）"></a>005-逐语句和逐过程（中断模式）</h3><h4 id="逐语句和逐过程"><a href="#逐语句和逐过程" class="headerlink" title="逐语句和逐过程"></a><strong>逐语句和逐过程</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">在中断模式下我们可以单步执⾏代码，单步执⾏带有有两种：逐过程和逐语句。<br>两类单步执行都是⼀条语句⼀跳语句的执⾏，区别在于：<br>逐过程遇到函数，不会进⼊函数内部⽽把函数当成⼀条语句去执⾏。<br>而逐语句会进入函数内部并在函数内逐条执行代码。<br></code></pre></td></tr></table></figure><h3 id="006-关于程序中的异常-x2F-007-使用try-catch-finally语句处理异常"><a href="#006-关于程序中的异常-x2F-007-使用try-catch-finally语句处理异常" class="headerlink" title="006-关于程序中的异常 &#x2F; 007-使用try-catch-finally语句处理异常"></a>006-关于程序中的异常 &#x2F; 007-使用try-catch-finally语句处理异常</h3><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">异常是在运⾏期间代码中产⽣的错误。<br>异常发⽣的时候，程序会终⽌掉，然后异常后⾯的代码都⽆法执⾏。<br></code></pre></td></tr></table></figure><h4 id="异常的处理：try-catch-finally语句"><a href="#异常的处理：try-catch-finally语句" class="headerlink" title="异常的处理：try catch finally语句"></a><strong>异常的处理：try catch finally语句</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">try <span class="hljs-regexp">//</span>放置可能出现异常的代码。<br>&#123;<br>...<br>&#125;<br>catch( &lt;exceptionType&gt; e ) <span class="hljs-regexp">//</span>放置异常类型，例如IndexOutOfRangeException。<br>&#123;<br>... <span class="hljs-regexp">//</span>出现异常时如何处理（执行什么语句）。<br>&#125; <span class="hljs-regexp">//</span>catch可以并列放置多个异常类型。<br>finally <span class="hljs-regexp">//</span>无论代码是否出现异常，都会执行后续的代码。<br>&#123;<br>&#125;<br><span class="hljs-regexp">//</span>其中catch块可以有<span class="hljs-number">0</span>或者多个，finally可以有<span class="hljs-number">0</span>或者<span class="hljs-number">1</span>个。<br><span class="hljs-regexp">//</span>如果没有catch块，必须有finally块。<br><span class="hljs-regexp">//</span>没有finally块，必须有catch块，catch块和finally块可以同时存在。<br><span class="hljs-regexp">//</span>在检测用户输入是否符合要求的场合，可以使用<span class="hljs-keyword">while</span>循环+try catch的组合。<br><span class="hljs-regexp">//</span>此时在try的代码块的最后加入<span class="hljs-keyword">break</span>直接终止跳出循环，运行到<span class="hljs-keyword">break</span>说明try内的代码没有报错。<br><span class="hljs-regexp">//</span>如果运行不到<span class="hljs-keyword">break</span>说明报错了，此时执行catch语句进行处理再回到try代码块循环。<br></code></pre></td></tr></table></figure><h3 id="011-怎么定义一个类-x2F-012-创建对象和对象的使用"><a href="#011-怎么定义一个类-x2F-012-创建对象和对象的使用" class="headerlink" title="011-怎么定义一个类 &#x2F; 012-创建对象和对象的使用"></a>011-怎么定义一个类 &#x2F; 012-创建对象和对象的使用</h3><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a><strong>类的定义</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Customer <span class="hljs-comment">//class+类名：定义一个类。</span><br>&#123;<br>public <span class="hljs-built_in">string</span> name;<br>public <span class="hljs-built_in">string</span> address;<br>public <span class="hljs-built_in">int</span> age;<br>public <span class="hljs-built_in">string</span> buyTime; <span class="hljs-comment">//添加变量，类似于定义一个结构体，权限默认public。</span><br>public void <span class="hljs-constructor">Show()</span> <span class="hljs-comment">//声明一个打印顾客信息的函数。</span><br>&#123;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;名字:&quot;</span>+<span class="hljs-params">name</span>)</span>;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;年龄:&quot;</span>+<span class="hljs-params">age</span>)</span>;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;地址:&quot;</span>+<span class="hljs-params">address</span>)</span>;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;购买时间:&quot;</span>+<span class="hljs-params">buyTime</span>)</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a><strong>对象的创建与使用</strong></h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">ClassName myClass = <span class="hljs-keyword">new</span> <span class="hljs-type">ClassName</span>();<br>Customer c1 =<span class="hljs-keyword">new</span> <span class="hljs-type">Customer</span>(); <span class="hljs-comment">//对象也是一种变量，声明一个对象并初始化。</span><br>c1.name = ’siki‘； <span class="hljs-comment">//给c1对象里面的变量赋值。</span><br>c1.show(); <span class="hljs-comment">//调用c1对象中的函数。</span><br></code></pre></td></tr></table></figure><h3 id="013-车辆类和向量类的定义和使用-x2F-014-public和private访问权限控制"><a href="#013-车辆类和向量类的定义和使用-x2F-014-public和private访问权限控制" class="headerlink" title="013-车辆类和向量类的定义和使用 &#x2F; 014-public和private访问权限控制"></a>013-车辆类和向量类的定义和使用 &#x2F; 014-public和private访问权限控制</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">访问修饰符：<span class="hljs-keyword">public</span> /<span class="hljs-keyword">private</span><br>通过<span class="hljs-keyword">private</span>修饰定义的变量仅能在类当中去声明和访问。<br><span class="hljs-comment">//习惯上所有数据的声明都是用private。</span><br><span class="hljs-comment">//使private可以在外界访问的方法是在类中构造一个赋值作用的public函数。</span><br><span class="hljs-comment">//prvate的优势就是可以通过get获取/set设置类的方法对数据进行校验判断。</span><br></code></pre></td></tr></table></figure><h3 id="015-什么是构造函数"><a href="#015-什么是构造函数" class="headerlink" title="015-什么是构造函数"></a>015-什么是构造函数</h3><h4 id="构造函数的语法"><a href="#构造函数的语法" class="headerlink" title="构造函数的语法"></a><strong>构造函数的语法</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">构造对象时候，对象的初始化过程是⾃动完成的。<br>但是在初始化对象的过程中有的时候需要做⼀些额外的⼯作。<br>例如需要初始化对象存储的数据，构造函数就是⽤于初始化数据的函数。<br>声明基本的构造函数的语法就是声明⼀个和所在类同名的⽅法，但是该⽅法没有返回类型。<br>public class MyClass<br>&#123;<br>public MyClass() <span class="hljs-regexp">//</span>没有返回值，public后直接接一个和类myclass名称相同的函数，括号内是函数的参数。<br>&#123;<br>这个构造函数的函数体 <span class="hljs-regexp">//</span>一般是初始化时直接给构造的对象赋值，初始化时直接调用函数完成赋值。<br>&#125;<br>&#125;<br><span class="hljs-regexp">//</span>构造函数可以存在多个（需要参数不同），存在多个构造函数时根据参数的类型进行重载。<br><span class="hljs-regexp">//</span>构造函数在构造方法时默认一定会执行一次。<br><span class="hljs-regexp">//</span>创建类时可以不写构造函数，此时系统会执行默认构造函数（无参无效果）。<br><span class="hljs-regexp">//</span>如果声明了一个有参的构造函数，声明时就不能不加参数。<br><span class="hljs-regexp">//</span>构造函数赋值时可以用this.字段来表示当前对象避免参数和字段重名的问题。<br></code></pre></td></tr></table></figure><h3 id="017-属性-x2F-018-属性和匿名类型"><a href="#017-属性-x2F-018-属性和匿名类型" class="headerlink" title="017-属性 &#x2F; 018-属性和匿名类型"></a>017-属性 &#x2F; 018-属性和匿名类型</h3><h4 id="通过属性完成对象的赋值和调用"><a href="#通过属性完成对象的赋值和调用" class="headerlink" title="通过属性完成对象的赋值和调用"></a><strong>通过属性完成对象的赋值和调用</strong></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> MyIntProp <br><span class="hljs-comment">//类似于函数的设置方式，MyIntProp是函数的名字，可以自由取名，但一般是字段首字母大写。</span><br>&#123;<br>get <span class="hljs-comment">//代表获取对象字段的具体值。</span><br>&#123;<br>/get code <span class="hljs-comment">//例如return age。</span><br>&#125;<br>set<br>&#123;<br>set code <span class="hljs-comment">//例如 age = value，此处的value是固定的。</span><br>&#125;<br>&#125;<br>xiaoming.age = <span class="hljs-number">14</span>; <span class="hljs-comment">//使用时直接通过.name这样的属性方式进行赋值，不调用具体函数。</span><br>console.<span class="hljs-built_in">writeline</span>(xiaoming.age) <span class="hljs-comment">//直接获取并输出赋值后的数据信息。</span><br><span class="hljs-comment">//相当于使用同一个属性直接完成了字段的赋值与调用，是两种函数组合的简写形式。</span><br><span class="hljs-comment">//set code部分同样是可以加入if语句来对赋值进行检验处理。</span><br><span class="hljs-comment">//get和set部分同样可以在前面加入private来限制数据的访问权限。</span><br><span class="hljs-comment">//属性可以仅提供⼀个set块或者get块，未必两个都要有。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> Age&#123;get;set;&#125; <br><span class="hljs-comment">//在类中使用该代码，系统会自动创建public int age的代码，之后的get/set可以直接设置数据的访问权限。</span><br></code></pre></td></tr></table></figure><h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a><strong>匿名类型</strong></h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">创建变量（对象的时候），必须指定类型，但其实也可以不去指定类型，而是使⽤<span class="hljs-built_in">var</span>声明⼀个匿名类型。<br>使⽤<span class="hljs-built_in">var</span>声明的匿名类型，当初始化的时候，这个变量的类型就被确定下来，并且以后不可以修改。<br><span class="hljs-built_in">var</span> <span class="hljs-built_in">var1</span> = <span class="hljs-number">34</span>; //因为初始化赋值是<span class="hljs-number">34</span>，<span class="hljs-built_in">var1</span>会被系统自动设置为int类型，且无法再做类型的修改。<br></code></pre></td></tr></table></figure><h3 id="020-值类型和引用类型-x2F-023-对象引用的改变"><a href="#020-值类型和引用类型-x2F-023-对象引用的改变" class="headerlink" title="020-值类型和引用类型 &#x2F; 023-对象引用的改变"></a>020-值类型和引用类型 &#x2F; 023-对象引用的改变</h3><h4 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a><strong>值类型和引用类型</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">类型被分为两种：<br>值类型(整数，<span class="hljs-built_in">bool</span>，<span class="hljs-keyword">struct</span>，<span class="hljs-built_in">char</span>，⼩数)<br>引⽤类型（<span class="hljs-built_in">string</span> 数组 ⾃定义的类，内置的类）<br>值类型只需要⼀段单独的内存，⽤于存储实际的数据（单独定义的时候放在栈中）。<br>引⽤类型需要两段内存：第⼀段存储实际的数据，它总是位于堆中；第⼆段是⼀个引⽤，指向数据在堆中的存放位置。<br>注意使⽤引⽤类型赋值时，其实是赋值的引⽤类型的引⽤。<br>因此在两个变量均指向同一个引用时，修改其中一个引用对应的具体值，另一个变量的值也会发生同样的变化。<br></code></pre></td></tr></table></figure><h3 id="024-什么是继承-x2F-025-继承的代码演示"><a href="#024-什么是继承-x2F-025-继承的代码演示" class="headerlink" title="024-什么是继承 &#x2F; 025-继承的代码演示"></a>024-什么是继承 &#x2F; 025-继承的代码演示</h3><h4 id="类的继承代码"><a href="#类的继承代码" class="headerlink" title="类的继承代码"></a><strong>类的继承代码</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">class MyDerivedClass : MyBaseclass <span class="hljs-regexp">//</span>创建类时，在类的名字后面加上一个冒号并接上需要继承的父类。<br>&#123;<br>functions and data members here <br><span class="hljs-regexp">//</span>此时DerivedClass已经继承了父类的所有内容，代码块中可以加入自己独有的代码。<br>&#125;<br><span class="hljs-regexp">//</span>父类使用private权限修饰变量时，子类没办法直接调用，因此需要把父类的private修改成protected。<br><span class="hljs-regexp">//</span>protected意义为可以在其他类里面调用，但不能在主程序里调用。<br></code></pre></td></tr></table></figure><h3 id="027-this和base关键字"><a href="#027-this和base关键字" class="headerlink" title="027-this和base关键字"></a>027-this和base关键字</h3><h3 id="this和base"><a href="#this和base" class="headerlink" title="this和base"></a><strong>this和base</strong></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>和base关键字的作用：<span class="hljs-number">1.</span>代码编辑器提供变量的提示；<span class="hljs-number">2.</span>可以用于区分局部变量和字段。<br>主要是可以区分需要调用的函数或者变量是父类还是子类里的（会出现重名的情况不好区分）。<br>在需要对父类的某个函数进行重写时（两个函数名称相同），调用时就可以用<span class="hljs-keyword">this</span>来明确调用的是子类的代码。<br></code></pre></td></tr></table></figure><h3 id="028-关于虚方法Virtual"><a href="#028-关于虚方法Virtual" class="headerlink" title="028-关于虚方法Virtual"></a>028-关于虚方法Virtual</h3><h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a><strong>虚方法</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBaseClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> <span class="hljs-title">VirtualMethod</span>() <span class="hljs-comment">//在访问修饰符和返回值之前加入virtual后，方法成为虚方法。</span></span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Method is called in base class&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass</span>:<span class="hljs-title">MyBaseClass</span> <span class="hljs-comment">//构造一个子类对象继承自mybaseclass。</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">VirtualMethod</span>() <span class="hljs-comment">//声明一个与父类中重名的函数，virtual改为override。</span></span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Method is called in derivedclass.&quot;</span>; <span class="hljs-comment">//函数中的代码与父类中不同，相当于重写了该函数。</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//通过virtual和override重写方法后，子类对象在调用该方法后默认执行重写后的函数语句。</span><br></code></pre></td></tr></table></figure><h3 id="029-隐藏方法"><a href="#029-隐藏方法" class="headerlink" title="029-隐藏方法"></a>029-隐藏方法</h3><h4 id="隐藏方法"><a href="#隐藏方法" class="headerlink" title="隐藏方法"></a><strong>隐藏方法</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBaseClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MyMethod</span>() <span class="hljs-comment">//使用隐藏方法时，父类不作任何改动。</span></span><br>&#123;<br>&#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass</span> :<span class="hljs-title">MyBaseClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>() <span class="hljs-comment">//子类在构造同名的方法时，在访问修饰符和返回类型之间加入new。</span></span><br>&#123;<br>&#125;<br>&#125;<br><span class="hljs-comment">//加入new意味着方法被重新构造，此时子类调用该方法后，执行的也是修改（new）后的代码。</span><br></code></pre></td></tr></table></figure><h3 id="030-抽象类和密封类"><a href="#030-抽象类和密封类" class="headerlink" title="030-抽象类和密封类"></a>030-抽象类和密封类</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a><strong>抽象类</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Building</span> <span class="hljs-comment">//在创建类的最前面添加abstract表示构造抽象类。</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">decimal</span> <span class="hljs-title">CalculateHeatingCost</span>()</span>; <span class="hljs-comment">//抽象类下可以构造抽象方法，语法一样。</span><br>&#125;<br><span class="hljs-comment">//抽象方法就是没有具体函数体的方法。</span><br></code></pre></td></tr></table></figure><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a><strong>密封类</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">sealed FinalClass <span class="hljs-regexp">//</span>sealed表示设置为密封类，同理还有密封方法。<br>&#123;<br><span class="hljs-regexp">//</span> etc<br>&#125;<br>对于类，密封表示不能继承该类；对于⽅法，密封表示不能重写该⽅法。<br><span class="hljs-regexp">//</span>密封的作用主要是代码中防止类和方法被多次重写而变得混乱。<br></code></pre></td></tr></table></figure><h3 id="031-子类的构造函数"><a href="#031-子类的构造函数" class="headerlink" title="031-子类的构造函数"></a>031-子类的构造函数</h3><h4 id="子类的构造函数"><a href="#子类的构造函数" class="headerlink" title="子类的构造函数"></a><strong>子类的构造函数</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>():<span class="hljs-title">base</span>() <span class="hljs-comment">//在构造函数后面加冒号和父类，调用父类的默认构造函数。</span></span><br>&#123;<br><span class="hljs-comment">//do something</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//这里:base()的代码不写也会默认先调用父类的构造函数。</span><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MyDerivedClass</span><br>&#123;<br><span class="hljs-keyword">public</span> MyDerivedClass(<span class="hljs-built_in">string</span> name):base(name) <span class="hljs-comment">//调用有具体参数的父类构造函数。</span><br>&#123;<br><span class="hljs-comment">//do something</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//相当于先调用了父类的有参构造函数。</span><br></code></pre></td></tr></table></figure><h3 id="032-修饰符和怎么访问别的项目下的类"><a href="#032-修饰符和怎么访问别的项目下的类" class="headerlink" title="032-修饰符和怎么访问别的项目下的类"></a>032-修饰符和怎么访问别的项目下的类</h3><h4 id="访问其他项目下的类"><a href="#访问其他项目下的类" class="headerlink" title="访问其他项目下的类"></a><strong>访问其他项目下的类</strong></h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">三个步骤：<br><span class="hljs-number">1.</span>在需要引用其他项目的项目下添加其他项目的引用。<br><span class="hljs-number">2.</span>在项目最开始的代码引入需要引用的项目的命名空间。<br><span class="hljs-number">3.</span>把需要引用的类的访问权限设置为<span class="hljs-keyword">public</span>。<br></code></pre></td></tr></table></figure><h3 id="033-其他修饰符和readonly"><a href="#033-其他修饰符和readonly" class="headerlink" title="033-其他修饰符和readonly"></a>033-其他修饰符和readonly</h3><h4 id="只读修饰符readonly"><a href="#只读修饰符readonly" class="headerlink" title="只读修饰符readonly"></a><strong>只读修饰符readonly</strong></h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">只读修饰符<span class="hljs-keyword">readonly</span>：声明只读字段。<br>只读字段可以在声明或构造函数中初始化，每个类或结构的实例都有⼀个独⽴的副本。<br>可以与<span class="hljs-keyword">static</span>⼀起使⽤，声明静态只读字段。<br>静态只读字段可以在声明或静态构造函数中初始化，静态常量字段只有⼀个副本。<br>简单来说就是只能在声明和构造函数中赋值，不能后期再对只读的字段进行值的修改。<br></code></pre></td></tr></table></figure><h3 id="034-static静态的"><a href="#034-static静态的" class="headerlink" title="034-static静态的"></a>034-static静态的</h3><h4 id="静态修饰符"><a href="#静态修饰符" class="headerlink" title="静态修饰符"></a><strong>静态修饰符</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">使⽤<span class="hljs-keyword">static</span>修饰的类为静态类，静态类所有成员都必须是静态的，不能与<span class="hljs-keyword">abstract</span>、<span class="hljs-keyword">sealed</span>⼀起使⽤。<br><span class="hljs-keyword">static</span>可以修饰⽅法、字段、属性或事件，始终通过类名⽽不是实例名称访问静态成员，静态字段只有⼀个副本。<br>静态类不能被实例化。<br>简单来说就是被<span class="hljs-keyword">static</span>修饰的方法/属性只能通过类访问而不能通过实例访问。<br>例如某个类下边有若干个静态属性和通常属性，在实例化该类时，创建的类不能赋值静态属性。<br></code></pre></td></tr></table></figure><h3 id="035-什么是接口-x2F-036-接口的继承"><a href="#035-什么是接口-x2F-036-接口的继承" class="headerlink" title="035-什么是接口 &#x2F; 036-接口的继承"></a>035-什么是接口 &#x2F; 036-接口的继承</h3><h4 id="接口的声明"><a href="#接口的声明" class="headerlink" title="接口的声明"></a><strong>接口的声明</strong></h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">IFlyHandler</span> //一般接口的名字使用<span class="hljs-symbol">I</span>字母开头，表示是接口而不是类。<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> Fly(); <span class="hljs-comment">//接口里面会有一个空的方法。</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">Type1Enemy:<span class="hljs-symbol">IFlyHandler</span></span> //调用接口，类似于继承的代码。<br>&#123;<br>&#125;<br>定义⼀个接⼝在语法上跟定义⼀个抽象类完全相同，但不允许提供接⼝中任何成员的实现⽅式.<br>⼀般情况下，接⼝只能包含⽅法，属性，索引器和事件的声明。<br>接⼝不能有构造函数，也不能有字段，接⼝也不允许运算符重载。<br>接⼝定义中不允许声明成员的修饰符，接⼝成员都是公有的。<br></code></pre></td></tr></table></figure><h4 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a><strong>接口的继承</strong></h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">A</span><br>&#123;<br><span class="hljs-built_in">void</span> Method1();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">B</span>:<span class="hljs-symbol">A</span> //相当于拥有了<span class="hljs-symbol">interfaceA</span>接口的方法，所以需要实现<span class="hljs-symbol">method1</span>和<span class="hljs-symbol">method2</span>的方法。<br>&#123;<br><span class="hljs-built_in">void</span> Method2();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="043-什么是列表和列表的创建添加遍历访问"><a href="#043-什么是列表和列表的创建添加遍历访问" class="headerlink" title="043-什么是列表和列表的创建添加遍历访问"></a>043-什么是列表和列表的创建添加遍历访问</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a><strong>列表</strong></h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">当有很多类型⼀样的数据的时候，⼀般使⽤数组来进⾏管理。<br>但是这样有个缺点就是数组的⼤⼩是固定的。<br>如果很多类型⼀样的数据⽐如游戏得分，可以用集合类来进⾏管理，⽐如列表<span class="hljs-built_in">List</span>。<br>使⽤列表<span class="hljs-built_in">List</span>可以很⽅便的添加数据，删除数据，以及其他对数据的操作。<br></code></pre></td></tr></table></figure><h4 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a><strong>列表的创建</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">List&lt;<span class="hljs-built_in">int</span>&gt; scoreList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;(); <span class="hljs-comment">//创建一个叫scorelist的数据集合，需要指定集合的数据类型。</span><br><span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;()&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125; <span class="hljs-comment">//给list添加三个数据。</span><br><span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;()&#123;<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>&#125;<br><span class="hljs-keyword">var</span> scoreList = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br></code></pre></td></tr></table></figure><h3 id="列表数据的添加"><a href="#列表数据的添加" class="headerlink" title="列表数据的添加"></a><strong>列表数据的添加</strong></h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">scoreList</span>.Add(<span class="hljs-number">12</span>); //使用add方法添加<span class="hljs-number">12</span>这个数据。<br><span class="hljs-attribute">scoreList</span>.Add(<span class="hljs-number">45</span>);<br></code></pre></td></tr></table></figure><h3 id="列表数据的访问"><a href="#列表数据的访问" class="headerlink" title="列表数据的访问"></a><strong>列表数据的访问</strong></h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.writeline(scorelist[<span class="hljs-number">3</span>]); <span class="hljs-comment">//和数组一样通过索引进行访问。</span><br>socrelist.<span class="hljs-built_in">count</span>; <br><span class="hljs-comment">//count是list的一个属性，表示list中的数据个数，可以用count结合for循环对list进行遍历。</span><br></code></pre></td></tr></table></figure><h3 id="044-关于列表的内部数据管理"><a href="#044-关于列表的内部数据管理" class="headerlink" title="044-关于列表的内部数据管理"></a>044-关于列表的内部数据管理</h3><h4 id="列表的容量"><a href="#列表的容量" class="headerlink" title="列表的容量"></a><strong>列表的容量</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">List.Capacity; <span class="hljs-regexp">//</span>和count一样是list的一个属性，表示list当前可以存放的数据个数即容量。<br><span class="hljs-regexp">//</span>注意capacity和count的区别，count是列表内的数据个数，而capacity是存放数据的个数上限。<br></code></pre></td></tr></table></figure><h3 id="045-列表的一些常见操作"><a href="#045-列表的一些常见操作" class="headerlink" title="045-列表的一些常见操作"></a>045-列表的一些常见操作</h3><h4 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a><strong>列表的遍历</strong></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-keyword">for</span>循环，遍历所有的索引，通过索引访问列表中的元素。<br><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i=<span class="hljs-number">0</span>;i&lt;list.Count;i++)</span></span><br>&#123;<br><span class="hljs-comment">//循环体list[i]</span><br>&#125;<br>foreach遍历<br><span class="hljs-function"><span class="hljs-title">foreach</span><span class="hljs-params">(int temp in list)</span></span>  <span class="hljs-comment">//依次取得list中的每⼀个元素赋值给temp，并执⾏循环体。</span><br>&#123;<br><span class="hljs-comment">//循环体 temp</span><br>&#125;<br><span class="hljs-comment">//和数组的遍历没有区别。</span><br></code></pre></td></tr></table></figure><h4 id="列表的常见操作"><a href="#列表的常见操作" class="headerlink" title="列表的常见操作"></a><strong>列表的常见操作</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>.list.capacity; <span class="hljs-regexp">//</span>获取list的容量。<br><span class="hljs-number">2</span>.list.add(); <span class="hljs-regexp">//</span>给list添加数据。<br><span class="hljs-number">3</span>.list[index]; <span class="hljs-regexp">//</span>通过索引给访问list的具体数据。<br><span class="hljs-number">4</span>.list.insert([index],数据); <span class="hljs-regexp">//</span>在指定索引前面插入一个数据。<br><span class="hljs-regexp">//</span>注意索引还是从<span class="hljs-number">0</span>开始的。<br><span class="hljs-number">5</span>.list.remove(数据); <span class="hljs-regexp">//</span>删除list中第一个与输入数据相同的数据。<br><span class="hljs-number">6</span>.list.removeat([index]); <span class="hljs-regexp">//</span>删除list中相应索引的数据。<br><span class="hljs-number">7</span>.list.indexof(数据); <span class="hljs-regexp">//</span>查询list中第一个对应数据所在的索引，如果没有匹配数据会返回-<span class="hljs-number">1</span>。<br><span class="hljs-number">8</span>.list.LastIndexOf(数据); <span class="hljs-regexp">//</span>从后往前查询第一个对应数据所在的索引。<br><span class="hljs-number">9</span>.list.sort(); <span class="hljs-regexp">//</span>对列表中元素从小到大进行排序。<br></code></pre></td></tr></table></figure><h3 id="046-泛型-x2F-泛型类"><a href="#046-泛型-x2F-泛型类" class="headerlink" title="046-泛型&#x2F;泛型类"></a>046-泛型&#x2F;泛型类</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a><strong>泛型类</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp">定义⼀个泛型类就是指的是，定义⼀个类，这个类中某些字段的类型是不确定的。<br>这些类型可以在类构造的时候确定下来。<br>举例:创建⼀个类处理<span class="hljs-built_in">int</span>类型和<span class="hljs-built_in">double</span>类型的相加。<br><span class="hljs-keyword">class</span> <span class="hljs-title">ClassA</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-comment">//习惯性后边加个中括号&lt;T&gt;</span><br>&#123;<br><span class="hljs-keyword">private</span> T a; <br><span class="hljs-keyword">private</span> T b; <span class="hljs-comment">//a和b的类型都是T类型了。</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassA</span>(<span class="hljs-params">T a,T b</span>)</span><br>&#123;<br><span class="hljs-keyword">this</span>.a = a ;<br><span class="hljs-keyword">this</span>.b = b;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetSum</span>()</span><br>&#123;<br><span class="hljs-built_in">dynamic</span> num1 = a;<br><span class="hljs-built_in">dynamic</span> num2 = b; <span class="hljs-comment">//声明两个dynamic类型的a和b然后相加。</span><br><span class="hljs-built_in">dynamic</span> result = num1 + num2;<br><span class="hljs-keyword">return</span> (T)result; <span class="hljs-comment">//将dynamic类型的相加结果强制转换为T类型。</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//在声明类时把T直接替换为需要的类型，再调用getsum()函数即可实现自己指定数据类型的函数效果。</span><br></code></pre></td></tr></table></figure><h3 id="048-泛型方法"><a href="#048-泛型方法" class="headerlink" title="048-泛型方法"></a>048-泛型方法</h3><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a><strong>泛型方法</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title">GetSum</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">T a,T b</span>)</span><br>&#123;<br><span class="hljs-built_in">dynamic</span> num1 = a;<br><span class="hljs-built_in">dynamic</span> num2 = b;<br><span class="hljs-built_in">dynamic</span> result = num1 + numb; <span class="hljs-comment">//和泛型类的定义基本一致。</span><br><span class="hljs-keyword">return</span> (T) result;<br>&#125;<br>GetSum&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">23</span>,<span class="hljs-number">12</span>);<br>GetSum&lt;<span class="hljs-built_in">double</span>&gt;(<span class="hljs-number">23.2</span>,<span class="hljs-number">12</span>); <span class="hljs-comment">//调用时指定好T位置的类型然后正常使用方法即可。</span><br></code></pre></td></tr></table></figure><h3 id="049-创建自己的MyList列表-x2F-050-通过索引器访问列表里面的数据"><a href="#049-创建自己的MyList列表-x2F-050-通过索引器访问列表里面的数据" class="headerlink" title="049-创建自己的MyList列表 &#x2F; 050-通过索引器访问列表里面的数据"></a>049-创建自己的MyList列表 &#x2F; 050-通过索引器访问列表里面的数据</h3><h4 id="Mylist"><a href="#Mylist" class="headerlink" title="Mylist"></a><strong>Mylist</strong></h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mylist</span>&lt;T&gt; <span class="hljs-comment">//声明一个mylist类。</span><br>&#123;<br><span class="hljs-keyword">private</span> T[] data = <span class="hljs-keyword">new</span> T[<span class="hljs-number">0</span>]; <span class="hljs-comment">//初始化一个T类型名称为data的数组。</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化时连带着声明数组目前的元素个数，默认为0。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> capacity <span class="hljs-comment">//声明一个名称为capacity的方法。</span><br>&#123;<br>get<br>&#123;<br><span class="hljs-keyword">return</span> data.length; <span class="hljs-comment">//返回data数组的长度。</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span> <span class="hljs-comment">//声明一个名称为count的方法。</span><br>&#123;<br>get<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> add(T item)<br>&#123;<br><span class="hljs-keyword">if</span> (data.length == <span class="hljs-number">0</span>) <span class="hljs-comment">//判断data数组的长度是否为0。</span><br>&#123;<br>data =<span class="hljs-keyword">new</span> T[<span class="hljs-number">4</span>]; <span class="hljs-comment">//如果长度为0，重设一个长度为4的数组。</span><br>&#125;<br><span class="hljs-keyword">if</span> (data.length == <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断当前数组是不是已经满了。</span><br>&#123;<br>T[] temp = <span class="hljs-keyword">new</span> T[<span class="hljs-keyword">count</span> * <span class="hljs-number">2</span>]; <span class="hljs-comment">//重新创建一个长度为count两倍的临时数组。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i&lt;data.length;i++)<br>&#123;<br>temp [i] = data[i];<br>&#125;<br>data = temp; <span class="hljs-comment">//将数据迁移完毕的temp数组再重新赋值给data，完成数据迁移。</span><br>&#125;<br>data[<span class="hljs-keyword">count</span>] = item; <span class="hljs-comment">//将需要添加的元素赋值给数值等同于count的索引，表明在最后添加了一组数据。</span><br><span class="hljs-keyword">count</span>++; <span class="hljs-comment">//添加完毕后，count也需要自增一次。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> T <span class="hljs-keyword">this</span> [<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>] <span class="hljs-comment">//创建索引器。</span><br>get<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断索引是否越界了。</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> system.argumentoutofrangeexception(”参数超出范围了“); <span class="hljs-comment">//抛异常。</span><br>&#125;<br><span class="hljs-keyword">return</span> data[<span class="hljs-keyword">index</span>];<br>&#125;<br>set<br>&#123;<br>data[<span class="hljs-keyword">index</span>] = value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> insert(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>, T item)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断索引是否越界了。</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> system.argumentoutofrangeexception(”参数超出范围了“); <span class="hljs-comment">//抛异常。</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i =<span class="hljs-keyword">count</span><span class="hljs-number">-1</span>;i&gt;<span class="hljs-keyword">index</span><span class="hljs-number">-1</span>;i--)<br>&#123;<br><span class="hljs-built_in">date</span> [i+<span class="hljs-number">1</span>] = <span class="hljs-built_in">date</span>[i] <span class="hljs-comment">//index后面的数据每个向后移一位。</span><br>&#125;<br><span class="hljs-built_in">date</span> [<span class="hljs-keyword">index</span>] = item;  <span class="hljs-comment">//在index索引位插入item数据。</span><br><span class="hljs-keyword">count</span>++; <span class="hljs-comment">//count自增。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> removeat(<span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= <span class="hljs-keyword">count</span>) <span class="hljs-comment">//判断索引是否越界了。</span><br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> system.argumentoutofrangeexception(”参数超出范围了“); <span class="hljs-comment">//抛异常。</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i =<span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>;i&lt;<span class="hljs-keyword">count</span>;i++)<br>&#123;<br><span class="hljs-built_in">date</span> [i<span class="hljs-number">-1</span>] = data[i]; <span class="hljs-comment">//数据前移。</span><br>&#125;<br><span class="hljs-keyword">count</span>--; <span class="hljs-comment">//count自减。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> indexof(T item)<br>&#123;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">-1</span>; <span class="hljs-comment">//默认值设置为-1。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-keyword">count</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span> (item.equals(data[i])) <span class="hljs-comment">//equals方法判断两个值是否相等。</span><br>&#123;<br><span class="hljs-keyword">index</span> = i; <span class="hljs-comment">//将index赋值为找到的索引。</span><br><span class="hljs-keyword">break</span>; <span class="hljs-comment">//中断循环</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">index</span>; <span class="hljs-comment">//返回index。</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> sort()<br>&#123;<br>array.sort(data,<span class="hljs-number">0</span>,<span class="hljs-keyword">count</span>) <span class="hljs-comment">//调用array.sort方法将data数组的第0个索引到第count个索引进行排序。</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="052-Equals方法-x2F-课程完结"><a href="#052-Equals方法-x2F-课程完结" class="headerlink" title="052-Equals方法 &#x2F; 课程完结"></a>052-Equals方法 &#x2F; 课程完结</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">a.equal<span class="hljs-params">(b)</span>; <span class="hljs-string">//</span>判断a和b是否相等，如果是返回<span class="hljs-literal">true</span>，如果不是返回<span class="hljs-literal">false</span>。<br><span class="hljs-string">//</span>对于对象（引用类型），比较的是内存地址，因此即使看起来相等还是会返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#学习笔记-编程基础</title>
    <link href="/2022/12/12/%E7%AC%94%E8%AE%B0/C-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/12/12/%E7%AC%94%E8%AE%B0/C-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h3 id="008-程序的基本语法-x2F-009-基本语法总结-x2F-010-输出语句练习题"><a href="#008-程序的基本语法-x2F-009-基本语法总结-x2F-010-输出语句练习题" class="headerlink" title="008-程序的基本语法 &#x2F; 009-基本语法总结 &#x2F; 010-输出语句练习题"></a>008-程序的基本语法 &#x2F; 009-基本语法总结 &#x2F; 010-输出语句练习题</h3><h4 id="语法：控制台输出文本"><a href="#语法：控制台输出文本" class="headerlink" title="语法：控制台输出文本"></a><strong>语法：控制台输出文本</strong></h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;Hello World&quot;</span>);  <span class="hljs-comment">//输出括号内的文本，输出完毕后默认换行。</span><br><span class="hljs-built_in">Console</span>.Write(<span class="hljs-string">&quot;Hello &quot;</span>); <span class="hljs-comment">//输出括号内的文本，输出完毕后默认不换行。</span><br><span class="hljs-built_in">Console</span>.Write(<span class="hljs-string">&quot;World&quot;</span>); <span class="hljs-comment">//与上一条代码组合后会输出一行完整的Hello World。</span><br></code></pre></td></tr></table></figure><h4 id="语法：转义符"><a href="#语法：转义符" class="headerlink" title="语法：转义符"></a><strong>语法：转义符</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">Console.WriteLine(<span class="hljs-string">&quot;H\tello \nWorld&quot;</span>);  <br>Console.WriteLine(<span class="hljs-string">&quot;\\\&quot;&quot;</span>) <span class="hljs-regexp">//</span>会生成\”的字符。<br><span class="hljs-regexp">//</span>转义符\与n连用后代表换行，\与t连用后代表tab制表符（一般是四个空格）。<br><span class="hljs-regexp">//</span>转义符\与\连用后代表一个非转义作用的\字符。<br><span class="hljs-regexp">//</span>转义符与“连用后代表一个引号文本字符，不会被识别为字符串的标识。<br></code></pre></td></tr></table></figure><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">注释代码：<span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-built_in">K</span> → <span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-built_in">C</span><br>解除注释：<span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-built_in">K</span> → <span class="hljs-variable">Ctrl</span><span class="hljs-operator">+</span><span class="hljs-variable">U</span><br>运行代码：<span class="hljs-variable">F5</span><br></code></pre></td></tr></table></figure><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a><strong>特别注意</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>多行注释时不能像 <span class="hljs-regexp">/ *我是注释 * /</span>这样，不能在*和/符号之间加空格。<br></code></pre></td></tr></table></figure><h3 id="013-计算机基本知识-x2F-014-计算机中的数据"><a href="#013-计算机基本知识-x2F-014-计算机中的数据" class="headerlink" title="013-计算机基本知识 &#x2F; 014-计算机中的数据"></a>013-计算机基本知识 &#x2F; 014-计算机中的数据</h3><h4 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a><strong>快捷键</strong></h4><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos">Home/End键：快速定位至当前代码的最前端和最后端。<br><span class="hljs-built_in">Shift</span>键：光标放在起始代码行，按住<span class="hljs-built_in">Shift</span>，再移动光标至结束行，可以快速选中代码。<br>Ctrl+A：全选所有代码<br>Ctrl+S：快速保存<br>Ctrl+Z：撤销上一步操作<br></code></pre></td></tr></table></figure><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><strong>数据类型</strong></h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">整数：<span class="hljs-number">1</span><br>浮点数：<span class="hljs-number">1.1</span><br>字符：&#x27;A&#x27;（注意是单引号）<br>字符串：<span class="hljs-string">&quot;AAAA&quot;</span><br></code></pre></td></tr></table></figure><h3 id="015-变量的声明和赋值-x2F-016-判断结果-练习-x2F-017-练习"><a href="#015-变量的声明和赋值-x2F-016-判断结果-练习-x2F-017-练习" class="headerlink" title="015-变量的声明和赋值 &#x2F; 016-判断结果-练习 &#x2F; 017-练习"></a>015-变量的声明和赋值 &#x2F; 016-判断结果-练习 &#x2F; 017-练习</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">int age; <span class="hljs-regexp">//</span>创建一个名为age的容器，容器的数据类型是int。<br>age = <span class="hljs-number">10</span>; <span class="hljs-regexp">//</span>把<span class="hljs-number">10</span>放在age这个容器里面，即赋值。<br>double age2; <span class="hljs-regexp">//</span>double存放小数，注意变量不能重名。<br>char age3 = <span class="hljs-string">&#x27;7&#x27;</span>; <span class="hljs-regexp">//</span>char存放单个字符，注意需要使用单引号。<br>string age4 = <span class="hljs-string">&quot;11岁&quot;</span>; <span class="hljs-regexp">//</span>可以把赋值和声明两个步骤合起来简写成一行。<br><span class="hljs-regexp">//</span>注意：变量名称由英文、数字和下划线组成，区分大小写，不能以数字开头。<br><span class="hljs-regexp">//</span>注意：必须先声明变量，再赋值，然后才能使用变量。<br></code></pre></td></tr></table></figure><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a><strong>其他注意事项</strong></h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-comment">; //被赋值的变量可以被多次赋值，每一次赋值会清空上一次的赋值。</span><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> b = <span class="hljs-number">1</span> , c = <span class="hljs-number">2</span>; <span class="hljs-comment">//声明多个相同数据类型的变量时，可以简写成一行代码一起进行赋值。</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a =<span class="hljs-number">1</span> , b = <span class="hljs-number">2</span>;<br>Console.<span class="hljs-constructor">Writeline(<span class="hljs-params">a</span>+<span class="hljs-string">&quot;+&quot;</span>+<span class="hljs-params">b</span>)</span> <span class="hljs-comment">//输出：1+2</span><br>Console.<span class="hljs-constructor">Writeline(<span class="hljs-string">&quot;a+b&quot;</span>+<span class="hljs-params">a</span>+<span class="hljs-params">b</span>)</span> <span class="hljs-comment">//输出：a+b12</span><br>Console.<span class="hljs-constructor">Writeline(<span class="hljs-string">&quot;a+b&quot;</span>+(<span class="hljs-params">a</span>+<span class="hljs-params">b</span>)</span>) <span class="hljs-comment">//输出：a+b3</span><br><span class="hljs-comment">//注意：涉及到字符串与数字的加法运算时，默认是把字符串和数字直接拼接在一起。</span><br><span class="hljs-comment">//注意：在运算过程中，优先运算最里层括号的算式。</span><br></code></pre></td></tr></table></figure><h3 id="018-字符类型和对应的整数-x2F-019-字符串的声明和简单拼接操作"><a href="#018-字符类型和对应的整数-x2F-019-字符串的声明和简单拼接操作" class="headerlink" title="018-字符类型和对应的整数 &#x2F; 019-字符串的声明和简单拼接操作"></a>018-字符类型和对应的整数 &#x2F; 019-字符串的声明和简单拼接操作</h3><h4 id="字符类型与整数的转换"><a href="#字符类型与整数的转换" class="headerlink" title="字符类型与整数的转换"></a><strong>字符类型与整数的转换</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">char</span> a = <span class="hljs-character">&#x27;a&#x27;</span>;<br><span class="hljs-built_in">int</span> b = a;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">a</span>)</span>; <span class="hljs-comment">//输出：a</span><br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//输出：97</span><br><span class="hljs-comment">//字符类型也代表一个整数，上述代码中，字符类型的a被再定义为整数类型后，输出变成97。</span><br><span class="hljs-comment">//字符与整数的转换规则详情可以见ASCII码表。</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a = <span class="hljs-number">97</span>;<br><span class="hljs-built_in">char</span> b = a; <span class="hljs-comment">//此处因为char类型比int类型要小，所以进行转换时会出现报错。</span><br><span class="hljs-built_in">char</span> b = (<span class="hljs-built_in">char</span>)a; <span class="hljs-comment">//遇到上述报错情况可以使用强制转换，语法时是在=号后面加上（类型）。</span><br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">a</span>)</span>; <span class="hljs-comment">//输出：97</span><br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//输出：a</span><br><span class="hljs-comment">//注意：最好是在明确可以转换的情况下再使用强制转换，在不能转换时使用强制转换会出现问题。</span><br></code></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">char</span> <span class="hljs-keyword">a</span> = <span class="hljs-string">&#x27;\n&#x27;</span>;<span class="hljs-comment"> //输出：</span><br><span class="hljs-keyword">char</span> b = <span class="hljs-string">&#x27;\\&#x27;</span>;<span class="hljs-comment"> //输出：\</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-string">&#x27;\&quot;&#x27;</span>;<span class="hljs-comment"> //输出：&quot;</span><span class="hljs-comment"></span><br><span class="hljs-comment">//注意：字符类型不一定是单引号内只有一个字符，转义符\并不算在一个字符内。</span><br></code></pre></td></tr></table></figure><h4 id="字符的使用"><a href="#字符的使用" class="headerlink" title="@字符的使用"></a><strong>@字符的使用</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Console.WriteLine(<span class="hljs-string">&quot;C:\\A\\B\\C&quot;</span>); <span class="hljs-regexp">//</span>输出： C:\A\B\C<br>Console.WriteLine(@<span class="hljs-string">&quot;C:\A\B\C&quot;</span>);  <span class="hljs-regexp">//</span>输出： C:\A\B\C<br><span class="hljs-regexp">//</span>当需要输出的字符串内存在多个\字符且不希望发挥转义作用时，可以在双引号前加@字符取消全部\的转义作用。<br></code></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">Console.WriteLine(@<span class="hljs-string">&quot;C:</span><br>\A<br>\B<br>\C<span class="hljs-string">&quot;);</span><br><span class="hljs-comment">//@字符的另一个作用就是可以直接在字符串的声明或直接输出时给字符串直接换行。</span><br><span class="hljs-comment">//使用@字符给字符串换行时，如果还需要使用正常的双引号“，可以用两个双引号“”来代替。</span><br></code></pre></td></tr></table></figure><h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a><strong>字符串的拼接</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Console.WriteLine(<span class="hljs-number">123</span>+“www”); <span class="hljs-regexp">//</span>输出：<span class="hljs-number">123</span>www<br><span class="hljs-regexp">//</span>两个字符串可以使用+符号来进行直接拼接，当数字类型和字符串类型使用+号连接时，一样进行拼接。<br></code></pre></td></tr></table></figure><h3 id="020-怎么得到用户输入"><a href="#020-怎么得到用户输入" class="headerlink" title="020-怎么得到用户输入"></a>020-怎么得到用户输入</h3><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a><strong>用户输入</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">string</span> str = Console.<span class="hljs-constructor">ReadLine()</span>; <br><span class="hljs-comment">//使用Console.ReadLine()实现用户输入，并传递给字符串str赋值。</span><br><span class="hljs-built_in">int</span> strint = Convert.<span class="hljs-constructor">ToInt32(<span class="hljs-params">str</span>)</span>; <br><span class="hljs-comment">//Console.ReadLine()的输入默认为字符串，使用Convert.ToInt32()将字符串转换为int类型的数字。</span><br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;int&quot;</span> + <span class="hljs-params">strint</span>)</span>; <span class="hljs-comment">//将int和用户输入的数字拼接成一个字符串输出。</span><br><span class="hljs-comment">//注意：使用Convert.ToInt32()必须由用户输入数字才能执行，不然会报错。</span><br></code></pre></td></tr></table></figure><h3 id="024-命名规范和命名规则"><a href="#024-命名规范和命名规则" class="headerlink" title="024-命名规范和命名规则"></a>024-命名规范和命名规则</h3><h4 id="两种命名规范"><a href="#两种命名规范" class="headerlink" title="两种命名规范"></a><strong>两种命名规范</strong></h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">驼峰命名法：⾸个单词的⾸字⺟⼩写，其余单词的⾸字⺟⼤写（enemyHp）<br><span class="hljs-keyword">Pascal</span>命名规范：每个单词的第⼀个字⺟都⼤写（EnemyHp），如果使⽤到英⽂单词的缩写，全部使⽤⼤写（HP）。<br>变量使⽤驼峰命名法，⽅法和类使⽤<span class="hljs-keyword">Pascal</span>命名规范。<br></code></pre></td></tr></table></figure><h3 id="025-字符串格式化输出"><a href="#025-字符串格式化输出" class="headerlink" title="025-字符串格式化输出"></a>025-字符串格式化输出</h3><h4 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a><strong>字符串格式化</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a = <span class="hljs-number">100</span>, b = <span class="hljs-number">200</span>;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">a</span> + <span class="hljs-string">&quot;+&quot;</span> + <span class="hljs-params">b</span> + <span class="hljs-string">&quot;=&quot;</span>+(<span class="hljs-params">a</span> + <span class="hljs-params">b</span>)</span>); <span class="hljs-comment">//用字符串拼接的方式处理比较繁琐。</span><br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-string">&quot;&#123;0&#125;+&#123;1&#125;=&#123;2&#125;&quot;</span>,<span class="hljs-params">a</span>,<span class="hljs-params">b</span>,<span class="hljs-params">a</span>+<span class="hljs-params">b</span>)</span>; <span class="hljs-comment">//可以使用&#123;0&#125;这种替代符放入字符串。</span><br><span class="hljs-comment">//替代符的编号从0开始，可以给出值不使用，但不可以使用了没有给出的值。</span><br></code></pre></td></tr></table></figure><h3 id="026-数学运算符-x2F-27-练习题和赋值运算符"><a href="#026-数学运算符-x2F-27-练习题和赋值运算符" class="headerlink" title="026-数学运算符 &#x2F; 27-练习题和赋值运算符"></a>026-数学运算符 &#x2F; 27-练习题和赋值运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a><strong>算数运算符</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">加法：+<br>减法：-<br>乘法：*<br>除法：/（两个整数相除会自动省略掉小数点，得到整数）<br><span class="hljs-regexp">//</span>注意：如果不想忽略小数点，可以在赋值中把变量类型设置为double，并且在算式中加入一个小数。<br>取模：%（获得两个整数相除得到的余数）<br></code></pre></td></tr></table></figure><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h4><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;<br>a += <span class="hljs-number">10</span>; <span class="hljs-comment">//结果：10</span><br>a -= <span class="hljs-number">5</span>; <span class="hljs-comment">//结果：5</span><br>a *= <span class="hljs-number">3</span>; <span class="hljs-comment">//结果：15</span><br>a /= <span class="hljs-number">6</span>; <span class="hljs-comment">//结果：2</span><br>a %= <span class="hljs-number">2</span>; 结果：<span class="hljs-number">0</span><br><span class="hljs-comment">//可以将算数运算符和赋值运算符=号合起来作为简写。</span><br></code></pre></td></tr></table></figure><h3 id="028-自增和自减运算符"><a href="#028-自增和自减运算符" class="headerlink" title="028-自增和自减运算符"></a>028-自增和自减运算符</h3><h4 id="自增-x2F-自减运算符"><a href="#自增-x2F-自减运算符" class="headerlink" title="自增&#x2F;自减运算符"></a><strong>自增&#x2F;自减运算符</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">int a = <span class="hljs-number">5</span>;<br>a++; <span class="hljs-regexp">//</span>结果：<span class="hljs-number">6</span><br>a--; <span class="hljs-regexp">//</span>结果：<span class="hljs-number">5</span><br><span class="hljs-regexp">//</span>++和--为自增（自减）运算符，即将自己的值+<span class="hljs-number">1</span>或-<span class="hljs-number">1</span>。<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> b = a++; <span class="hljs-comment">//先赋值，再自增，此时b的值为5，a的值为6。</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-built_in">int</span> b = ++a; <span class="hljs-comment">//先自增，再赋值，此时a和b的值都是6。</span><br><span class="hljs-comment">//++和--单独使用时，不管放在前面和后面都是自增自减。</span><br><span class="hljs-comment">//在涉及到多个变量的表达式中，放在前面是先自增再赋值，放在后面就是先赋值再自增。</span><br></code></pre></td></tr></table></figure><h3 id="029-关系运算符和布尔类型"><a href="#029-关系运算符和布尔类型" class="headerlink" title="029-关系运算符和布尔类型"></a>029-关系运算符和布尔类型</h3><h4 id="关系运算符和布尔类型"><a href="#关系运算符和布尔类型" class="headerlink" title="关系运算符和布尔类型"></a><strong>关系运算符和布尔类型</strong></h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">bool</span> a = <span class="hljs-literal">true</span>; <br><span class="hljs-type">bool</span> b = <span class="hljs-literal">false</span>;<br>//<span class="hljs-type">bool</span>类型只有<span class="hljs-literal">true</span>（<span class="hljs-number">1</span>）和<span class="hljs-literal">false</span>（<span class="hljs-number">0</span>）两个值，<span class="hljs-literal">true</span>为真，<span class="hljs-literal">false</span>为假。<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">== <span class="hljs-regexp">//</span>判断左边是否等于右边<br>&gt; <span class="hljs-regexp">//</span>判断左边是否⼤于右边<br>&lt; <span class="hljs-regexp">//</span>判断左边是否⼩右边<br>&gt;= <span class="hljs-regexp">//</span>判断左边是否⼤于或等于右边<br>&lt;= <span class="hljs-regexp">//</span>判断左边是否⼩于或等于右边<br>!= <span class="hljs-regexp">//</span>判断左边是否不等于右边<br></code></pre></td></tr></table></figure><h3 id="030-逻辑运算符"><a href="#030-逻辑运算符" class="headerlink" title="030-逻辑运算符"></a>030-逻辑运算符</h3><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">&amp;&amp; <span class="hljs-regexp">//</span>与，全真为真，有假为假。<br>|| <span class="hljs-regexp">//</span>或，有一个真即为真，全假为假。<br>！ <span class="hljs-regexp">//</span>非，将结果颠倒，条件为真则使之为假，反之亦然。<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bool</span> a = <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span> &gt; <span class="hljs-number">4</span>;  //<span class="hljs-number">2</span>&gt;<span class="hljs-number">4</span>为假，所以是false。<br><span class="hljs-attribute">bool</span> b = <span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span> || <span class="hljs-number">2</span> &gt; <span class="hljs-number">4</span>; //<span class="hljs-number">3</span>&gt;<span class="hljs-number">1</span>为真，所以是true。<br><span class="hljs-attribute">bool</span> c = !(<span class="hljs-number">3</span> &gt; <span class="hljs-number">1</span>); //<span class="hljs-number">3</span>&gt;<span class="hljs-number">1</span>为真，颠倒结果，所以是false。<br></code></pre></td></tr></table></figure><h3 id="034-if条件语句"><a href="#034-if条件语句" class="headerlink" title="034-if条件语句"></a>034-if条件语句</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><strong>if语句</strong></h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (Convert.ToInt32(<span class="hljs-built_in">Console</span>.ReadLine())&gt;=<span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;可以进入&quot;</span>);<br>&#125;<br><span class="hljs-comment">//语法为：if(条件)&#123;执行语句&#125;，小括号为条件，大括号内为满足条件后运行的语句。</span><br></code></pre></td></tr></table></figure><h4 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if-else语句"></a><strong>if-else语句</strong></h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">if</span> (Convert.ToInt32(<span class="hljs-built_in">Console</span>.ReadLine())&gt;=<span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;可以进入&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">Console</span>.WriteLine(<span class="hljs-string">&quot;不可以进入&quot;</span>);<br>&#125;<br><span class="hljs-comment">//语法为：if(条件)&#123;执行语句&#125;else&#123;执行语句&#125;，第二个大括号内为不满足条件时执行的语句。</span><br><span class="hljs-comment">//在大括号内的执行语句中也可以嵌套新的if语句用来做多层级判断条件的处理。</span><br></code></pre></td></tr></table></figure><h4 id="if-else-if语句"><a href="#if-else-if语句" class="headerlink" title="if-else-if语句"></a><strong>if-else-if语句</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">int score = Convert.ToInt32(Console.ReadLine());<br><span class="hljs-keyword">if</span> (score &gt;=<span class="hljs-number">90</span>)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;A&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;=<span class="hljs-number">70</span>)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;B&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt;= <span class="hljs-number">60</span>)<br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;C&quot;</span>);            <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>Console.WriteLine(<span class="hljs-string">&quot;D&quot;</span>);<br>&#125;<br><span class="hljs-regexp">//</span>语法为：<span class="hljs-keyword">if</span>(条件)&#123;执行语句&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>&#123;执行语句&#125;…<span class="hljs-keyword">else</span>&#123;执行语句&#125;。<br><span class="hljs-regexp">//</span>可以理解为在第一个<span class="hljs-keyword">if</span>未满足条件的情况下，读取下一个elseif的条件，满足便执行后续的代码。<br><span class="hljs-regexp">//</span>如此一层一层往下读，读到最后一个<span class="hljs-keyword">else</span>还未满足过条件，就执行最后一个<span class="hljs-keyword">else</span>后面的代码。<br></code></pre></td></tr></table></figure><h3 id="044-switch语句-基本语法"><a href="#044-switch语句-基本语法" class="headerlink" title="044-switch语句-基本语法"></a>044-switch语句-基本语法</h3><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><strong>switch语句</strong></h4><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">switch</span>(变量)<br>&#123;<br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">1</span>:<br>执行代码<br><span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">2</span>:<br>执行代码<br><span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">3</span>:<br>执行代码<br><span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br><span class="hljs-literal">default</span>:<br>执行代码<br><span class="hljs-built_in">break</span><span class="hljs-comment">;</span><br>&#125;<br>//注意：<span class="hljs-literal">default</span>可以没有。<br>//注意：每⼀个<span class="hljs-keyword">case</span>后⾯⼀般都有<span class="hljs-built_in">break</span>。<br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">switch</span>(变量)<br>&#123;<br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">1</span>:<br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">2</span>:<br><span class="hljs-keyword">case</span> 条件<span class="hljs-number">3</span>:<br>执行代码<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br>执行代码<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">//当多个不同条件执行相同代码时，可以按照将case逐行放在一起，这样只需要加一次执行代码。</span><br></code></pre></td></tr></table></figure><h3 id="048-while循环的基本结构"><a href="#048-while循环的基本结构" class="headerlink" title="048-while循环的基本结构"></a>048-while循环的基本结构</h3><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a><strong>while循环语句</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">while</span>（条件表达式）<br>&#123;<br>循环体<br>&#125;<br><span class="hljs-regexp">//</span>注意：当满⾜条件的时候会⼀直执⾏，不满⾜条件的时候，跳出循环。<br><span class="hljs-regexp">//</span>注意：条件表达式也是布尔表达式，需要返回⼀个布尔值。<br></code></pre></td></tr></table></figure><h3 id="054-通过for循环输出1-10"><a href="#054-通过for循环输出1-10" class="headerlink" title="054-通过for循环输出1-10"></a>054-通过for循环输出1-10</h3><h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a><strong>for循环语句</strong></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(初始化;条件表达式;增量表达式)</span></span><br>&#123;<br>循环体<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(int i <span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=10;i++)</span><br>&#123;<br>console.writeline(i)<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="056-do-while循环"><a href="#056-do-while循环" class="headerlink" title="056-do-while循环"></a>056-do-while循环</h3><h4 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do-while循环语句"></a><strong>do-while循环语句</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">do</span><br>&#123;<br>循环体<br>&#125;<br><span class="hljs-keyword">while</span>(条件表达式);<br><span class="hljs-regexp">//</span>当⾸次进⼊循环不满⾜条件表达式的时候，dowhile会执⾏⼀次循环体，<span class="hljs-keyword">while</span>⼀次都不会执⾏。<br><span class="hljs-regexp">//</span>其他情况，<span class="hljs-keyword">do</span> <span class="hljs-keyword">while</span>和<span class="hljs-keyword">while</span>没有区别。<br></code></pre></td></tr></table></figure><h3 id="057-for循环的其他情况"><a href="#057-for循环的其他情况" class="headerlink" title="057-for循环的其他情况"></a>057-for循环的其他情况</h3><h4 id="强行终止循环"><a href="#强行终止循环" class="headerlink" title="强行终止循环"></a><strong>强行终止循环</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>可以在<span class="hljs-keyword">for</span>循环中加入<span class="hljs-keyword">if</span>条件判断语句，然后插入<span class="hljs-keyword">break</span>来强行终止循环。<br></code></pre></td></tr></table></figure><h3 id="058-变量的作用域"><a href="#058-变量的作用域" class="headerlink" title="058-变量的作用域"></a>058-变量的作用域</h3><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a><strong>变量的作用域</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>变量仅在自己的作用域内才能生效，例如在<span class="hljs-keyword">for</span>循环中定义的变量i不能在循环语句外使用。<br><span class="hljs-regexp">//</span>在不同的作用域下，可以存在多个重名的变量。<br></code></pre></td></tr></table></figure><h3 id="066-编程题（单个字符读取）"><a href="#066-编程题（单个字符读取）" class="headerlink" title="066-编程题（单个字符读取）"></a>066-编程题（单个字符读取）</h3><h4 id="读取控制台输入的单个字符"><a href="#读取控制台输入的单个字符" class="headerlink" title="读取控制台输入的单个字符"></a><strong>读取控制台输入的单个字符</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">char</span> a =(<span class="hljs-keyword">char</span>)console.<span class="hljs-keyword">read</span>();<br><span class="hljs-keyword">char</span> b =(<span class="hljs-keyword">char</span>)console.<span class="hljs-keyword">read</span>();<br><span class="hljs-comment">//console.read()在运行时要求在控制台输入一串字符，在按下回车后判定为输入完毕。</span><br><span class="hljs-comment">//接着根据执行console.read()语句的此时将输入的字符串的前若干位存储入变量。</span><br><span class="hljs-comment">//注意：在不用(char)进行强制转换的情况下，默认读取的字符是int类型即字符对应ASCII表的数字。</span><br><span class="hljs-comment">//在控制台输入超过console.read()语句数量的字符后：</span><br><span class="hljs-comment">//即使运行了其他语句，再执行该语句为变量赋值时，会直接使用前一次输入的字符串的字符。</span><br></code></pre></td></tr></table></figure><h3 id="068-循环中的continue"><a href="#068-循环中的continue" class="headerlink" title="068-循环中的continue"></a>068-循环中的continue</h3><h4 id="循环中的continue"><a href="#循环中的continue" class="headerlink" title="循环中的continue"></a><strong>循环中的continue</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在循环中嵌套<span class="hljs-keyword">if</span>语句中插入<span class="hljs-keyword">continue</span>，满足<span class="hljs-keyword">if</span>的条件后，运行<span class="hljs-keyword">continue</span>语句。<br><span class="hljs-regexp">//</span>此时直接终止当前循环，进行下一次循环。<br><span class="hljs-regexp">//</span>和<span class="hljs-keyword">break</span>的区别在于<span class="hljs-keyword">continue</span>不会终止全部循环，仅终止本次的循环（不运行此次循环中后续的代码）。<br></code></pre></td></tr></table></figure><h3 id="074-猜数字小游戏"><a href="#074-猜数字小游戏" class="headerlink" title="074-猜数字小游戏"></a>074-猜数字小游戏</h3><h4 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a><strong>随机数生成</strong></h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Random</span> rd = <span class="hljs-keyword">New</span> <span class="hljs-built_in">Random</span>(); <span class="hljs-comment">//创建一个新的随机数对象rd。</span><br><span class="hljs-built_in">Console</span>.Writeline(rd.Next(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)) <span class="hljs-comment">//使用Next方法生成一个区间在[1，10）以内的随机数并输出。</span><br><span class="hljs-comment">//注意：区间是左闭右开，上述例子中，生成的数字可以是1，但不会是10。</span><br></code></pre></td></tr></table></figure><h3 id="075-基本数据类型-整型-x2F-076-基本数据类型-浮点（小数）类型"><a href="#075-基本数据类型-整型-x2F-076-基本数据类型-浮点（小数）类型" class="headerlink" title="075-基本数据类型-整型 &#x2F; 076-基本数据类型-浮点（小数）类型"></a>075-基本数据类型-整型 &#x2F; 076-基本数据类型-浮点（小数）类型</h3><h3 id="077-类型的转换（显式和隐式转换）"><a href="#077-类型的转换（显式和隐式转换）" class="headerlink" title="077-类型的转换（显式和隐式转换）"></a>077-类型的转换（显式和隐式转换）</h3><h4 id="整型-x2F-浮点数据"><a href="#整型-x2F-浮点数据" class="headerlink" title="整型&#x2F;浮点数据"></a><strong>整型&#x2F;浮点数据</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">byte</span>:可以安全转换为<span class="hljs-built_in">short</span>，<span class="hljs-built_in">ushort</span>，<span class="hljs-built_in">int</span>，<span class="hljs-built_in">uint</span>，<span class="hljs-built_in">long</span>，<span class="hljs-built_in">ulong</span>，<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。<br><span class="hljs-built_in">sbyte</span>:可以安全转换为<span class="hljs-built_in">short</span>，<span class="hljs-built_in">int</span>，<span class="hljs-built_in">long</span>，<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。<br>shourt：可以安全转换为<span class="hljs-built_in">int</span>，<span class="hljs-built_in">long</span>，<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。<br><span class="hljs-built_in">ushort</span>：可以安全转换为<span class="hljs-built_in">int</span>，<span class="hljs-built_in">uint</span>，<span class="hljs-built_in">long</span>，<span class="hljs-built_in">ulong</span>，<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。<br><span class="hljs-built_in">int</span>：可以安全转换为<span class="hljs-built_in">long</span>，<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。 <span class="hljs-comment">//int转换成float可能会丢失精度。</span><br>unit：可以安全转换为<span class="hljs-built_in">long</span>，<span class="hljs-built_in">ulong</span>，<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，demical。<br><span class="hljs-built_in">long</span>：可以安全转换为<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。<br><span class="hljs-built_in">ulong</span>:可以安全转换为<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。<br><span class="hljs-built_in">float</span>：可以安全转换为<span class="hljs-built_in">double</span>。<span class="hljs-comment">//使用float定义数据：float a =1.5f </span><br><span class="hljs-comment">//注意使用flaot类型赋值要在最后加个f。</span><br><span class="hljs-built_in">char</span>:可以安全转换为<span class="hljs-built_in">ushort</span>，<span class="hljs-built_in">int</span>，<span class="hljs-built_in">uint</span>，<span class="hljs-built_in">long</span>，<span class="hljs-built_in">ulong</span>，<span class="hljs-built_in">float</span>，<span class="hljs-built_in">double</span>，<span class="hljs-built_in">decimal</span>。<br><span class="hljs-comment">//注意：赋值的时候，两边类型是需要⼀致的，如果不⼀致的话，就需要转换类型。</span><br><span class="hljs-comment">//有些条件下，会⾃动进⾏转换，叫做隐式转换。</span><br><span class="hljs-comment">//有些情况下，需要我们告诉编译器进⾏类型转换，叫做显⽰转换，也叫做强制类型转换，强塞。</span><br><span class="hljs-comment">//不能强制转换不同类型的数据，比如不能把数字类型强制转换成字符串类型。</span><br></code></pre></td></tr></table></figure><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos">不同数据类型的强制转换使用<span class="hljs-built_in">convert</span>.toxxxxx方法。<br>例如：<span class="hljs-built_in">convert</span>.toint32  <span class="hljs-built_in">convert</span>.todouble  <span class="hljs-built_in">convert</span>.tostring 等等。<br></code></pre></td></tr></table></figure><h3 id="081-什么是数组-x2F-082-数组的使用"><a href="#081-什么是数组-x2F-082-数组的使用" class="headerlink" title="081-什么是数组 &#x2F; 082-数组的使用"></a>081-什么是数组 &#x2F; 082-数组的使用</h3><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a><strong>数组的声明</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">int[] ages = &#123;<span class="hljs-number">32</span>,<span class="hljs-number">12</span>,<span class="hljs-number">56</span>,<span class="hljs-number">78</span>&#125;; <span class="hljs-regexp">//</span>数组长度为括号里面的数字的数目。<br><span class="hljs-regexp">//</span>忽略new int[]的语句时声明需要在同一行完成。<br><span class="hljs-regexp">//</span>数组的组成有下标（索引），从<span class="hljs-number">0</span>开始排，可以理解为序号。<br>console.writeline(ages[<span class="hljs-number">0</span>]); <span class="hljs-regexp">//</span>通过数组名[索引]来访问对应的数组内容。<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span>[] ages = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span> [<span class="hljs-number">10</span>]; <span class="hljs-comment">//创建一个长度为10的数组，没有声明具体的数字，所以会用默认值0。</span><br>age[<span class="hljs-number">4</span>] = <span class="hljs-number">20</span>; <span class="hljs-comment">//可以再次声明单独修改数组里面的单个元素的值。</span><br><span class="hljs-comment">//注意：声明时直接确定数组长度时，长度需要和赋值时提供的数字个数一致，否则会报错。</span><br></code></pre></td></tr></table></figure><h3 id="083-数组的遍历"><a href="#083-数组的遍历" class="headerlink" title="083-数组的遍历"></a>083-数组的遍历</h3><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a><strong>数组的遍历</strong></h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i&lt;<span class="hljs-number">10</span> ; i++)<br>&#123;<br>console.<span class="hljs-keyword">write</span>(ages[i]+<span class="hljs-string">&quot; &quot;</span>); <br>&#125;<br><span class="hljs-comment">//通过for循环来遍历数组。</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">int i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>  (i&lt;<span class="hljs-number">10</span>)<br>&#123;<br>console.write(ages[i]+<span class="hljs-string">&quot; &quot;</span>);<br>i++;<br>&#123;<br><span class="hljs-regexp">//</span>通过<span class="hljs-keyword">while</span>循环来遍历数组。<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">foreach</span>(<span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> <span class="hljs-keyword">in</span> ages) //<span class="hljs-keyword">temp</span>是临时变量<br>&#123;<br>console.<span class="hljs-keyword">write</span>(<span class="hljs-keyword">temp</span> +&quot; &quot;);<br>&#125;<br>//通过<span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span>循环遍历数组。<br>//<span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span>仅用于集合的遍历，且仅能正序遍历数组。<br></code></pre></td></tr></table></figure><h4 id="数组长度的获取"><a href="#数组长度的获取" class="headerlink" title="数组长度的获取"></a><strong>数组长度的获取</strong></h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">ages.<span class="hljs-built_in">length</span> <span class="hljs-comment">//可以通过数组.length来获取数组的具体长度。</span><br></code></pre></td></tr></table></figure><h3 id="084-字符串-字符数组"><a href="#084-字符串-字符数组" class="headerlink" title="084-字符串-字符数组"></a>084-字符串-字符数组</h3><h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a><strong>字符数组</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">string name = <span class="hljs-string">&quot;lchiot&quot;</span> <span class="hljs-regexp">//</span>lchiot字符串可以看作一个字符的数组。<br><span class="hljs-regexp">//</span>字符串数组也可以用string[序号]来进行访问，但不能单独修改组成部分。<br>console.writeline(name.lengyh); <span class="hljs-regexp">//</span>输出name字符串的长度并输出。<br><span class="hljs-keyword">for</span> each (string temp <span class="hljs-keyword">in</span> name)<br>&#123;<br>console.writeline(temp); <span class="hljs-regexp">//</span>用<span class="hljs-keyword">for</span> each遍历字符串中的每一个字符。<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="085-字符串操作常用方法-x2F-086-字符串操作Split"><a href="#085-字符串操作常用方法-x2F-086-字符串操作Split" class="headerlink" title="085-字符串操作常用方法 &#x2F; 086-字符串操作Split"></a>085-字符串操作常用方法 &#x2F; 086-字符串操作Split</h3><h4 id="字符串的常用方法"><a href="#字符串的常用方法" class="headerlink" title="字符串的常用方法"></a><strong>字符串的常用方法</strong></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">字符串<span class="hljs-selector-class">.tolower</span>() / 字符串<span class="hljs-selector-class">.toupper</span>() <span class="hljs-comment">//把字符串里的所有字母全变成小写or大写。</span><br><span class="hljs-comment">//注意：使用该方法不会修改字符串本身，需要申明一个新的字符串来接收结果。</span><br>字符串<span class="hljs-selector-class">.Trim</span>() / 字符串<span class="hljs-selector-class">.TrimStart</span>() / 字符串<span class="hljs-selector-class">.TrimEnd</span>() <br><span class="hljs-comment">//trim：去除字符串前后的空格；trimstart：只去除前面的；trimend：只去除后面的。</span><br>字符串<span class="hljs-selector-class">.Split</span>(分割号) <span class="hljs-comment">//根据分割号将一个字符串切割成若干个字符串组成的字符串数组。</span><br>string <span class="hljs-selector-attr">[]</span> strarray = name<span class="hljs-selector-class">.Spilit</span>(<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment">//根据逗号将name字符串切割成若干个字符串组成staarray数组。</span><br></code></pre></td></tr></table></figure><h3 id="087-编程题-可乐和字符串加密"><a href="#087-编程题-可乐和字符串加密" class="headerlink" title="087-编程题-可乐和字符串加密"></a>087-编程题-可乐和字符串加密</h3><h4 id="将字符串转换为字符数组"><a href="#将字符串转换为字符数组" class="headerlink" title="将字符串转换为字符数组"></a><strong>将字符串转换为字符数组</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">字符串.tochararray(); <span class="hljs-regexp">//</span>将字符串转换为字符数组的方法。<br>chararrar[i] =(char)(chararray[i] +<span class="hljs-number">2</span>) <br><span class="hljs-regexp">//</span>注意：字符与整数相加时默认会将字符转换为ASCII表对应的数字再相加输出整数。<br><span class="hljs-regexp">//</span>因此还需要通过强制转换（char）强制将整数再重新转换成char类型完成数组变化。<br></code></pre></td></tr></table></figure><h3 id="090-编程题-排序-系统方法"><a href="#090-编程题-排序-系统方法" class="headerlink" title="090-编程题-排序-系统方法"></a>090-编程题-排序-系统方法</h3><h4 id="通过系统的方法对数组进行排序"><a href="#通过系统的方法对数组进行排序" class="headerlink" title="通过系统的方法对数组进行排序"></a><strong>通过系统的方法对数组进行排序</strong></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Array.<span class="hljs-constructor">Sort(<span class="hljs-params">intarray</span>)</span>; <span class="hljs-comment">//array.sort(数组)可以对任意数组进行从小到大的排序。</span><br>foreach (<span class="hljs-built_in">int</span> t <span class="hljs-keyword">in</span> intarray)<br>&#123;<br>Console.<span class="hljs-constructor">WriteLine(<span class="hljs-params">t</span>)</span>; <span class="hljs-comment">//对排序结果再进行输出。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="098-方法（函数）的定义和调用"><a href="#098-方法（函数）的定义和调用" class="headerlink" title="098-方法（函数）的定义和调用"></a>098-方法（函数）的定义和调用</h3><h4 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a><strong>函数的定义和调用</strong></h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">static void <span class="hljs-built_in">Verify</span>() <span class="hljs-comment">//void是返回值，Verify是方法名。</span><br>&#123;<br>console<span class="hljs-selector-class">.writeline</span>(&quot;这是一个函数&quot;); <span class="hljs-comment">//编写函数的执行代码。</span><br>&#125;<br><span class="hljs-built_in">Verify</span>(); <span class="hljs-comment">//使用函数。</span><br></code></pre></td></tr></table></figure><h3 id="099-方法的参数和返回值的作用"><a href="#099-方法的参数和返回值的作用" class="headerlink" title="099-方法的参数和返回值的作用"></a>099-方法的参数和返回值的作用</h3><h4 id="方法的返回值和参数"><a href="#方法的返回值和参数" class="headerlink" title="方法的返回值和参数"></a><strong>方法的返回值和参数</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>) <span class="hljs-comment">//括号内定义参数。</span></span><br>&#123;<br><span class="hljs-keyword">return</span> a+b; <span class="hljs-comment">//设置返回的值。</span><br>&#125;<br>Add(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//调用具体的参数。</span><br><span class="hljs-built_in">int</span> result =<span class="hljs-keyword">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//通过定义新变量获取函数的返回值。</span><br>console.writeline(result);<br>注意：执行<span class="hljs-keyword">return</span>后默认方法结束了，该方法后续的代码不会再执行。<br></code></pre></td></tr></table></figure><h3 id="102-方法中的参数数组"><a href="#102-方法中的参数数组" class="headerlink" title="102-方法中的参数数组"></a>102-方法中的参数数组</h3><h4 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a><strong>参数数组</strong></h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan">static <span class="hljs-type">int</span> Add(params <span class="hljs-type">int</span>[] <span class="hljs-type">array</span>) <br>&#123;<br><span class="hljs-type">int</span> <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span>;<br>foreach (<span class="hljs-type">int</span> temp <span class="hljs-keyword">in</span> <span class="hljs-type">array</span>)<br>&#123;<br><span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + temp;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>;<br>&#125;<br><span class="hljs-comment">//在数组参数之前加上params后，调用时不用再声明完整的数组。</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">int sum = Add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>Console.WriteLine(sum);<br><span class="hljs-regexp">//</span>调用时直接函数名（数组组成部分）即可，不用先声明一个新的数组了。<br><span class="hljs-regexp">//</span>params会自动把各个int参数组合成一个完整的数组后再放入函数中进行运行。<br><span class="hljs-regexp">//</span>params之前还可以加入其他类型的参数，但params必须是函数中的最后一个参数。<br><span class="hljs-regexp">//</span>返回值也可以是一个数组。<br></code></pre></td></tr></table></figure><h3 id="104-函数的重载-Overload"><a href="#104-函数的重载-Overload" class="headerlink" title="104-函数的重载-Overload"></a>104-函数的重载-Overload</h3><h4 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a><strong>函数的重载</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>多个函数名相同，参数不同，这个叫做函数的重载。<br><span class="hljs-regexp">//</span>编译器通过不同的参数去识别应该调⽤哪⼀个函数。<br><span class="hljs-regexp">//</span>编译器会根据你传递过来的实参的类型去判定调⽤哪⼀个函数。<br></code></pre></td></tr></table></figure><h3 id="105-方法的递归调用"><a href="#105-方法的递归调用" class="headerlink" title="105-方法的递归调用"></a>105-方法的递归调用</h3><h4 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a><strong>递归函数</strong></h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">调⽤⾃⾝的函数就是递归函数。<br>递归需要设置一个递归的终止条件，没有终止条件会进入死循环。<br></code></pre></td></tr></table></figure><h3 id="109-常量"><a href="#109-常量" class="headerlink" title="109-常量"></a>109-常量</h3><h4 id="常量的声明"><a href="#常量的声明" class="headerlink" title="常量的声明"></a><strong>常量的声明</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">const int i = <span class="hljs-number">10</span>; <span class="hljs-regexp">//</span>前面加const代表常量声明。<br><span class="hljs-regexp">//</span>注意：声明常量后，不能对常量再进行赋值。<br><span class="hljs-regexp">//</span>常量的名字一般是全部大写。<br></code></pre></td></tr></table></figure><h3 id="110-什么是枚举类型"><a href="#110-什么是枚举类型" class="headerlink" title="110-什么是枚举类型"></a>110-什么是枚举类型</h3><h4 id="枚举类型的定义与声明"><a href="#枚举类型的定义与声明" class="headerlink" title="枚举类型的定义与声明"></a><strong>枚举类型的定义与声明</strong></h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">enum RoleType <span class="hljs-regexp">//</span>roletype是枚举类型的名字。<br>&#123;<br>Mage = <span class="hljs-number">10</span>,Archer,Assassin,Tank,Support,Warriar <span class="hljs-regexp">//</span>枚举类型的值，用逗号隔开。<br>&#125;<br><span class="hljs-regexp">//</span>枚举类型的值不需要用引号，直接写就可以。<br><span class="hljs-regexp">//</span>上述代码是枚举声明的过程。<br>RoleType t1 = RoleType.Tank; <span class="hljs-regexp">//</span>使用枚举类型名字.类型的值可以对变量进行声明。<br><span class="hljs-regexp">//</span>枚举类型变量的赋值和使用与正常的变量相同。<br><span class="hljs-regexp">//</span>每个枚举类型的值同时也是一个整数类型，默认按照顺序从<span class="hljs-number">0</span>开始递增。<br><span class="hljs-regexp">//</span>默认值可以在声明枚举类型时进行更改。<br></code></pre></td></tr></table></figure><h3 id="112-结构体"><a href="#112-结构体" class="headerlink" title="112-结构体"></a>112-结构体</h3><h4 id="结构体的定义与使用"><a href="#结构体的定义与使用" class="headerlink" title="结构体的定义与使用"></a><strong>结构体的定义与使用</strong></h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//结构体的作⽤就是把某⼀类的变量进⾏整合，组成⼀个新的数据类型，相当于⼀个新的信息。</span><br><span class="hljs-comment">//⽐如学⽣信息（包含了 年龄，姓名、年级、学号）。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StudentInfo</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">//public是访问权限，目前默认使用public。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> name;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> grade;<br><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> studyID; <br>&#125;<br><span class="hljs-comment">//只是规定学生信息包含4个信息与信息的数据类型。</span><br>StudentInfo xiaoming; <span class="hljs-comment">//创建学生小明。</span><br>xiaoming.age = <span class="hljs-number">12</span>; <span class="hljs-comment">//给小明的年龄赋值。</span><br>xiaoming.name = <span class="hljs-string">&quot;⼩明&quot;</span>;<br><span class="hljs-comment">//相当于把所有信息汇总到了小明这个变量里面。</span><br>studentinfo[] studens = <span class="hljs-keyword">new</span> studentinfo[<span class="hljs-number">10</span>]; <span class="hljs-comment">//也可以创建结构体类型的数组方便进一步惯管理。</span><br></code></pre></td></tr></table></figure><h3 id="113-结构体函数"><a href="#113-结构体函数" class="headerlink" title="113-结构体函数"></a>113-结构体函数</h3><h4 id="结构体函数"><a href="#结构体函数" class="headerlink" title="结构体函数"></a><strong>结构体函数</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp">在结构体中定义函数，实现得到名字<br><span class="hljs-keyword">struct</span> CustomerName<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> firstName;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> lastName;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">GetName</span>()</span><br>&#123;<br><span class="hljs-keyword">return</span> firstName+<span class="hljs-string">&quot; &quot;</span>+lastName;<br>&#125;<br>&#125;<br><span class="hljs-comment">//结构体中不但可以定义属性，也可以定义函数。</span><br><span class="hljs-comment">//当我们在结构体中定义⼀个函数的时候，这个函数就可以通过结构体声明的变量来调⽤，</span><br><span class="hljs-comment">//这个函数可以带有参数，那么调⽤的时候必须传递参数，</span><br><span class="hljs-comment">//这个函数，可以使⽤结构体中的属性。</span><br>customername xiaoming; <span class="hljs-comment">//声明一个小明结构体</span><br>console.writeline(xiaoming.Getname()); <span class="hljs-comment">//通过结构体.函数的语法调用在结构体中声明的函数。</span><br></code></pre></td></tr></table></figure><h3 id="115-什么是委托"><a href="#115-什么是委托" class="headerlink" title="115-什么是委托"></a>115-什么是委托</h3><h4 id="委托类型变量"><a href="#委托类型变量" class="headerlink" title="委托类型变量"></a><strong>委托类型变量</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">delegate <span class="hljs-type">double</span> <span class="hljs-title function_">MyDelegate</span><span class="hljs-params">(<span class="hljs-type">double</span> param1,<span class="hljs-type">double</span> param2)</span>; <span class="hljs-comment">//声明一个叫mydelegate的委托。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Multiply</span><span class="hljs-params">(<span class="hljs-type">double</span> param1,<span class="hljs-type">double</span> param2)</span><br>&#123;<br><span class="hljs-keyword">return</span> param1*param2; <span class="hljs-comment">//声明一个作用是两个数相乘的函数。</span><br>&#125;<br><span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">Divide</span><span class="hljs-params">(<span class="hljs-type">double</span> param1,<span class="hljs-type">double</span> param2)</span><br>&#123;<br><span class="hljs-keyword">return</span> param1/param2; <span class="hljs-comment">//声明一个作用是两个数相除的函数。</span><br>&#125;<br><span class="hljs-type">double</span> <span class="hljs-variable">param1</span> <span class="hljs-operator">=</span> <span class="hljs-number">34</span>; <br><span class="hljs-type">double</span> <span class="hljs-variable">param2</span> <span class="hljs-operator">=</span><span class="hljs-number">2</span>;<br>MyDelegate de; <span class="hljs-comment">//正式声明一个叫de的委托变量。</span><br>de = Multiply; <span class="hljs-comment">//让de成为乘法函数。</span><br>de(param1,param2);<br>de = Divide; <span class="hljs-comment">//再让de成为除法函数。</span><br>de(param1,param2);<br><span class="hljs-comment">//委托是⼀个函数类型，可以把⼀个函数赋值给委托类型。</span><br><span class="hljs-comment">//定义委托的时候，语法类似于函数，需要声明返回值和参数类型，但是没有函数体。</span><br><span class="hljs-comment">//只能把委托赋值为参数和返回值均⼀样的函数。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结束，与新的开始</title>
    <link href="/2022/11/30/%E6%9D%82%E8%B0%88/%E7%BB%93%E6%9D%9F%E4%B8%8E%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
    <url>/2022/11/30/%E6%9D%82%E8%B0%88/%E7%BB%93%E6%9D%9F%E4%B8%8E%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p align="justify">　　我本想思考些什么，在拥挤之下选择放弃了思考，戴上耳机把大脑放空。出站后，就离我家距离很近了，天上下着不算很大但也忽视不了的雨，风也刮得厉害，向来不喜欢打伞的我走了一阵之后最终还是选择妥协，打开了伞。<p></blockquote><span id="more"></span> <h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p align="justify">　　11月29日下午，天色挺阴沉，坐在办公室内的我一如既往地刷着手机，出于无聊或者说是惯例，我给常联系的某位同事发了条“没事干了”，然后伸了个懒腰。大约一刻钟之后，抬头瞅了眼电脑屏幕，主管私聊我发了条“来趟会议室4”。我起身，走出办公室，看到领导站在办公室门口，摆出要领着我去会议室的架势。会议室4离我的工位并不远，走出办公室后，也就大约10步左右的距离。我推开门，狭小的会议室里坐着部门主管和两名不认识的女性，桌上摆着几张纸。事情发展到这个地步，再迟钝也该知道接下来会发生什么事情了。<p align="justify">　　很难形容当时的我是怎么样的心情，对于这种展开，我毫不惊讶，没有感到悲伤，如果事前想象这个场景，我会说我求之不得，但真的发生以后，也并不觉得开心。总之我挪开椅子，坐下。面前正对着我的两名女性并没有开口，反而是侧面的部门主管先发话：“你应该也知道了，项目解散了，现在要解除与你的劳动关系”。他的态度非常冷淡，还没等我来得及作出反应，我不知道名字的女性就开始介绍赔偿事宜，大致就是按照规定解除劳动关系会赔偿员工N+1月工资，11月到当天为止的工资和剩余的年假会一并结算，今天处理完遗留的考勤确认和发票报销就可以提前离开不用打卡如此这般。一般按照常理，遇到这种情况，我应该提前打开录音保留证据，以回避之后再发生一些争议事态需要维权的风险。但因为近期这种事情在公司内部已经听闻太多次，确实没听说有什么争端，而且大公司确实感觉也没有必要在这种地方耍什么花招，最终只是草草地阅读了下协议书，在几份文件上签好自己的名字，简要询问了下遗留事宜的处理，然后非常淡定地带着留给员工的文件和入职时提交的就业手册走出办公室。整个过程如同近期一系列事件的发展一样，干脆利落，丝毫不拖泥带水，我甚至怀疑整个我不到五分钟就走完了这个一般被称为“裁员”的流程。<p align="justify">　　我带着离职证明和就业手册回到工位，不需要我开口说什么，手里拿着的物件已经无声地向周边的同事宣告了这个事实。很快，先前那位常联系的同事就给我发了一串问号，坐我边上的同事倒吸了口气，感叹了一声。后桌某位入职初期就认识的老同事回过头用目光向我确认，我不知道怎么回应他，只能摆出一副苦笑的姿态，轻轻点头。事到如今，实在是没什么好开口说的，直接堂而皇之地开口讨论这种事情，对于还在职的同事们似乎也是一种禁忌。我打开公司的OA系统，把11月好几次加班晚到申请完，接着慢悠悠地掏出这半年来加班攒下的大概10张打车发票，挨个拍照传到电脑上录入系统，提交报销申请。考勤和报销处理完，我把桌面上的文件全部送进了回收站，这些文件涵盖了入职大概两年半以来经历的一共三个项目的各种经历，没什么很重要的东西，所以我直接把回收站清空了。把桌面恢复成默认后，我决定留下我曾经在职的最后一点痕迹，即我的工作账号头像。自从某次更新后，公司离职员工的头像不会恢复成默认头像，而是会保留离职前的最后一个头像，尽管通讯录中再也搜不到离职员工的名字，但先前的聊天记录还会保留，其他人透过聊天记录依然能看到最后的头像。我本想把头像换成曾经使用过的某个写着“与其这么辛苦，要不咱就不上班了吧”的头像，感觉会带来一种灰色幽默的效果，但可惜这张图已经在我的相册中不知去向，思前想后，我决定使用我入职以来使用过的第一个头像，是动画《邻家索菲》中主角索菲的头像，算是“回到最初的起点”了。接着我决定修改工作签名送走自己，本想改成“再也不见”，但总感觉太过张扬，最终，我选择了更加简单的三个字：“告辞！”，确实是告辞了。<p align="justify">　　换完头像和签名后，我关闭了电脑，开始收拾起遗留在工位的最后一点东西。幸亏对于今天的处境早有预期，最近一段时间，我陆陆续续把能带回去的东西比如书籍几乎全拿回去了，留下的大多是一些没什么用的杂物和垃圾，只用了十分钟就全部清理完了。事情都办完后，我清点下包里是否还有遗漏的东西，确认应该没有遗漏后，我背上包起身离开办公室。可能是留最后一丝情面，主管主动提出送我一程，跟我一起上了下行的电梯，两人面面相觑，气氛略显尴尬。最后是他主动开口：“之后有什么打算吗？”我说没有，准备休息一段时间了。他点点头：“你不喜欢SLG游戏，如果强行把你安排到SLG，对两边都不好，所以…”这句话没头没尾，可能是在解释为什么轮到我的原因。出于礼貌，我面无表情地表现出认同的样子：“挺好的”。走到大楼平时刷卡的闸机，主管用自己的卡帮我打开了离开的最后一道关卡，我回头摆摆手，道一声再见，走出了大楼。<p align="justify">　　直接主管离开后，还有两个同事为我送行，分别是入职以来前两个项目的同事，也是平日来交流最多的两个同事。我解释了先前这一个小时的遭遇和情境，简要聊了聊自己初步的规划和对未来的期许，所谓的未来期许其实就是没有期许，毕竟谁也不能预测虚无缥缈的未来，不过是随波逐流，能约定的不过是未来有机会可以再一起吃顿饭而已。最后一位同事送我平时上下班固定经过的地铁站后，因为离常规的下班时间还早，所以我决定先让自己吃顿好的，所以跑到了常去的拉面馆点了一碗最喜欢的豚骨拉面，吃的很撑。期间，我离开的消息逐渐扩散，陆陆续续有曾经共事过的同事通过工作用的通讯软件向我送上最后的道别。最意外的是上一个项目的某个研发同事，因为不在同一个部门，也就共事时有个很短暂的交流，我甚至没见过他本人，不知道他长什么样。他可能是刚好看到了我改的签名，吃惊地询问道：“老哥你不会…”那会儿还没到下班前后工作账号会被注销的时点，我还能回复消息，于是我半开玩笑地回了一句“要是再晚一点，你这条消息就发不出来了”。他似乎对我的遭遇表示不解，浅浅聊了一会儿后，最终给我留下了一句“希望你能找到更好的公司和工作，保重了”。老实说有点感动。吃完这最后地晚餐，我独自踏上了名为“第一份工作”的旅程的最后一段路——回家。<p align="justify">　　回家依然是乘坐地铁，刚好碰到了下班晚高峰期，一号线地铁格外拥挤，平时下班时刚好晚高峰刚好过去，车厢不会很挤，于是就显得尤其不适应，被疲惫的下班社畜们挤得浑身难受。我本想思考些什么，在拥挤之下选择放弃了思考，戴上耳机把大脑放空。出站后，就离我家距离很近了，天上下着不算很大但也忽视不了的雨，风也刮得厉害，向来不喜欢打伞的我走了一阵之后最终还是选择妥协，打开了伞。就这样，报着复杂的心情来到家门口前，我掏出钥匙、走进熟悉的家门，结束了，一切都结束了。<h2 id="定局"><a href="#定局" class="headerlink" title="定局"></a>定局</h2><p align="justify">　　虽然很多人都表示特别意外，但对我来说，这个结局其实不难预见，用游戏的说法，这个结局肯定算不上HE，但绝不是BE，算是个最容易触发的Normal End。年中，我经历的第二个项目宣告失败，项目组解散，大家不得不各奔东西。当时有很多选择摆在我面前，比如说，我可以趁着项目解散，和一些策划同事一样，选择直接离开，提早结束这段旅程；再比如说我可以主动提出去公司的核心SLG项目，增添一笔能加分的工作履历；但我最终选择坚持自己不愿意去SLG项目，最终经过当时部门主管的协调，跨部门来到了一个类卡牌的新项目。如果放在游戏中，这绝对是个决定故事展开的关键选项，也正是因为我选了这个选项，就注定了最后的结局。<p align="justify">　　来到新项目后，仅短短一个星期不到的时间我就嗅到了危险的气息，项目和先前经历的第二个项目实在过于相似了。一样是数据表现不佳在持续调整，一样是每隔一段时间导量一次测数据，甚至连导量选择的国家都几乎一致。收入数据虽然比第二个项目好上一些，但怎么看都不太像是能做大的样子。一个星期后的某天，主管把所有人叫去开了个会，提到项目要整体做一次超级巨大的改版，游戏的经济系统和外部玩法框架都要全面更改，当时就感觉多半是寄了，因为一模一样的剧本我在前项目中就已经见过一次。当一个新项目长期数据不佳到需要靠大改版来寻求生机时，就意味着已经走到了极其糟糕的地步，而事已至此，通过系统方面的改版去解决新玩家付费的问题不能说完全不可能，只能说概率极低。在新项目中待的时间稍长一些后，随即发现整个项目的管理是无可救药级别的烂，上线时间永远一拖再拖，研发的效率和产能也低得离谱。数据长期低迷最终让上面管理层下达了11月24日的死线，改版一定要在这个点之前完成，视改版效果决定项目去留。对我来说这是一场没有丝毫胜算的仗，倒不如说能否在死线前把规划好的内容都像样的做出来，都得打个问号。临近24日，公司开始年底裁员，组内的两个客服同时被裁，而研发团队中也有几个策划和程序先后走人，在这种节骨眼上裁人，等于是提前宣布了项目的终局。与此同时，我感觉也看到了自己的结局，开始提前收拾东西做好某天随时离开的准备。24号新版本上线，第二天看到数据我就知道项目关停已成定局，本以为还能按照先前的信息给出一个星期的宽裕，没想到周末过完就直接叫停了项目，再往后一天，也就是11月29日，我等待的这一天来了。<p align="justify">　　如此干脆地叫停项目，我觉得对所有人来说都是一件好事。对于策划和程序员，他们正在以极低的士气去打一场没有胜算的硬仗，为此不得不长时间加班，23号甚至过了个通宵。而在项目即将叫停的当下，一个普通运营所做的一切都没有任何意义。至于我自己，我觉得算是给了我一个痛快，等这一天很久了，某种意义上，我是求仁得仁了。<p align="justify">　　老实说，我其实想离开很久了，当我在新项目中察觉到“这个项目不太可能做得起来”这个事实后，我就感觉自己几乎失去了想要为之努力的动力。在项目做不起来的背景下，几乎所有常规的工作包括平时日周数据的整理都产生不了任何的价值，只能算是表面工夫。新主管的作风和我相性非常不好，我更希望可以有明确的工作布置下来，交代清楚具体的流程、要求和关键时间点，而他总是在追求虚无缥缈的所谓主动性，经常是什么都不说清楚，上班的体验犹如猜谜。进入项目组几个月，几乎没有给到什么像样的细则工作，只能是辅助性地给其他同事打打下手，而一项习惯被动的我也懒得开口，最后就变成了上班经常无事可做，只能刷手机看一天厕纸的状况。听起来很令人羡慕，但并不是什么很好的体验，最终形成了“觉得工作没有意义，不想干活”和“没有活干，每天无所事事耗时间感到痛苦”的矛盾状态。期间曾有被主管拉进会议室谈话，他说他觉得我做什么都差一口气，当工作中出现一件事情可做可不做时，我往往更倾向于不做。确实是这样，长期处于这种状态后，我感觉自己的精神状态很差，我所做的只是每天准时起床来到工位折磨自己大半天，然后准点下班，无限循环。我的工资不算低，按照我每天真正有在工作的时间来算，我的时薪可能高的令人发指，但贪婪的我并不太满意这样的生活。<p align="justify">　　我经常会跟同事口嗨说我想跑路了，但遗憾的是我并没有这样的勇气和行动力。一年之前，当我经历的第一个项目进入了一段犹如地狱一般的状态时，长期毫无意义的加班让我最终决定鼓起勇气提出离职的请求，但在当时两位部门主管的挽留下，最终我选择更换了项目而不是离开。我没有勇气的根源来自于我对自己的不自信，我对自己的自我认知始终是一个责任心有限、职业技能有限、非常社恐、难以沟通的废柴社恐形象，我总是觉得自己的工作只要大街上随便拉个人来培训两个星期就能顶替，我总觉得我自己的能力不足以支持我去找一份更好的工作，以至于当我寻觅机会看到招聘信息上的要求时，我一定会打起退堂鼓。我倒是有着名为创作的梦想，不管是做一款游戏也好、写一部小说也好，我希望可以通过自己的想象力来完成一部有趣的作品，但我似乎并没有天赋，甚至没有为了追逐梦想而尝试、学习的行动力。<p align="justify">　　各种信息渠道都在反应一个事实就是现在整体形式很差，失业之后找不到工作。没有勇气的我受此影响，尽管每隔一个星期都会产生强烈的辞职欲望，最后还是采取了能苟且一天是一天的策略，简直把摆烂二字写在了脸上。我的心态还是很矛盾，表现上是想一直混下去，内心里则是期待项目赶紧寄了给个痛快。当组内两个客服一并被裁时，我还疑惑为什么没有轮到我，而现在得偿所愿了。这次被裁员更多是系统性的裁员，快速扩展立下的各个新项目普遍效果不好，老项目也是一直在走下坡路，裁员规模远远大于以往。项目被叫停后，大概率是出于我多次明确表达出不去SLG的意愿，所以没有再跟我沟通换组事宜而是直接顺着形式一裁了之。<p align="justify">　　如果在关键抉择中我选择跑进SLG项目并留到年底，大概率可以躲过这次系统性裁员，但事到如今讨论这个已经没有意义了。人总是会做出当时对自己来说是最优解的抉择，普通人即不能预知未来，也不能改变过去，就算后悔也无济于事。我不后悔当初的决定，就算我去不太能接受的SLG项目苟且，也不见得会有更好的上班体验，我的生活未必会变得更好。自打我选择来到这个项目的那一刻，就已经是定局了。<h2 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h2><p align="justify">　　对于被裁员这件事，我的表现一直是比较平淡的。记得当时组内某个客服被裁的时候哭红了眼，我不太能做到这么感性，所以全程没有明显的情绪表达，最多也就是苦涩地笑笑，仿佛自己看得很开的样子。心里无数次预演过自己主动离职或者被动离职的情景，一度让我以为自己能很平淡地接受这件事情，但事实证明我好像还没有这么强大的内心。回到家后打了会儿游戏，洗漱完毕后躺在床上准备早点入睡，随即遭遇了早已习惯的失眠。以往失眠只是会胡思乱想各种乱七八糟的事情，而这次失眠掺杂着惆怅的情绪，算不上悲伤，更多一种对未来的不确定感。在失去了人生中这一份工作后，今后该何去何从？会不会遇到更多的困难与挫折？找不到新工作怎么办？找到了还是不满意，又怎么办？思绪遂开始不断地膨胀，随后演绎出若干个可见的Bad End，让我辗转反侧。<p align="justify">　　一觉醒来后倒是感觉好了不少，如果仔细回顾自打来到这个世界上的这二十多年，我觉得我迄今为止的生活算是比较顺利，基本没有什么很大的挫折。我没有很高的智力，找不太到很擅长的兴趣爱好，也不努力，但在学生时期总是能有比较好的运气取得差强人意的升学成绩。尽管对第一份工作有各种埋怨，但也不得不承认在待遇和人际关系方面，这份工作没有什么可以挑剔的地方，两年多工作下来，我已经有了相对同龄人来说比较高的存款积蓄，可以支撑我在无业的状态下坚持很长的时间。按照学生时期的划分，人生是三至五年作为一个阶段，工作了两年多，现在重归待业状态，算是上一个阶段的结束，更是新一个阶段的开始。我常常会抱怨工作后可自由支配的时间变少，没有精力和时间去学习想学的东西、费些功夫去实现自己的梦想，而现在回归待业状态后，这个借口就不再成立了。<p align="justify">　　写下这篇文章，不仅是对上一份工作的回顾、对这一次难得的裁员经历的记录，更多是对接下来两三个月的展望和鞭策。很久之后的未来不可预测，也无从把握，但待业期已经到来，可以好好做个规划。我希望在这难得的待业期给自己安排两个月的修整，在这两个月内，不去考虑找新工作的事宜、更不去考虑今后会遭遇多么糟糕的结局。用这难得的两个月，尽可能地去尝试实现一些之前遥不可及的梦想，例如做一款自己独创的游戏，等等，同时保持相对规律的作息好好地调节调节自己的身体和精神。两个月后，再去考虑那些令人头疼事关生存的事宜。如果这两个月依然把握不好，那就说明我并不具备实现梦想的资质，我需要抛弃这些不切实际的念想。如果勉强能在两个月内取得一些短期的进展，就需要做更长期的规划和后续找工作的环节结合起来。不清楚接下来会怎么发展，希望我，以及关心我的同事和朋友们，都能有光明的未来吧。]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《凶人邸杀人事件》的再突破</title>
    <link href="/2022/11/01/%E6%9D%82%E8%B0%88/%E5%87%B6%E4%BA%BA%E9%82%B8%E6%9D%80%E4%BA%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%86%8D%E7%AA%81%E7%A0%B4/"/>
    <url>/2022/11/01/%E6%9D%82%E8%B0%88/%E5%87%B6%E4%BA%BA%E9%82%B8%E6%9D%80%E4%BA%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%86%8D%E7%AA%81%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<p>　　</p><blockquote><p align="justify">　　欢迎来到梦幻城，这里是现实与梦幻之间的乐园。大家跟我一起快乐的跳舞吧，直到永夜迎来曙光。</blockquote><span id="more"></span> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p align="justify">　　国庆结束后返工第二天，公司大楼就因为疫情被封了，喜提时间长达两周的居家办公和一周的红码，以及三次上门核酸的VIP待遇。居家办公后，最显而易见的变化就是空闲时间变多了，每天能多睡至少一个小时。借着这难得的空闲，首先是搭了这个简陋的个人博客，其次就是正好把刚到货的简中版《凶人邸杀人事件》看完了。和同系列的前两部作品一样，这部作品在国内翻译为《凶人邸谜案》，应该是标题中出现“杀人”二字不太合适所以做了避嫌，是比较常规的操作了。不过我个人还是更喜欢“杀人事件”的翻译，毕竟作品原名就是《兇人邸の殺人》，强调“杀人”二字，明显更符合作为推理作品的题材。<p align="justify">　　《凶人邸杀人事件》的篇幅类似于系列前两部作品，字数在推理类作品中属于偏多的一类，简中版厚厚一大本，摸起来手感特别不错，一开始是当作睡前读物以比较慢的速度看了三四天，随着故事逐渐进入高潮，用一个晚上的时间把最后一半不到的篇幅一口气看完了。可能是因为长时间没有看小说载体的推理作品，《凶人邸杀人事件》的观感非常意外得不错，硬要说观感不错具体是哪里不错的话，我只能说就是故事写得非常好看，比系列前两作都要更加好看，在推理作品的故事性这一点上，我觉得作者今村昌弘非常难得地完成了又一次突破。<h2 id="今村昌弘与设定系推理"><a href="#今村昌弘与设定系推理" class="headerlink" title="今村昌弘与设定系推理"></a>今村昌弘与设定系推理</h2><p align="justify">　　前言中反复提到系列前两作，因此在书评的开始还是不得不简单地介绍介绍今村昌弘以及他笔下的两位主角。作为一名半路出道的推理作家，今村昌弘自2017年起，以两年一部新作的频率推出了三部推理作品，《尸人庄杀人事件》、《魔眼之匣杀人事件》以及本篇介绍的《凶人邸杀人事件》，三部作品使用同样的主角，构成时间线上连贯的系列作品。在《尸人庄杀人事件》中，男主角叶村让与女主角兼系列的侦探剑崎比留子相遇，以这次事件为契机，正式开启了两人调查事件始作俑者班目机构的主线，而《魔眼之匣杀人事件》和《凶人邸杀人事件》则是两人在调查班目机构的过程中，因女主角剑崎容易引发事端的体质，而被卷入新的危险事件的故事，由于是时间线渐进的系列作品，在三部作品中，读者也能看到男女主角关系的变化以及两人各自的成长。虽说是系列作品，但每一作的事件都基本独立，各作品之间相关联的基本只有男女主角的关系以及故事的大背景，所以不看前作，只看后边的作品其实也是可以的。说是这么说，但《尸人庄杀人事件》的推理部分逻辑条理清晰，诡计线索明确，故事性偏强，还是比较好读、不会觉得文字晦涩的行文风格，是个人钦定的推理作品入坑读物首选之一。如果对今村昌弘系列推理作品感兴趣，个人还是建议先从《尸人庄杀人事件》看起，如果看完感觉不对胃口，那后两部可能也没有再去看的必要了，毕竟三部作品各方面的调调都是比较相近的。<p align="justify">　　今村昌弘的三部作品在类型上均属于设定系推理，或者也可以叫科幻推理（SF推理）。设定系推理可以看作将超现实元素融入本格推理的推理作品，在这类作品中会出现带有科幻属性的超现实元素，这些超现实元素的加入目的是为了让作品中的诡计（或案件）得以成立，因此设定系推理仍然属于推理作品的范畴。传统本格推理作品虽然也经常会出现都市传说、民俗怪谈这样的超现实元素，但普遍是作为背景版，用作渲染故事气氛，案件的作案手法（或成立条件）不会与之相关，这是设定系推理和传统本格推理最大的区别。例如在西泽保彦的经典设定系推理作品《死了七次的男人》中，出现了时间循环的元素，在故事中，同样的一天被重复九次，除主角外，其他人无法察觉到这一天被重复九次的事实，若主角本人不加干涉，所有人在每个循环里都应当做出相同的行动。最后一次时间循环是这一天的“决定版”，主角需要在这一天来临之前，破解在外公第一个循环中安然无事，却在第二个循环中被人杀害的谜题，回避外公死亡的结局。毫无疑问，正是因为时间循环这个超现实元素在故事中真实存在，作品的谜题及诡计才得以成立。<p align="justify">　　相较于传统本格推理，个人觉得设定系推理的优势主要体现在两个层面：一是在超现实元素加入后，作品的案件设计尤其是诡计设计有了更多的可能性；二是推理作品的故事属性会得到大幅的强化。这两点今村昌弘的作品中得到了比较突出的体现——《尸人庄杀人事件》面世后，不仅得到了本格推理爱好者们的好评，获得了多项推理作品奖项，同时也在一般读者群体中大受欢迎，成为一部非常畅销的推理作品。能获得推理奖项，是因为作品中「丧尸」这一超现实元素被赋予了严密的行动原则，是案件发生的主要成因兼杀人诡计成立的核心因素，属于一种杀人手法（或者说诡计）设计上的创新；比起传统推理作品，丧尸这种流行科幻元素的出现明显更能调动一般读者的兴趣，所以成为畅销作品自然就水到渠成了。<p align="justify">　　如果说《尸人庄杀人事件》的「丧尸」元素实现了诡计的创新，那么系列第二部作品《魔眼之匣杀人事件》中的「预知未来」元素可以称得上是实现了案件动机上的突破。本以为今村昌弘可能就到此为止了，没想到新出的这一部《凶人邸杀人事件》还能带给我新的惊喜。这一次，今村昌弘淡化了前作中超现实元素与诡计、动机方面的强联系，而是转而将超自然元素重点放在了作品的故事性上，硬是把设定系推理写成了披着推理作品皮的冒险故事。<p align="justify">　　继「丧尸」和「预知未来」之后，这一次，超现实元素换成了在疯狂科学家的禁忌实验下诞生、身体能力远超常人、失去了人类理智、只留下了最后一丝执念、在黑暗中游荡、使用大砍刀、以残暴的方式斩首杀人的——「巨人」。<div class="note note-danger">            <p><strong>警告</strong><br>接下来会含有大量对小说《凶人邸杀人事件》剧情的剧透。<br>剧透包括本作故事的部分背景和情节脉络，但不会涉及到本作的凶手和核心诡计。<br>如果对这部推理小说相当感兴趣，请不要往下阅读本篇文章。</p>          </div><h2 id="扣人心弦的冒险"><a href="#扣人心弦的冒险" class="headerlink" title="扣人心弦的冒险"></a>扣人心弦的冒险</h2><p align="justify">　　设想下，在名为「凶人邸」的大型建筑中，潜藏一块昏黑的地下空间，在这如同迷宫一般的区域中，游荡着一只体格远超常人的「巨人」，「巨人」手提一把大刀，性情狂躁，带有目的性地狩猎着闯入这片区域的人类，杀死人类后，他会用大刀将尸体的头颅切下，扔到被地下室中被称为「首冢」的区域里。经过长年累月的狩猎，「首冢」已经满是人类头颅的枯骨。如今，一队人马趁着宅邸主人不备，在对「巨人」的存在毫不知情的情况下，硬闯入了这座满是秘密的建筑，他们怀着不同的目的，正面遭遇了狂暴的「巨人」。混乱中，唯一能打开「凶人邸」正门、同时也是唯一能启动用于将「巨人」离开的机关的钥匙不慎遗失，最了解「巨人」和整栋建筑情况的宅邸主人也在混乱中遭到杀害，众人被困在了「凶人邸」中无法脱离，不得不在「巨人」的威胁下寻找逃生的办法…<p align="justify">　　上述情境正是《凶人邸杀人事件》前期的主要故事内容，充斥着经典B级恐怖片的既视感：作死闯入禁忌之地的主角团、隐藏在暗处狩猎人类的恐怖「怪物」、遭「怪物」袭击后四散逃生的恐怖夜晚，这些元素几乎全是特色B级「杀人狂魔电影」的标配。一般来说，这类B级片最吸引人的地方一般是「怪物」以残忍手段杀人时血浆喷涌的限制级场面，到了后期，普遍又会变成人怪大战的俗套展开，最后天选之人的主角通过某种方式杀死怪物，得以存活。本作故事后续的展开也确实基本遵循这套经典架构：初次遭遇「怪物」的首个杀戮之夜，队伍中的几名雇佣兵面对未知「怪物」的突然袭击毫无招架之力、被砍下了头颅，剩余存活的人则因为各自心怀鬼胎而产生分歧，在宅邸中分散行动，寻找逃出宅邸的有效方案。在故事的最后，主角们基于对彼此的信任完成了一次大胆而另类的人怪大战，成功从险境中逃出生天。单以B级恐怖片的视角来看，本作好像未能免俗。<p align="justify">　　但《凶人邸杀人事件》说到底还是一部推理作品，尽管俗套，但B级恐怖片的元素还是相当于一剂强力的催化剂，给作品带来了令人耳目一新的阅读体验。具体来说，骇人怪物「巨人」的进场杀戮和主角惊慌逃生的情节描写大幅强化了阅读过程中的紧张感和压迫感，一般推理小说最多是加入一些传说怪谈元素渲染悬疑气氛，远不及在真实存在的恐怖怪物的追击下逃生所带来的压迫感。在带来压迫的同时，「巨人」的存在还让本作具备了比一般推理作品更强的互动感：本作自带一张独立的「凶人邸」平面图，建筑在推理作品中一般主要是起到让诡计合理化的效果，而「凶人邸」这一建筑的设计更多是为了让读者在阅读过程中多和地图互动，在作品中扮演着相当重要的角色。如果不经常对着地图，读者很难仅靠小说中的文字描述明确各个角色尤其是巨人在展开杀戮时的行动路线。为了强化这种需要经常查看地图的阅读体验，作为本作故事舞台的「凶人邸」被设计得超级复杂，不仅面积巨大，分成地上、地下、本馆、别馆、主区、副区等区块，布局也很花心思，巨人主要活动的地下区域更是做成了迷宫的样式。推理作品与读者的互动一般体现于读者在字里行间寻找线索、猜测案件的幕后凶手以及使案件成立的诡计，而《凶人邸杀人事件》在这基础上通过骇人怪物「巨人」的引入和「凶人邸」的复杂设计，明显更进了一步，从来没有哪部推理小说像本作一样让我如此频繁地查看地图，这种体验让我感到非常难得与有趣。<p align="justify">　　不管是让读者身临其境般地体会到来自「巨人」的威胁，还是让读者频繁查看地图了解行动路线，本质上目的都是强化作品的冒险故事属性，单就这一点来说，《凶人邸杀人事件》成功地达成了目的。<h2 id="略显薄弱的推理"><a href="#略显薄弱的推理" class="headerlink" title="略显薄弱的推理"></a>略显薄弱的推理</h2><p align="justify">　　在故事性得到提升的同时，本作的推理部分相应有所减弱。今村昌弘开篇用了大量的篇幅来描写主角二人进入「凶人邸」的经过以及遭到「巨人」袭击的第一天夜晚，一直到全书大约三分之一的篇幅位置，本作推理意义上的第一个案件，也就是「凶人邸」主人不木玄助在第一天夜晚被杀才姗姗来迟，作者今村昌弘甚至还非常贴心地通过视角转换的描写，直接挑明了凶手身份和不木玄助被杀的第一现场，再让因「巨人」袭击无法一起展开搜查的两名主角分别挖掘线索，推理出凶手的身份，引出本次事件中存在另一名「真凶」的事实，这一部分的推理又占据了本作大约三分之一的篇幅位置。在本作约三分之二不到的篇幅位置，第一夜巨人遭遇战中幸存下来的某人突发失踪，尸体随后在本馆中被发现，此时正是「巨人」因畏光无法出没于本馆的时间点，另一个「真凶」存在的事实完全暴露，可以看作本作推理意义上的第二起同时也是最后一起案件。最后约三分之一的故事篇幅讲述了众人在第二天夜晚再次遭遇巨人、在第三天白天尝试与外界联络、在第三天夜晚成功逃出「凶人邸」的经过，揭开「真凶」的身份和「巨人」背后的悲剧故事，宣布本作告一段落。<p align="justify">　　对比《尸人庄杀人事件》中利用丧尸实现的三起案件，《凶人邸杀人事件》的这两起案件在设计上要逊色不少。在第一起案件中，作者开上帝视角直接告知了读者凶手身份和第一现场，使得本作情节的聚焦点转移为「真凶」多此一举处理不木玄助尸体嫁祸给「巨人」的动机，比起如何实现杀人事件的诡计，动机层面的谜题就显得没那么有趣。第二起案件的发生紧贴第二夜正面遭遇「巨人」的时间点，导致这起杀人事件在凶残「巨人」的冲击下反而显得平平无奇。一般来说，推理作品最大的悬念同时也是最吸引读者的部分，往往是「真凶」的身份，而本作中「真凶」的身份，比已经很好猜的《尸人庄杀人事件》还要好猜——在第二夜的「巨人」遭遇战后，只要简单做个排除法，即使不知道第二起案件的手法，「真凶」的身份也已经呼之欲出了。至于第二起案件的诡计其实简单到不可思议，只能勉强看起来逻辑自洽，仔细推敲就会感觉「真凶」的动机非常奇怪，并且他使用的这个简单诡计，在现代刑侦技术下，不能达成他的真实目的。<p align="justify">　　读完全书后，这两起案件在本作的定位给我感觉更像是推理元素的陪衬而非主体，今村昌弘将真正的诡计放在了最后一章内，这一次，诡计的目的是骗过正面无法对抗的「巨人」。在这名为「最后的诡计」的一章里，读者可以看到真凶和侦探合作完成了命中仅此一次的诡计，经由一场刺激的冒险，成功借「巨人」之手取出了遗失的钥匙。在故事的最后，今村昌弘抛出了一个推理小说中鲜少出现的问题：凶手真的是侦探的敌人吗？在「最后的诡计」中，今村昌弘诠释了凶手和侦探之前可能存在的另一种关系。<p align="justify">　　最后小小吐槽一下，一直在读到第三日白天揭晓了记者的真实身份之后，我才发现我把记者这个人物的真实身份连带着把「巨人」的身份都一起弄错了…开篇的内心独白两个人都说得通，两个人名字还挺像，看了下本作的书评，好像也有人提到这个点，出现这种误会，感觉是行文中有刻意误导的缘故，勉强算是一种叙诡了。<h2 id="现实与梦幻之间"><a href="#现实与梦幻之间" class="headerlink" title="现实与梦幻之间"></a>现实与梦幻之间</h2> <p align="justify">　　叶村让和剑崎比留子一起遭遇的三起事件毫无疑问都是悲剧事件，如果说前两作中的悲剧是无辜之人被卷入事件，那么本作的悲剧源头就是「巨人」的存在。本作在九个章节中穿插了四段过往的回忆，尽管描写得比较收敛，但还是得以一窥事件始作俑者班目机构以及本作大恶人不木玄助的罪大恶极——「巨人」是不木玄助在扭曲执念下，通过对孩子进行丧心病狂的人体实验诞生的产物。「巨人」在实验后陷入了严重的精神错乱，永远停留在了若干年前实验事故发生的某个夜晚。在幻听和幻视的影响下，「巨人」将闯入的人类视作怪物，怀抱着想要保护同伴的愿望，在错乱中砍下人类的首级，夺走了无数人的性命。 <p align="justify">　　在故事中，「凶人邸」外面破旧游乐园响起的轻快音乐反复出现：<blockquote><p>　　欢迎来到梦幻城，这里是现实与梦幻之间的乐园。<br>　　大家跟我一起快乐的跳舞吧，直到永夜迎来曙光。</p></blockquote> <p align="justify">　　精神错乱的「巨人」所处的空间正是现实与梦幻之间的永夜，只是这片永夜的实质是一场没有尽头的噩梦，既称不上乐园，也永远不会迎来曙光。 <p align="justify">　　在本作的最后一页里，一名《凶人庄杀人事件》中登场的老角色再次回归，可想而知，今后叶村让和剑崎比留子的调查还会继续，他们还会卷入更多因班目机构的非人道研究而产生的事端之中——希望接下来可以少点残酷，整点更加温情的故事吧，虽然在推理小说中寻找温情像是搞错了什么。 <p align="justify">　　文章的最后，引用豆瓣上看到对于本作的一段短评，寥寥几行字，却比我这篇文章更能体现出《凶人邸杀人事件》这部作品的魅力：   <blockquote><p align="justify">　　在以非正常条件下的密室构建著称之外，还是非常流畅的冒险小说，仅仅从逃生的文字上就嗅到了欲罢不能的气息。和前作类似，这次依然很好地利用了「巨人」的生理特性和心理特征解决了谜题，「巨人」既是天灾又是人祸，它的诞生来源于善良的执念受到腐化，它的活跃既构成了密室又送出了密室的钥匙。安乐椅侦探操纵逻辑与话语，揭开真相，利用真相，引导真实，伪造真实，从孤塔的银狼进化为古堡的魔女。过去的悲剧与结局的HE相互映照，从正反印证了福尔摩斯与华生的相互倾诉与信任才是所向披靡的保证。<p></blockquote><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2> <p align="justify">　　这一篇文章断断续续写了5000多字，属于是有些没有想到。每每写这种作品推荐或者心得体会的文章时，总是会觉得自己大概确实是没有什么写作的天赋，写出来的段落普遍都是差不多毫无美感的句式，用词也相当啰嗦，很多语句都是改了删、删了再改来回好多遍，总感觉不能很好地把自己心里想的传达出来。 <p align="justify">　　嘛，不过这种文字也不会有什么人看，所以倒也可以放心大胆地写，不怕丢人。近期减少了打游戏的时间，拿来写这些个人主页的文章，勉强感觉日常的生活比以往更加充实了一些。很难说这样的变化有什么实质性的意义，但看到这个网站页面地文章慢慢变得充实，多少还是会有一些成就感，今后继续加油吧。]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>推理小说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《死亡终局 轮回试炼》的妥协</title>
    <link href="/2022/10/25/%E6%9D%82%E8%B0%88/%E6%AD%BB%E4%BA%A1%E7%BB%88%E5%B1%80%E8%BD%AE%E5%9B%9E%E8%AF%95%E7%82%BC%E7%9A%84%E5%A6%A5%E5%8D%8F/"/>
    <url>/2022/10/25/%E6%9D%82%E8%B0%88/%E6%AD%BB%E4%BA%A1%E7%BB%88%E5%B1%80%E8%BD%AE%E5%9B%9E%E8%AF%95%E7%82%BC%E7%9A%84%E5%A6%A5%E5%8D%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p align="justify">　　这种因低技术力、低成本、欠打磨等不利客观因素，最终将一款有潜力的游戏做成了令人遗憾的模样的情况，在日厂游戏中并不少见，地雷社这款《死亡终局 轮回试炼》显得尤为典型，甚至让我看到了日常工作时的一些影子。<p></blockquote><span id="more"></span> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p align="justify">　　平心而论，自己不能算是一个地雷社萌豚粉丝，地雷社出品的游戏里，个人打过的只有《碧蓝航线CW》、《神狱塔》系列以及《妖精剑士F》，而且《妖精剑士F》打了个开头就没打下去了。粉丝向的《碧蓝航线CW》一开始就没报什么期望，自然谈不上什么失望。而《神狱塔》系列则远远超出期待，系列三部作品完整地交代了一个连贯有趣的好故事，期间埋下的坑和伏笔也尽数得到解答，结局不留下一丝遗憾。游戏的玩法设计虽远远达不到《鲁弗兰地下迷宫》的高度，作为卖点的鬼捉人系统也过分粗糙，但好歹是小成本制作下，一款有自己的想法并且能称得上比较好玩的好作品——这让我对因玩他家游戏跟排雷一样而“名声在外”的地雷社产生了一些不必要的期待。<p align="justify">　　于是在国庆闲暇之余，趁着PS二档会员还没过期，我开坑了《死亡终局 轮回试炼》。这款游戏由《尸体派对》系列的编剧祁答院慎负责剧本，《神狱塔》系列的画师ナナメダケイ负责角色设计和CG绘制。尽管在国内并没有什么名气，但ナナメダケイ这名看起来像是专职参与地雷社作品的画师在《神狱塔》系列的发挥确实可圈可点：画风辨识度高，算是我喜欢的风格，设计出来的角色普遍形象鲜明。<p align="justify">　　从通关后的感受来看，画师ナナメダケイ的发挥确实没有让我失望，本作的角色设计和CG水平依然维持在不错的水平，祁答院慎的剧本也不能说是没有想法，打桌球的战斗玩法乍一看似乎也有那么点意思…<p align="justify">　　只是偏偏上面任何一条可以让这个游戏显得与众不同的点，本作的制作组都没有做好：CG的水准确实不低，可是游戏里压根就没有几张CG，甚至连大多数角色个人结局的CG都是找个合适的背景把角色立绘往上一贴；剧本设计确实有想法，但游戏的体量显然驾驭不住这么复杂的设定，后期剧情一路暴走，仿佛写作文写到交卷时发现写不完，不得不胡乱收个尾一样，看得人满头问号；主推的击飞敌人清BUG玩法乍一看好像挺有意思，实际击飞的设定进入游戏中期就已经是形同虚设，本质上和传统的站桩回合制几乎就没有区别，除了增加不必要的操作外没有任何用处。<p align="justify">　　上面提到的这些仅仅是这款令人感到遗憾的游戏中比较典型的几个部分。除了CG、剧本以及战斗系统外，《死亡终局 轮回试炼》的其他方方面面也都散布着遗憾的气息：明明很多点子看起来都挺像是那么回事，只需要好好打磨就能变得很有意思，却偏偏因为廉价或者说是糟糕的制作发挥不出应有的效果。<p align="justify">　　基于这种个人游戏历程中相当少见的情况，我很难说《死亡终局 轮回试炼》是一部不值一提，彻底失败的“地雷”作品，在二十多个小时的游玩中，反而是经常感到遗憾和惋惜。用我贫瘠的语言能力来描述的话，可能就是看着别人乱拆炸弹把一手好牌打得稀烂时那种恨铁不成钢的感受。<p align="justify">　　这种因低技术力、低成本、欠打磨等不利客观因素，最终将一款有潜力的游戏做成了令人遗憾的模样的情况，在日厂游戏中并不少见，地雷社这款《死亡终局 轮回试炼》显得尤为典型，甚至让我看到了日常工作时的一些影子。<p align="justify">　　因为实在太过遗憾，所以写下这篇看似游戏测评，实际上也不知道算不算是测评的文章，当作给这款经典遗憾系地雷社游戏作品做个留念罢。<p><div class="note note-danger">            <p><strong>警告</strong><br>接下来会含有大量对游戏《死亡终局 轮回试炼》剧情的剧透。<br>剧透包括故事的主要情节脉络与核心设计。<br>如果对这款游戏尤其是剧情感兴趣，请不要往下阅读本篇文章。</p>          </div><h2 id="戛然而止的剧情"><a href="#戛然而止的剧情" class="headerlink" title="戛然而止的剧情"></a>戛然而止的剧情</h2><p align="justify">　　用戛然而止来形容《死亡终局 轮回试炼》的剧情可能再合适不过了。<p align="justify">　　从总体结构上看，本作剧情是比较经典的双线式展开：被卷入事件，意识进入未完成「游戏世界」的二之宫椎菜在旅程中与其他NPC角色们结识，并一同展开拯救世界的冒险；游戏程序员水梨新与同事们在「现实世界」中寻找线索，修改游戏代码，消除BUG，帮助椎菜通关后可以顺利登出游戏。<p align="justify">　　在「游戏世界」的冒险中，椎菜与同伴们持续性地发现仅应存在于「现实世界」的违和物件；在「现实世界」对这些物件进行调查时，新持续不断地遭遇超自然的事件：从天而降的尸体，藏身于出租屋暗处的杀人鬼，散布诅咒的人偶，与自己完全一样的二重身…<p align="justify">　　每次铤而走险的调查最终都指向一段神秘的代码碎片，将代码碎片运用于游戏程序后，可以解决「游戏世界」内妨碍椎菜通关游戏的未知BUG。在新和椎菜为了通关游戏、脱离危险而努力的同时，他们逐渐发现了所谓「游戏世界」背后的秘密和阴谋，而与此同时，反派势力也在开始展开行动…简单来说，《死亡终局 轮回试炼》大概就是这样的故事。<p align="justify">　　就个人体验过的作品中，多视角多场景的故事框架并不少见，光同为地雷社本社制作的《神狱塔 Finale》就使用了这种设计：主角团会被划分为三个队伍，各个队伍会有独立的剧情事件，需要在探索过程中通过操作机关，帮助其他两队得以前进并最终汇合。在《死亡终局 轮回试炼》里，「游戏世界」的BUG会以无法打开的门，或者空气墙的模式阻挡在椎菜和队友们面前，这就需要将视角切换到新在现实世界中触发剧情，获得代码，才能让挡路的障碍消失。两个游戏在玩法上的情节推进方式几乎是完全一样的。<p align="justify">　　言归正传，早在游戏最前期的几章故事中，《死亡终局 轮回试炼》主要埋下了几个疑问，这些疑问直接关乎到故事的核心：椎菜是怎么进入「游戏世界」的？是谁绑架了椎菜让她被困在「游戏世界」中无法脱离？为什么「游戏世界」内会被放入「现实世界」才有的物件？新在「现实世界」中会遇到各种无法用科学解释的超自然现象要如何解释？这些超自然现象又如何生成能解决「游戏世界」BUG的代码？故事最一开始，椎菜在「游戏世界」内被杀死的情景是怎么一回事？<p align="justify">　　当现实物件在剧情前几章中出现，并将两个世界关联起来后，故事的悬念就已经形成。<p align="justify">　　按理来说，这些悬念应当在之后的故事里面逐步揭开，最终得到一个圆满的解答，可是玩家在游戏长期的推进中，只能看到这些悬念一次又一次被重复地抛出，几乎没有有关上述悬念的新线索：在皇宫里，椎菜遇到了王国的公主NPC莉莉，与莉莉成为队友后，捡到了现实物件日记；在造船厂里，椎菜遭遇了想要成为冒险家的NPC阿尔，与阿尔成为队友后，捡到了现实物件报纸；在遗迹里，椎菜遭遇了商人NPC柯丽雅，与柯丽雅成为队友后，捡到了现实物件照片…<p align="justify">　　游戏前中期的每一章故事都是这样的单元剧架构：遇到新NPC，发生事件，NPC作为同伴加入队伍，探索途中发现现实物件，在调查现实物件时遭遇怪异的超自然现象，并找到神秘代码修复BUG，就这样一遍又一遍循环。循环到故事进入中后期，按理来说也该开始揭露真相了，可剧本开始又侧重于「游戏世界」里NPC队友们的描写：所谓的NPC其实都是「现实世界」里真实存在的人，被绑架以NPC的身份进入了「游戏世界」，并融入了作为「游戏世界」里NPC的自我。每位NPC都受到巴咕生命体的影响失去了一种应有的感情：阿尔失去了悲伤的感情、露西尔失去了喜悦的感情…剧情又变成了每章寻回一种感情的二度单元剧。<p align="justify">　　NPC是「现实世界」真实存在过的人物并被剥夺了一种感情早在前期就已经有了明确的伏笔，所以这一阶段的剧情显得相当俗套也并不会让人感到意外。作为玩家，我更在意的是谜语人形象的卢登斯是什么定位、现实物件与超自然现象如何关联，遗憾的是剧情即使到了后期也没有相关的线索，反而是抛出了更多的谜题：新在调查现实物件时偶然目睹了同事莉迪亚杀人的过程，莉迪亚可能就是留下游戏代码的神秘人；而另一位前同事绪方潜入明显有着黑幕的游戏引擎公司，却中计在敌人大本营被捕…<p align="justify">　　按照正常的剧本设计，故事在这里应当进入高潮，将伏笔悉数回收，深度展开剧情同时给到真相大白的痛快感，可怎能料到，在游戏第10-11章也就是最后两章中，故事却以始料未及的超高速戛然而止。<p align="justify">　　在这短短两章的内容里：队友赛丽卡以降智的理由跳反，打出了一波NPC队友的团灭；莫名其妙「现实世界」与「游戏世界」就融合到了一起，让「游戏世界」的怪物出现在「现实世界」中大肆破坏；幕后黑手的引擎公司揭露了自己的计划，尽管完全不理解他们到底想搞什么，总之他们连同「现实世界」中新的同事们一起莫名其妙地领了便当；作为事件核心的「情报生命」同时也是谜语人卢登斯们侍奉地对象爱丽丝莫名其妙地黑化、接着莫名其妙地在被主角团打倒后恢复了正常；莉迪亚再次出现表明自己的真实身份，但依然没有说明白她之前杀人的行为和留下代码的前因后果…<p align="justify">　　这如同脱缰野马一路狂飙的剧情过到最后，玩家才会惊奇地发现，《死亡终局 轮回试炼》这款游戏是类似于《命运石之门》的轮回系作品，且涵盖了《史丹利的寓言》既视感的META元素，可以称得上是实实在在的元游戏：水梨新作为他自己认知中「现实世界」的一份子，在挖掘「游戏世界」秘密的最后阶段，终于发现两个世界实则都是《死亡终局 轮回试炼》这款游戏的一部分，于是向游戏之外、且有着更高权能的高维生物也就是玩家发起求助，希望玩家可以主动介入《死亡终局 轮回试炼》这款游戏，帮助他在《死亡终局 轮回试炼》的世界中达成没有任何人牺牲的最好结局，甚至连《死亡终局 轮回试炼》这个名字都是他取的，目的是为了吸引玩家来帮助他达成他所期望的HAPPY END。包括故事一开始椎菜被最终BOSS杀害在内，游戏里充斥着大量意义不明的，二选一选错选项就会GAME OVER的「死亡结局」，这就需要玩家反复的读档，在一次次轮回中帮助新做出正确的选择，这就是「轮回试炼」。<p align="justify">　　通关后回顾整个剧本的构思，无论是现实中的游戏、游戏中的现实以及游戏中的游戏，一共三个世界的嵌套，还是游戏主角向现实世界的玩家求助、结局好坏全看玩家愿不愿意帮忙的情节，抑或是大量BAD END设计与游戏标题的呼应，虽说很难谈得上创新，但至少都是比较有趣的想法，然而这些有趣想法在故事里的呈现，虽不能称得上是水到渠成吧，只能算是相当突兀：最后一路狂飙的两章剧情虽然回收了大量的伏笔，但大多回收得无比僵硬，比方说真结局交代现实物件是主角新在先前的轮回中自己放进游戏的，目的是为了提醒自己身处一次次的轮回，但我怎么也想不明白现实物件如何起到这样的作用，而且与现实世界直接关联的超自然现象完全联系不起来。故事在中后期为了强调其他角色给每个NPC队友角色设计了一段找回感情的戏码，在有限的剧情篇幅和极其薄弱的演出下（几乎就没有几张CG），情绪和气氛上的渲染完全不到位，只是流水线式地给每个角色跑一边过场，以至于最后最终战明明是很王道的剧情，却丝毫调不起玩家的兴致。明明剧本篇幅已经很有限了，中期还设计了一个从其他游戏里穿越来、画风迥异的彩蛋役角色，本以为后面会有什么特别的展开，结果客串了几次就没有一点后文了。大量的BAD END是剧情设计的核心之一，但处理得却相当草率，普遍都是摆出两个简单的选项，选错就GAME OVER，几乎没有任何逻辑性，完全丢失了「死亡结局」应有的沉重感，显得特别廉价。游戏的结局也是突出一个坑爹，除了女主人公椎菜的结局（可以算真结局）比较详细地交代了故事的后续外，其他个人结局就像是硬凑个数一样，廖廖几行字配一个把背景和人物立绘贴一起的超廉价CG，尤其莉迪亚的个人结局，我一周目触发的这个结局，真的给我气笑了。<p align="justify">　　近年来玩的日呆游戏，剧情能称得上优秀的实在不多，但让我体会到遗憾这种情绪的，《死亡终局 轮回试炼》大概是独一无二的特别。虽然刚开始玩就知道游戏制作很廉价，但前期超自然事件的包装以及顺畅的剧情过度十足拉高了对剧本的期望值，当期望值在流程中后期达到顶峰时，突如其来的结局直接杀了个措手不及，一波打出GG，这都算不上高开低走，反而像是直接腰斩了。剧本很有想法、角色很有魅力，但是这些魅力还没来得及展示出来，游戏就结束了。若能放缓节奏，更耐心地把这个故事讲完，适当追加更多的CG，本应能成为一款优秀的作品，只是可惜没有如果。<p><h2 id="灾难般的完成度"><a href="#灾难般的完成度" class="headerlink" title="灾难般的完成度"></a>灾难般的完成度</h2><p align="justify">　　前面大篇幅描述了游戏在剧本和CG方面的缺憾，但比较讽刺的是，剧本、CG以及音乐等游离于游戏Gameplay外的元素，已经是这款游戏完成度最高的部分了。相比之下，游戏的RPG玩法部分的完成度堪称灾难。一般形容一个游戏作品没做完就拿出去卖，都会叫半成品，但我总觉得半成品不能够恰到好处地形容明白这游戏在制作上的完成度之低，所以我决定超级减半再减半，叫他八分之一成品吧。<p align="justify">　　比较直接的体现是看似有所创新的战斗系统，游戏使用JRPG常见的第三人称迷宫式地图探索+明雷遇敌玩法，遇敌后会进入一场看起来不太像回合制其实就是回合制的战斗。玩家根据行动顺序轴依次操作队伍中的三名角色移动并执行指令，然后结束行动。因为牵扯到战斗场地和移动的概念，玩家需要做的就是让角色移动到合理的位置释放合理的范围技能，尽可能覆盖到更多的怪物，打出更高的伤害。<p align="justify">　　战斗中与之配套同时也是卖点的是击飞系统，玩家操作角色进行攻击类指令时，在收招后会产生一个击退效果，即沿着攻击弹道将怪物击飞一段距离，被击飞的怪物碰撞到场地边缘、或碰撞到其他怪物及友方角色时，又会产生二次击飞，造成更多的额外伤害，有点打桌球的既视感。为了突出这套击飞系统的深度，游戏又加入了BUG和污染度的概念，战斗场地会有大量的BUG地块，玩家操作角色移动时，若踩到BUG地块就会增加污染度，当污染度爆表后，角色会直接暴毙。战场中BUG地块的数量决定环境污染度，当环境污染度降低至50%以下后，玩家就可以让负责支援的主角新改变游戏类型，或召唤之前击败的BOSS作为友方加入战场。除了操作角色直接踩上去以外，另一个消除BUG地块的方式就是让怪物被击飞，怪物在击飞过程中会消除沿途经过的BUG地块，降低环境污染度。<p align="justify">　　乍一看这套战斗系统还挺有新意，挺美好的，只是游戏极其糟糕的制作水平完全没能把这套系统的魅力体现出来。<p align="justify">　　首先是击飞弹道的判定，击飞怪物遵循一般逻辑，即怪物被击飞的方向是玩家操作角色释放攻击技能方向的延伸，可战斗中根本没有给到足够的信息告知玩家敌人在出招后被击飞的弹道（甚至连射击类技能的瞄准弹道都非常模糊），不管是击飞距离还是击飞方向全凭玩家个人感觉，多数时候实际的击飞效果与预期会产生一定的偏差，明明感觉能撞到，结果方向却偏了一点，一次击飞后产生多次连锁击飞的场面可能只存在于理论上。前期还能看着怪弹来弹去，到了游戏中后期，敌人强度提升后，很多怪物的脚底仿佛跟抹了502胶水一样突出一个不动如山，击飞系统形同虚设。另外那个看起来蛮有意思的所谓改变游戏类型的玩法，也像是个纯纯的噱头：以射击游戏类型为例，触发后玩家需要在第一人称射击游戏的模式下，在静止的战斗场景中瞄准敌人射出若干发子弹，低帧数加持下僵硬的射击镜头和迷之弹道让射击的手感变得无穷蹩脚；而格斗游戏的玩法变更其实就是把UI换成格斗游戏那种1V1的版式，然后玩家连按两个按键单方面殴打怪物罢了，只是做做样子看起来像是这么一回事。<p align="justify">　　游戏的关卡设计则更是重量级，典型的是游戏最开始的两块区域即皇宫和造船厂，这两块区域充斥着大量不可通过的半透明空气墙，而小地图里对此不做任何的标注，跑了两个周目都还是会在里头找不到路。皇宫区域有大量打不开的门，因为缺少合理的地图标注，玩家既不知道哪扇门打开后是正确的路，也不知道开门需要的钥匙在哪里，即使拿到钥匙后，也不知道新拿到的钥匙能打开之前哪扇打不开的门。造船厂区域中有两处可以调整水位的隐蔽开关，一般按照惯例，多半是什么隐藏道路或者触发剧情的正路，实际打到最后发现就是多一片区域出来多开个不值钱的宝箱…游戏进入后期后，地图设计直接弃疗，不搞机制，基本上都是一条直道，比较讽刺的是这样搞游戏体验反而好起来了。<p align="justify">　　支线任务的设计更是让人大开眼界，游戏里有三栏支线任务，支线任务不涉及任何剧情，前两栏分别是杀特定怪和采集特定素材，之所以不提第三栏是因为直到通关第三栏都没有一个任务。杀怪任务前期是一章出一个新的，结果到了第五章之后就没有了。采集任务需求的素材很多出率都比较低，早期为了完成我还刻意来回搜刮了几遍地图，结果到了最后一章才发现所有的素材都可以直接花钱买…最牛逼的是这些明显就是在摆烂的支线任务，居然和游戏的结局直接相关，如果在通关前未能将绝大多数的支线任务完成，就只能进入普通结局，单从剧情的逻辑上是完全没有任何道理的。<p align="justify">　　游戏完成度如此之低，要我说还不如直接把RPG部分砍了，经费全放在剧情、CG以及相关演出上，做成一款纯AVG游戏，兴许这样，这款游戏反而可以获得更高的评价和质量吧，只是可惜没有如果。<p><h2 id="到头来都是妥协"><a href="#到头来都是妥协" class="headerlink" title="到头来都是妥协"></a>到头来都是妥协</h2><p align="justify">　　写到最后莫名有感而发，尽管可能只是一厢情愿，但我还是更愿意相信《死亡终局 轮回试炼》之所以做成这样，是各种客观不利因素作用下的妥协：程序技术力有限，只能更加关注于角色的建模和动作，所以大地图探索的RPG部分只能降低标准，勉强能跑就行；开发规模有限，驾驭不住庞大的剧情构思，所以RPG部分连带着剧情只能仓促收尾；开发成本有限，所以整体制作才会看起来这么廉价，连CG都舍不得多画几张…<p align="justify">　　虽然做的完全不是同一类游戏，但姑且作为一名游戏行业的从业者，平时工作中确实也处处存在着这种妥协。因为技术能力不行，很多构思无法实现，相当一部分策划案转入开发、再到落地后，往往是面目全非。因为项目顺位不高，公共部门能给予的支持有限，不少需求的优先级都一降再降，甚至不考虑排期开发。因为项目管理混乱，研发产能有限，重要功能的上线经常一拖再拖，每次游戏更版都在死线上冲刺，也没有足够的测试保障。<p align="justify">　　包括我自己在工作中，可能也在习惯性地一直妥协，因为成本有限、因为开发规模有限、因为技术力有限，我总是会给自己找这样的借口，然后将牵扯到我的各种工作无意义化，以敷衍的态度草草了事。我毫不觉得这样做有什么问题，毕竟当一项明摆着不可能落地的需求案落到我头上时，就算我拼尽全力去完成，又有什么用呢？只是白费功夫罢了。同样是技术能力不足，开发规模有限，游戏赶鸭子上架，或许《死亡终局 轮回试炼》的一般开发者也是这样的妥协心态，结果就是作为让作为玩家的我体会到了难得的遗憾。<p align="justify">　　近期被领导各种拷打，说我做任何事情总是会差一口气，我想这所谓的一口气其实就是因为我太擅长妥协了。用蹩脚的文笔写下这篇文章时，我依然不明白这样的妥协是否算是正确的选择，可能今后对待目前这份工作，我还是会采用一样的态度，毕竟我并不喜欢手头的这款游戏与这份工作，项目也实在不像是能做出点名堂的样子，怕是明年就寄了。但有时又会转念一想，这样真的好吗？如果今后有机会为自己真正支持着的游戏出一份力，希望可以试试以全力以赴而不是妥协的姿态努力一把，玩家会不会遗憾不重要，重要的是希望自己不要留下遗憾吧。<p align="justify">　　最后放一张阿尔结局的CG，说是CG其实就是张立绘贴图，但这个角色真的挺可爱的。<p><p><img src="/Imgpost/%E6%9D%82%E8%B0%88/%E6%AD%BB%E4%BA%A1%E7%BB%88%E5%B1%80end.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主机游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL50题（31-50题）</title>
    <link href="/2022/10/22/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8831-50%E9%A2%98%EF%BC%89/"/>
    <url>/2022/10/22/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8831-50%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="31-到-50-题"><a href="#31-到-50-题" class="headerlink" title="31 到 50 题"></a>31 到 50 题</h2><h3 id="31-查询课程编号为01且课程成绩在80分以上的学生的学号和姓名"><a href="#31-查询课程编号为01且课程成绩在80分以上的学生的学号和姓名" class="headerlink" title="31 查询课程编号为01且课程成绩在80分以上的学生的学号和姓名"></a>31 查询课程编号为01且课程成绩在80分以上的学生的学号和姓名</h3><div class="note note-info">            <p><strong>说明</strong><br>源数据里压根就没有超过80分的，会查出来空。<br>为了避免这个情况默认等于80也算80分以上了，有点坑。</p>          </div><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SELECT <span class="hljs-keyword">SC.SId, </span>Sname<br>FROM <span class="hljs-keyword">SC, </span>Student<br>WHERE <span class="hljs-keyword">SC.SId </span>=Student.SId<br><span class="hljs-keyword">AND </span>CId = <span class="hljs-string">&#x27;01&#x27;</span> <br><span class="hljs-keyword">AND </span><span class="hljs-keyword">score </span>&gt;= <span class="hljs-number">80</span>;<br></code></pre></td></tr></table></figure><h3 id="32-求每门课程的学生人数"><a href="#32-求每门课程的学生人数" class="headerlink" title="32 求每门课程的学生人数"></a>32 求每门课程的学生人数</h3><div class="note note-info">            <p><strong>说明</strong><br>总感觉这题前面好像出现过…</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> CId, <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CId<br></code></pre></td></tr></table></figure><h3 id="33-成绩不重复，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩"><a href="#33-成绩不重复，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩" class="headerlink" title="33 成绩不重复，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩"></a>33 成绩不重复，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</h3><div class="note note-info">            <p><strong>说明</strong><br>INNER JOIN联结全部四张表之后用ORDER BY降序排序成绩。<br>因为是取成绩最高，所以使用LIMIT 1选取排在最前面的一条数据。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.*, Score <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span> SC.CId = Course.CId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Teacher <span class="hljs-keyword">ON</span> Course.TId = Teacher.TId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Student <span class="hljs-keyword">ON</span> SC.SId = Student.SId<br><span class="hljs-keyword">WHERE</span> Tname = <span class="hljs-string">&#x27;张三&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="34-成绩有重复的情况下，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩"><a href="#34-成绩有重复的情况下，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩" class="headerlink" title="34 成绩有重复的情况下，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩"></a>34 成绩有重复的情况下，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩</h3><div class="note note-info">            <p><strong>说明</strong><br>本题假设最高成绩存在重复的情况，无法得知同分人数有几人，因此不能像上题一样，再使用LIMIT截取数据。<br>替代方法是先按上题的代码查询出最高成绩的具体分数，作为子查询，嵌套进一个新的SELECT语句中。<br>在新的SELECT语句中查询老师是张三，且成绩和先前查询出的最高分数一致的学生信息，可以达成要求。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.*, Score <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span> SC.CId = Course.CId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Teacher <span class="hljs-keyword">ON</span> Course.TId = Teacher.TId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Student <span class="hljs-keyword">ON</span> SC.SId = Student.SId<br><span class="hljs-keyword">WHERE</span> Tname = <span class="hljs-string">&#x27;张三&#x27;</span><br><span class="hljs-keyword">AND</span> score = (<br><span class="hljs-keyword">SELECT</span> Score <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span> SC.CId = Course.CId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Teacher <span class="hljs-keyword">ON</span> Course.TId = Teacher.TId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Student <span class="hljs-keyword">ON</span> SC.SId = Student.SId<br><span class="hljs-keyword">WHERE</span> Tname = <span class="hljs-string">&#x27;张三&#x27;</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span><br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="35-查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩"><a href="#35-查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩" class="headerlink" title="35 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩"></a>35 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩</h3><div class="note note-danger">            <p><strong>说明</strong><br>难题，本题最简单的思路是通过自联结SC表，构建出一个学生ID对应两门课成绩的新表。<br>然后在这个新表中加入课程ID不同（确保是两门不同的课）及分数相同的过滤条件。<br>特别注意因为使用了自联结所以会重复生成相同的数据，需要使用DISTINCT去重，最终达成目的。</p>          </div><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SELECT <span class="hljs-keyword">DISTINCT </span>A.* FROM <span class="hljs-keyword">SC </span>AS A<br>INNER <span class="hljs-keyword">JOIN </span><span class="hljs-keyword">SC </span>AS <span class="hljs-keyword">B </span>ON A.SId =<span class="hljs-keyword">B.SId</span><br><span class="hljs-keyword"></span>WHERE NOT A.CId = <span class="hljs-keyword">B.CId</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">AND </span>A.<span class="hljs-keyword">score </span>=  <span class="hljs-keyword">B.score</span><br></code></pre></td></tr></table></figure><h3 id="36-查询每门功课成绩最好的前两名"><a href="#36-查询每门功课成绩最好的前两名" class="headerlink" title="36 查询每门功课成绩最好的前两名"></a>36 查询每门功课成绩最好的前两名</h3><div class="note note-info">            <p><strong>说明</strong><br>和18题完全一样，改个数字就成…</p>          </div><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span> *, RANK() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> CId <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> C_RANK<br><span class="hljs-keyword">FROM</span> SC) <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">WHERE</span> C_RANK &lt;= <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><h3 id="37-统计每门课程的学生选修人数（超过5人的课程才统计）。"><a href="#37-统计每门课程的学生选修人数（超过5人的课程才统计）。" class="headerlink" title="37 统计每门课程的学生选修人数（超过5人的课程才统计）。"></a>37 统计每门课程的学生选修人数（超过5人的课程才统计）。</h3><div class="note note-info">            <p><strong>说明</strong><br>GROUP BY和聚合函数的简单运用。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> CId, <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CId<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(SId) &gt; <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="38-检索至少选修两门课程的学生学号"><a href="#38-检索至少选修两门课程的学生学号" class="headerlink" title="38 检索至少选修两门课程的学生学号"></a>38 检索至少选修两门课程的学生学号</h3><div class="note note-info">            <p><strong>说明</strong><br>依然是GROUP BY和聚合函数的简单运用。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SId, <span class="hljs-built_in">COUNT</span>(CId) <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SId<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(CId) &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="39-查询选修了全部课程的学生信息"><a href="#39-查询选修了全部课程的学生信息" class="headerlink" title="39 查询选修了全部课程的学生信息"></a>39 查询选修了全部课程的学生信息</h3><div class="note note-info">            <p><strong>说明</strong><br>用子查询先查总课程的数目，再检索学习课程数目等于前一次查询结果的学生信息。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.* <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Student <span class="hljs-keyword">ON</span> SC.Sid =Student.SId<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SId <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(CId) =(<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(CId) <span class="hljs-keyword">FROM</span> Course);<br></code></pre></td></tr></table></figure><h3 id="40-查询各学生的年龄，只按年份来算"><a href="#40-查询各学生的年龄，只按年份来算" class="headerlink" title="40 查询各学生的年龄，只按年份来算"></a>40 查询各学生的年龄，只按年份来算</h3><div class="note note-info">            <p><strong>说明</strong><br>因为只按年份来算，用当前年份减去Sage的年份就行。<br>返回当前时间用NOW()，返回年份用YEAR()。</p>          </div><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> SId, <br><span class="hljs-meta">YEAR</span>(NOW()) - <span class="hljs-meta">YEAR</span>(Sage) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;年龄&#x27;</span><br><span class="hljs-keyword">FROM</span> Student;<br></code></pre></td></tr></table></figure><h3 id="41-按照出生日期来算，当前月日-lt-出生年月的月日，则年龄减一"><a href="#41-按照出生日期来算，当前月日-lt-出生年月的月日，则年龄减一" class="headerlink" title="41 按照出生日期来算，当前月日&lt;出生年月的月日，则年龄减一"></a>41 按照出生日期来算，当前月日&lt;出生年月的月日，则年龄减一</h3><div class="note note-danger">            <p><strong>说明</strong><br>难题，比较暴力的方式是使用CASE WHEN，比较当前月日和出生年月的月日。<br>如果当前月比出生月大（或当前月与出生月相同，但当前日大于出生日），说明当前月日大于出生月日。<br>那么和上题一样直接相减年份就行。<br>反之，当前月日小于出生月日，不够1岁，因此需要在相减年份后再将岁数-1。<br>这种处理方式比较复杂。<br>另一种方式是直接用TIMESTAMPDIFF函数，用法为TIMESTAMPDIFF(YEAR,日期1,日期2）。<br>可以求出两个日期之间的年份差（也可以求月份差和日期查，将YEAR替换成MONTH和DAY就可以）。</p>          </div><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vbscript"><span class="hljs-keyword">SELECT</span> Sname,<br><span class="hljs-keyword">CASE</span> WHEN <span class="hljs-built_in">MONTH</span>(<span class="hljs-built_in">NOW</span>()) &gt; <span class="hljs-built_in">MONTH</span>(Sage) <span class="hljs-keyword">OR</span><br>( <span class="hljs-built_in">MONTH</span>(Sage) = <span class="hljs-built_in">MONTH</span>(<span class="hljs-built_in">NOW</span>()) <span class="hljs-keyword">AND</span> <span class="hljs-built_in">DAY</span>(<span class="hljs-built_in">NOW</span>()) &gt; <span class="hljs-built_in">DAY</span>(Sage) )<br><span class="hljs-keyword">THEN</span> <span class="hljs-built_in">YEAR</span>(<span class="hljs-built_in">NOW</span>()) - <span class="hljs-built_in">YEAR</span>(Sage) <br><span class="hljs-keyword">ELSE</span> <span class="hljs-built_in">YEAR</span>(<span class="hljs-built_in">NOW</span>()) - <span class="hljs-built_in">YEAR</span>(Sage) <span class="hljs-number">-1</span> <span class="hljs-keyword">END</span>  <br>AS <span class="hljs-comment">&#x27;年龄&#x27;</span><br>FROM Student;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> Sname, <br>TIMESTAMPDIFF(YEAR, Sage, NOW()) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;年龄&#x27;</span><br><span class="hljs-keyword">FROM</span> Student;<br></code></pre></td></tr></table></figure><h3 id="42-查询本周过生日的学生"><a href="#42-查询本周过生日的学生" class="headerlink" title="42 查询本周过生日的学生"></a>42 查询本周过生日的学生</h3><div class="note note-info">            <p><strong>说明</strong><br>用WEEK函数返回日期是一年中的第几周。<br>另外这个做法不是很严谨。<br>因为给到的学生出生日期带有年份，用WEEK()返回周数返回的是当年的周数。<br>而当年的周数和今年的周数未必是相等的，所以返回的数据会有错误。<br>更合理的方法是使用SUBSTRING函数提取出Sage中的月份和日期部分，再用CONTACT和今年年份拼接。<br>可以更严谨地达成查询目的。</p>          </div><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">SELECT</span> <span class="hljs-variable">Sname</span> <span class="hljs-variable">FROM</span> <span class="hljs-variable">Student</span><br><span class="hljs-variable">WHERE</span> <span class="hljs-function"><span class="hljs-title">WEEK</span>(<span class="hljs-variable">Sage</span>) = <span class="hljs-title">WEEK</span>(<span class="hljs-title"><span class="hljs-built_in">NOW</span></span>()) ;</span><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> Sname <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> WEEK(CONTACT(<span class="hljs-string">&#x27;2022-&#x27;</span>, SUBSTRING(Sage, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>))) =WEEK(NOW());<br></code></pre></td></tr></table></figure><h3 id="43-查询下周过生日的学生"><a href="#43-查询下周过生日的学生" class="headerlink" title="43 查询下周过生日的学生"></a>43 查询下周过生日的学生</h3><div class="note note-info">            <p><strong>说明</strong><br>在上一题的基础上+1，使用SUBSTRING的更严谨方案不赘述了。<br>虽然但是，这样还是不够严谨，在当前日期为一年最后一周的时候，下一周学生是在第二年过生日。<br>这种情况下，上述的代码是无法将这类生日日期的学生过滤出来的，具体怎么处理可以看45题。</p>          </div><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">SELECT</span> <span class="hljs-variable">Sname</span> <span class="hljs-variable">FROM</span> <span class="hljs-variable">Student</span><br><span class="hljs-variable">WHERE</span> <span class="hljs-function"><span class="hljs-title">WEEK</span>(<span class="hljs-variable">Sage</span>) = <span class="hljs-title">WEEK</span>(<span class="hljs-title"><span class="hljs-built_in">NOW</span></span>())+<span class="hljs-number">1</span> ;</span><br></code></pre></td></tr></table></figure><h3 id="44-查询本月过生日的学生"><a href="#44-查询本月过生日的学生" class="headerlink" title="44 查询本月过生日的学生"></a>44 查询本月过生日的学生</h3><div class="note note-info">            <p><strong>说明</strong><br>用MONTH函数求月份，这题纯凑数啊。</p>          </div><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-keyword">SELECT</span> Sname <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-meta">MONTH</span>(Sage) = <span class="hljs-meta">MONTH</span>(NOW());<br></code></pre></td></tr></table></figure><h3 id="45-查询下月过生日的学生"><a href="#45-查询下月过生日的学生" class="headerlink" title="45 查询下月过生日的学生"></a>45 查询下月过生日的学生</h3><div class="note note-info">            <p><strong>说明</strong><br>当前月份为12月且学生生日在1月的情况下，直接在上题基础上+1不能达成目的，会略过这些1月过生日的学生。<br>所以本题在WHERE中加入CASE WHEN语句罗列出生月份在1月且当月为12月的情况。</p>          </div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> Sname <span class="hljs-keyword">FROM</span> Student <span class="hljs-keyword">WHERE</span> <br><span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">MONTH</span>(NOW()） <span class="hljs-operator">=</span><span class="hljs-number">12</span> <span class="hljs-keyword">THEN</span> <span class="hljs-keyword">MONTH</span>(Sage) <span class="hljs-operator">=</span><span class="hljs-number">1</span><br><span class="hljs-keyword">ELSE</span> <span class="hljs-keyword">MONTH</span>(Sage) <span class="hljs-operator">=</span><span class="hljs-keyword">MONTH</span>(NOW())<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL50题（21-30题）</title>
    <link href="/2022/10/21/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8821-30%E9%A2%98%EF%BC%89/"/>
    <url>/2022/10/21/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8821-30%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="21-到-30-题"><a href="#21-到-30-题" class="headerlink" title="21 到 30 题"></a>21 到 30 题</h2><h3 id="21-查询男生、女生人数"><a href="#21-查询男生、女生人数" class="headerlink" title="21 查询男生、女生人数"></a>21 查询男生、女生人数</h3><div class="note note-info">            <p><strong>说明</strong><br>直接用GROUP BY对Ssex分组后Count学生ID的数量即可。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Ssex, <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Ssex;<br></code></pre></td></tr></table></figure><h3 id="22-查询名字中含有「风」字的学生信息"><a href="#22-查询名字中含有「风」字的学生信息" class="headerlink" title="22 查询名字中含有「风」字的学生信息"></a>22 查询名字中含有「风」字的学生信息</h3><div class="note note-info">            <p><strong>说明</strong><br>使用LIKE在风字前后各加一个%通配符。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">WHERE</span> Sname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%风%&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="23-查询同名同性学生名单，并统计同名人数"><a href="#23-查询同名同性学生名单，并统计同名人数" class="headerlink" title="23 查询同名同性学生名单，并统计同名人数"></a>23 查询同名同性学生名单，并统计同名人数</h3><div class="note note-info">            <p><strong>说明</strong><br>按学生的姓名分组，求和之后用HAVING过滤出同名人数大于1的姓名。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Sname, <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Sname <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(SId) &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="24-查询1990年出生的学生名单"><a href="#24-查询1990年出生的学生名单" class="headerlink" title="24 查询1990年出生的学生名单"></a>24 查询1990年出生的学生名单</h3><div class="note note-info">            <p><strong>说明</strong><br>使用YEAR函数提取出Sage字段中的年份，用WHERE进行过滤。</p>          </div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">YEAR</span>(Sage) <span class="hljs-operator">=</span> <span class="hljs-number">1990</span>;<br></code></pre></td></tr></table></figure><h3 id="25-查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列"><a href="#25-查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列" class="headerlink" title="25 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列"></a>25 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列</h3><div class="note note-info">            <p><strong>说明</strong><br>两层排序，AVG(score)用DESC降序，升序用ASC，因为不写默认升序，所以可以不写。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> CId, <span class="hljs-built_in">AVG</span>(score) <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CId<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">AVG</span>(score) <span class="hljs-keyword">DESC</span>, CId;<br></code></pre></td></tr></table></figure><h3 id="26-查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩"><a href="#26-查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩" class="headerlink" title="26 查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩"></a>26 查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩</h3><div class="note note-info">            <p><strong>说明</strong><br>需要学生姓名，所以等值联结SC和Student两张表。<br>平均成绩依然是用GROUP BY按学生ID分组后使用AVG函数统计。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SC.SId, Sname, <span class="hljs-built_in">AVG</span>(score) <span class="hljs-keyword">FROM</span> SC, Student<br><span class="hljs-keyword">WHERE</span> SC.SId = Student.SId<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SId<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(score) &gt;= <span class="hljs-number">85</span>;<br></code></pre></td></tr></table></figure><h3 id="27-查询课程名称为「数学」，且分数低于60的学生姓名和分数"><a href="#27-查询课程名称为「数学」，且分数低于60的学生姓名和分数" class="headerlink" title="27 查询课程名称为「数学」，且分数低于60的学生姓名和分数"></a>27 查询课程名称为「数学」，且分数低于60的学生姓名和分数</h3><div class="note note-info">            <p><strong>说明</strong><br>需要学生姓名，分数以及课程名称的信息所以涉及到三张表格的联结。<br>代码使用等值联结，当然本题也可以用子查询和INNER JOIN完成。</p>          </div><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SELECT Sname, Cname, <span class="hljs-keyword">score </span>FROM <span class="hljs-keyword">SC, </span>Student, Course<br>WHERE <span class="hljs-keyword">SC.SId </span>= Student.SId<br><span class="hljs-keyword">AND </span><span class="hljs-keyword">SC.CId </span>= Course.CId<br><span class="hljs-keyword">AND </span>Cname = <span class="hljs-string">&#x27;数学&#x27;</span><br><span class="hljs-keyword">AND </span><span class="hljs-keyword">score </span>&lt; <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><h3 id="28-查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）"><a href="#28-查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）" class="headerlink" title="28 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）"></a>28 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）</h3><div class="note note-info">            <p><strong>说明</strong><br>即使没有成绩也要把学生ID和姓名显示出来，所以使用LEFT JOIN保留Student表格的信息。<br>这样没有成绩的学生在联结后会显示为NULL，满足题目的要求。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.SId, Sname, CID, score <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> Student.SId = SC.SId;<br></code></pre></td></tr></table></figure><h3 id="29-查询任何一门课程成绩在70分以上的姓名、课程名称和分数"><a href="#29-查询任何一门课程成绩在70分以上的姓名、课程名称和分数" class="headerlink" title="29 查询任何一门课程成绩在70分以上的姓名、课程名称和分数"></a>29 查询任何一门课程成绩在70分以上的姓名、课程名称和分数</h3><div class="note note-info">            <p><strong>说明</strong><br>涉及到学生姓名，成绩及课程名称所以需要联结三张表。<br>代码中使用的是INNER JOIN，当然也可以使用语法更简单的等值联结。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Sname, Cname, score <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Student <span class="hljs-keyword">ON</span> SC.SId = Student.SId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span> SC.CId =Course.CId<br><span class="hljs-keyword">WHERE</span> score &gt; <span class="hljs-number">70</span>;<br></code></pre></td></tr></table></figure><h3 id="30-查询不及格的课程"><a href="#30-查询不及格的课程" class="headerlink" title="30 查询不及格的课程"></a>30 查询不及格的课程</h3><div class="note note-info">            <p><strong>说明</strong><br>题干比较含糊没说明白需要哪些具体的信息，此处仅查询了有不及格学生的课程ID。<br>使用了DISTINCT进行了去重操作。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> CId <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">WHERE</span> score &lt; <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL50题（11-20题）</title>
    <link href="/2022/10/20/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8811-20%E9%A2%98%EF%BC%89/"/>
    <url>/2022/10/20/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8811-20%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="11-到-20-题"><a href="#11-到-20-题" class="headerlink" title="11 到 20 题"></a>11 到 20 题</h2><h3 id="11-查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩"><a href="#11-查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩" class="headerlink" title="11 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩"></a>11 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩</h3><div class="note note-info">            <p><strong>说明</strong><br>两门以上课程不及格需要满足两个条件：<br>条件1：不及格，使用WHERE从SC表中过滤出成绩小于60的数据。<br>条件2：两门以上，在条件1的基础上，使用GROUP BY按学生ID分组，使用COUNT统计不及格课程数目。<br>因为需要查询学生的姓名，需要使用JOIN联结Student表。</p>          </div>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.SId, Sname, <span class="hljs-built_in">Avg</span>(score) <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> Student <span class="hljs-keyword">ON</span> SC.SId = Student.SId<br><span class="hljs-keyword">WHERE</span> score &lt; <span class="hljs-number">60</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SC.SId<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(CId) &gt; <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="12-检索“01”课程分数小于60，按分数降序排列的学生信息"><a href="#12-检索“01”课程分数小于60，按分数降序排列的学生信息" class="headerlink" title="12 检索“01”课程分数小于60，按分数降序排列的学生信息"></a>12 检索“01”课程分数小于60，按分数降序排列的学生信息</h3><div class="note note-info">            <p><strong>说明</strong><br>直接按条件过滤SC表即可，因为需要按分数排序查询学生信息，所以还是要用联结。<br>排序使用ORDER BY，因为是降序，使用DESC。</p>          </div>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.* <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> Student <span class="hljs-keyword">ON</span> SC.SId = Student.SId<br><span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;01&#x27;</span> <span class="hljs-keyword">AND</span> score &lt; <span class="hljs-number">60</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h3 id="13-按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩"><a href="#13-按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩" class="headerlink" title="13 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩"></a>13 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩</h3><div class="note note-info">            <p><strong>说明</strong><br>使用AVG和GROUP BY分组算出平均成绩后，每个学生ID只会保留一条记录。<br>题目要求从显示所有学生所有课程，只用GROUP BY无法满足需求。<br>因此在用GROUP BY计算出平均成绩后，需要将查询结果和SC表再进行一次联结。<br>最后再按照计算字段Score_AVG降序排序。</p>          </div>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SC.*, Score_AVG <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <br>(<span class="hljs-keyword">SELECT</span> SId, <span class="hljs-built_in">AVG</span>(score) <span class="hljs-keyword">AS</span> Score_AVG <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SId ) <span class="hljs-keyword">AS</span> SCAVG<br><span class="hljs-keyword">ON</span> SC.SId =SCAVG.SId<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SCORE_AVG <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h3 id="14-查询各科成绩最高分、最低分和平均分："><a href="#14-查询各科成绩最高分、最低分和平均分：" class="headerlink" title="14 查询各科成绩最高分、最低分和平均分："></a>14 查询各科成绩最高分、最低分和平均分：</h3><div class="note note-success">            <p><strong>要求</strong><br>以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率。<br>及格为&gt;&#x3D;60，中等为：70-80，优良为：80-90，优秀为：&gt;&#x3D;90。<br>要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列。  </p>          </div>  <div class="note note-danger">            <p><strong>说明</strong><br>难题，本题需要使用CASE WHEN语句，根据成绩所处的区间，判定该成绩所处的位置。<br>以及格率为例，需要计算及格的人数和总人数，通过除法算出及格率。<br>计算及格的人数时，使用CASE WHEN判断score是否大于等于60，如果是的话设置为1，不是则设置为0。<br>这样通过SUM可以将若干个及格学生（数值为1）相加得出总及格人数。<br>中等率、优良率、优秀率同理，注意CASE WHEN最后不要忘记加END结束语句。<br>本题还要求输出课程name，所以需要用联结将SC和Course联结起来。<br>排序涉及到两个次序的排序，所以ORDER BY后跟两个字段分别降序和升序。</p>          </div>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SC.CId, <span class="hljs-built_in">COUNT</span>(SId), Cname, <span class="hljs-built_in">MAX</span>(score), <span class="hljs-built_in">MIN</span>(score), <span class="hljs-built_in">AVG</span>(Score),<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &gt;=<span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(score) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;及格率&#x27;</span>,<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &gt;=<span class="hljs-number">70</span> <span class="hljs-keyword">AND</span> score &lt;<span class="hljs-number">80</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(score) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;中等率&#x27;</span>,<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &gt;=<span class="hljs-number">80</span> <span class="hljs-keyword">AND</span> score &lt;<span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(score) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;优良率&#x27;</span>,<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &gt;=<span class="hljs-number">90</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(score) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;优秀率&#x27;</span><br><span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span> SC.CId = Course.CId<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SC.CId<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">DESC</span>, CId;<br></code></pre></td></tr></table></figure><h3 id="15-0-按各科成绩进行排序，并显示排名，Score-重复时保留名次空缺"><a href="#15-0-按各科成绩进行排序，并显示排名，Score-重复时保留名次空缺" class="headerlink" title="15-0 按各科成绩进行排序，并显示排名，Score 重复时保留名次空缺"></a>15-0 按各科成绩进行排序，并显示排名，Score 重复时保留名次空缺</h3><div class="note note-danger">            <p><strong>说明</strong><br>难题，本题使用窗口函数。<br>窗口函数有三种：RANK()， DENSE_RANK()以及ROW_NUMBER()。<br>使用的语法都一致：RANK() OVER(PARTITION BY 列1 ORDER BY 列2)<br>PARTITION可以看作分组，即将对应列中相同的数据归为一组进行排序。<br>ORDER BY可以看作排序依据，即排序将按照对应列中的数值来进行升降排序。<br>三个函数的区别在于：<br>ROW_NUMBER为不重复排序，在两行数据数值相同时，也会给出1、2、3、4这样连续的排序。<br>DENSE_RANK为连续排序，在两行数据相同时会给出相同排序，排序为1、2、2、3这样的效果。<br>RANK为跳跃排序，同样是数据相同时给相同排序，但排序效果为1、2、2、4。<br>本题要求保留名次空缺，要求上是DENSE_RANK的模式，直接用函数就行。</p>          </div>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> CId, SC.SId, Sname,<br>DENSE_RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> CId <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SCORE <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> 排名<br><span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Student<br><span class="hljs-keyword">ON</span> SC.SId = Student.SId;<br></code></pre></td></tr></table></figure><h3 id="15-1-按各科成绩进行排序，并显示排名，Score-重复时合并名次"><a href="#15-1-按各科成绩进行排序，并显示排名，Score-重复时合并名次" class="headerlink" title="15-1 按各科成绩进行排序，并显示排名，Score 重复时合并名次"></a>15-1 按各科成绩进行排序，并显示排名，Score 重复时合并名次</h3><div class="note note-info">            <p><strong>说明</strong><br>参考上一题的说明，本题要求合并名词，把DENSE_RANK改成RANK就可以。</p>          </div>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> CId, SC.SId, Sname,<br>Rank() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> CId <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SCORE <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> 排名<br><span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Student<br><span class="hljs-keyword">ON</span> SC.SId = Student.SId;<br></code></pre></td></tr></table></figure><h3 id="16-0-查询学生的总成绩，并进行排名，总分重复时保留名次空缺"><a href="#16-0-查询学生的总成绩，并进行排名，总分重复时保留名次空缺" class="headerlink" title="16-0 查询学生的总成绩，并进行排名，总分重复时保留名次空缺"></a>16-0 查询学生的总成绩，并进行排名，总分重复时保留名次空缺</h3><div class="note note-info">            <p><strong>说明</strong><br>组合GROUP和前两次使用的窗口函数（DENSE_RANK）可以轻松达成目的。<br>因为GROUP BY默认去重了，所以此处可以省略函数中PARTITION BY的语句。</p>          </div>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> SId, SUM(score) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;总成绩&#x27;</span>,<br>DENSE_RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SUM(score) <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;名次&#x27;</span><br><span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SId;<br></code></pre></td></tr></table></figure><h3 id="16-1-查询学生的总成绩，并进行排名，总分重复时不保留名次空缺"><a href="#16-1-查询学生的总成绩，并进行排名，总分重复时不保留名次空缺" class="headerlink" title="16-1 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺"></a>16-1 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺</h3><div class="note note-info">            <p><strong>说明</strong><br>和15-1一样，把DENSE_RANK换成RANK就行。</p>          </div>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> SId, SUM(score) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;总成绩&#x27;</span>,<br>RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> SUM(score) <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;名次&#x27;</span><br><span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SId;<br></code></pre></td></tr></table></figure><h3 id="17-统计各科成绩各分数段人数："><a href="#17-统计各科成绩各分数段人数：" class="headerlink" title="17 统计各科成绩各分数段人数："></a>17 统计各科成绩各分数段人数：</h3><div class="note note-success">            <p><strong>要求</strong><br>需要统计课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比</p>          </div>  <div class="note note-info">            <p><strong>说明</strong><br>和14题一样用CASE WHEN汇总各分段的学生人数，用计算字段来算出所占百分比。</p>          </div>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SC.CId, Cname,<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &gt;= <span class="hljs-number">85</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;85-100&#x27;</span>,<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &gt;= <span class="hljs-number">70</span> <span class="hljs-keyword">AND</span> score &lt; <span class="hljs-number">85</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;70-85&#x27;</span>,<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &gt;= <span class="hljs-number">60</span> <span class="hljs-keyword">AND</span> score &lt; <span class="hljs-number">70</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;60-70&#x27;</span>,<br><span class="hljs-built_in">SUM</span>(<span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> score &lt; <span class="hljs-number">60</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-keyword">END</span>) / <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;0-60&#x27;</span><br><span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span> SC.CId =Course.CId<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CId<br></code></pre></td></tr></table></figure><h3 id="18-查询各科成绩前三名的记录"><a href="#18-查询各科成绩前三名的记录" class="headerlink" title="18 查询各科成绩前三名的记录"></a>18 查询各科成绩前三名的记录</h3><div class="note note-danger">            <p><strong>说明</strong><br>难题，本题涉及到窗口函数的筛选。<br>需要注意的点是在一个SELECT里用窗口函数后，不能直接用WHERE对排序结果进行筛选。<br>原因在于窗口函数的排序原理是在WHERE过滤出需要的数据之后再进行排序。<br>所以在WHERE里过滤排序结果会直接报错。<br>解决方法是将使用窗口函数的查询结果命名为一张新的表格（代码里为A），嵌套一层SELECT对新表格A查询。<br>这样查询出的排名字段（C_RANK）只是一个普通字段而不是窗口函数作用的结果。<br>之后再使用WHERE过滤出名次小于3即前三名的数据记录。</p>          </div>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span> *, RANK() <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> CId <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>) <span class="hljs-keyword">AS</span> C_RANK<br><span class="hljs-keyword">FROM</span> SC) <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">WHERE</span> C_RANK &lt;= <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h3 id="19-查询每门课程被选修的学生数"><a href="#19-查询每门课程被选修的学生数" class="headerlink" title="19 查询每门课程被选修的学生数"></a>19 查询每门课程被选修的学生数</h3><div class="note note-info">            <p><strong>说明</strong><br>GROUP BY将CId分组后用COUNT统计即可。</p>          </div>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> CId, <span class="hljs-built_in">COUNT</span>(SId) <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> CId;<br></code></pre></td></tr></table></figure><h3 id="20-查询出只选修两门课程的学生学号和姓名"><a href="#20-查询出只选修两门课程的学生学号和姓名" class="headerlink" title="20 查询出只选修两门课程的学生学号和姓名"></a>20 查询出只选修两门课程的学生学号和姓名</h3><div class="note note-info">            <p><strong>说明</strong><br>使用子查询先查询学了两门课的学生ID，再用这些ID去查学生信息。<br>当然这题也可以用联结来解决。</p>          </div>  <figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.SId, Sname <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Student.SId <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> SC.SId <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SC.SId <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(CId) = <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL50题（01-10题）</title>
    <link href="/2022/10/19/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8801-10%E9%A2%98%EF%BC%89/"/>
    <url>/2022/10/19/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%8801-10%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="01-到-10-题"><a href="#01-到-10-题" class="headerlink" title="01 到 10 题"></a>01 到 10 题</h2><h3 id="1-0-查询“01”课程比“02”课程成绩高的学生的信息及课程分数"><a href="#1-0-查询“01”课程比“02”课程成绩高的学生的信息及课程分数" class="headerlink" title="1-0 查询“01”课程比“02”课程成绩高的学生的信息及课程分数"></a>1-0 查询“01”课程比“02”课程成绩高的学生的信息及课程分数</h3><div class="note note-danger">            <p><strong>说明</strong><br>难题，想要查询01成绩比02成绩高，比较便利的方法是构造一个三列分别为学生ID，01成绩和02成绩的新表。<br>因此首先分别查询SC表格中，对应课程ID为01和02的学生ID及相应的成绩（分别用AS命名为A和B）。<br>分别查询后，通过相同的学生ID，使用INNER JOIN 联结两次查询的结果（A和B），即可构造出想要的新表格。<br>之后再使用WHERE语句即可轻松地得到01成绩大于02的学生名单（需默认学生两门课都有成绩）。<br>在这之后，再将上述查询语句与Student表格联结，即可查询全部的学生信息。<br>由于01课程和02课程都使用命名为Score的字段，因此代码中用AS重命名为S1和S2方便辨认。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.*, S1 , S2 <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span><br>(<span class="hljs-keyword">SELECT</span> SId, CId, score <span class="hljs-keyword">AS</span> S1 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;01&#x27;</span>) <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">ON</span> Student.SId = A.SId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <br>(<span class="hljs-keyword">SELECT</span> SId, CId, score <span class="hljs-keyword">AS</span> S2 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;02&#x27;</span>) <span class="hljs-keyword">AS</span> B<br><span class="hljs-keyword">ON</span> A.SId =B.SId <br><span class="hljs-keyword">WHERE</span> S1 &gt; S2;<br></code></pre></td></tr></table></figure><h3 id="1-1-查询同时存在“01”课程和“02”课程的情况"><a href="#1-1-查询同时存在“01”课程和“02”课程的情况" class="headerlink" title="1-1 查询同时存在“01”课程和“02”课程的情况"></a>1-1 查询同时存在“01”课程和“02”课程的情况</h3><div class="note note-info">            <p><strong>说明</strong><br>因为题目没有明确说明具体要什么信息，所以不再联结Student表，也不用WHERE做筛选。<br>其余部分和1-0没有区别。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span> SId, CId, score <span class="hljs-keyword">AS</span> S1 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;01&#x27;</span>) <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <br>(<span class="hljs-keyword">SELECT</span> SId, CId, score <span class="hljs-keyword">AS</span> S2 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;02&#x27;</span>) <span class="hljs-keyword">AS</span> B<br><span class="hljs-keyword">ON</span> A.SId = B.SId<br></code></pre></td></tr></table></figure><h3 id="1-2-查询存在“01”课程但可能不存在“02”课程的情况（不存在时显示为-Null"><a href="#1-2-查询存在“01”课程但可能不存在“02”课程的情况（不存在时显示为-Null" class="headerlink" title="1-2 查询存在“01”课程但可能不存在“02”课程的情况（不存在时显示为 Null )"></a>1-2 查询存在“01”课程但可能不存在“02”课程的情况（不存在时显示为 Null )</h3><div class="note note-info">            <p><strong>说明</strong><br>和1-1区别仅在于需要增加不选择02课程（显示为NULL）的情况。<br>将INNER JIOIN 替换为LEFT OUTER JOIN即可，仅会过滤掉没有选择01课程的情况。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span> SId, CId, score <span class="hljs-keyword">AS</span> S1 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;01&#x27;</span>) <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> <br>(<span class="hljs-keyword">SELECT</span> SId, CId, score <span class="hljs-keyword">AS</span> S2 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;02&#x27;</span>) <span class="hljs-keyword">AS</span> B<br><span class="hljs-keyword">ON</span> A.SId = B.SId<br></code></pre></td></tr></table></figure><h3 id="1-3-查询不存在“01”课程但存在“02”课程的情况"><a href="#1-3-查询不存在“01”课程但存在“02”课程的情况" class="headerlink" title="1-3 查询不存在“01”课程但存在“02”课程的情况"></a>1-3 查询不存在“01”课程但存在“02”课程的情况</h3><div class="note note-info">            <p><strong>说明</strong><br>这次要求查选了02课程但没选01课程的情况，所以在1-2基础上改成RIGHT OUTER JOIN。<br>然后再加WHERE IS NULL的子句筛出没有选01课程的学生ID。<br>另一种方法是使用子查询：<br>首先查询出选了01课程的学生ID并用NOT IN否定，得到没有选择的01课程的学生ID。<br>然后再用AND添加WHERE子句，得到选择了02课程的学生ID，即满足题干的过滤要求。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span><br>(<span class="hljs-keyword">SELECT</span> SId, CId, Score <span class="hljs-keyword">AS</span> S1 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;01&#x27;</span>) <span class="hljs-keyword">AS</span> A<br><span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> <br>(<span class="hljs-keyword">SELECT</span> SId, CId, Score <span class="hljs-keyword">AS</span> S2 <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;02&#x27;</span>) <span class="hljs-keyword">AS</span> B<br><span class="hljs-keyword">ON</span> A.SId = B.SId<br><span class="hljs-keyword">WHERE</span> S1 <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">WHERE</span> SId <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> SId <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId = <span class="hljs-string">&#x27;01&#x27;</span> )<br><span class="hljs-keyword">AND</span> CId = <span class="hljs-string">&#x27;02&#x27;</span> ;<br></code></pre></td></tr></table></figure><h3 id="2-查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"><a href="#2-查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩" class="headerlink" title="2 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩"></a>2 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩</h3><div class="note note-info">            <p><strong>说明</strong><br>因为是需要按照学生的ID进行统计，因此需要使用GROUP BY分组。<br>在分组后，需要使用HAVING子句结合聚集函数过滤数据。<br>注意此处因为有分组所以不能使用WHERE子句，WHERE子句也不和聚集函数一起使用。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.SID, Student.Sname, <span class="hljs-built_in">AVG</span>(SC.score) <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span><br>Student.SId = SC.SId<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SC.SId<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(SC.score) &gt;= <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure><h3 id="3-查询在SC表存在成绩的学生信息"><a href="#3-查询在SC表存在成绩的学生信息" class="headerlink" title="3 查询在SC表存在成绩的学生信息"></a>3 查询在SC表存在成绩的学生信息</h3><div class="note note-info">            <p><strong>说明</strong><br>方法1：使用子查询先查询有分数的学生ID，再用IN操作符嵌套进Student表的查询。<br>方法2：使用联结组合两张表，由于SC表每个学生不止1个成绩，因此需要使用DISTINCT去重避免输出重复数据。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Student.SId <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> SC.SId <span class="hljs-keyword">FROM</span> SC);<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Student.* <span class="hljs-keyword">From</span> Student<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span><br>Student.SId = SC.SID;<br></code></pre></td></tr></table></figure><h3 id="4-0-查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩（没成绩的显示为Null）"><a href="#4-0-查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩（没成绩的显示为Null）" class="headerlink" title="4-0 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩（没成绩的显示为Null）"></a>4-0 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩（没成绩的显示为Null）</h3><div class="note note-info">            <p><strong>说明</strong><br>使用LETF JOIN以Student表为基底汇总SC表中成绩相关的信息。<br>聚集函数忽略NULL值，求和后依然会显示NULL值满足题干要求。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.Sid, Sname, <span class="hljs-built_in">Count</span>(CID), <span class="hljs-built_in">SUM</span>(score) <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> Student.SId = SC.SId<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> Student.SId;<br></code></pre></td></tr></table></figure><h3 id="4-1-查有成绩的学生信息"><a href="#4-1-查有成绩的学生信息" class="headerlink" title="4-1 查有成绩的学生信息"></a>4-1 查有成绩的学生信息</h3><div class="note note-info">            <p><strong>说明</strong><br>这一题看起来和第3题完全一致，实际上是玩了个文字游戏。<br>有成绩和在SC表里存在成绩可以看作两个意思。<br>前者理解为成绩至少是个具体的分数，后者理解为SC表里某学生有对应的score字段。<br>考虑到SC表中不排除会有某学生的成绩为空的情况（尽管事实上没有）：<br>如果还像第3题用INNER JOIN，那么就会输出成绩为NULL的学生信息，不满足有成绩的要求。<br>因此这里需要使用LEFT OUTER JOIN联结两张表，通过WHERE选出score不是NULL值的数据。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Student.* <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">OUTER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span> Student.SId = SC.SId<br><span class="hljs-keyword">WHERE</span> score <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="5-查询「李」姓老师的数量"><a href="#5-查询「李」姓老师的数量" class="headerlink" title="5 查询「李」姓老师的数量"></a>5 查询「李」姓老师的数量</h3><div class="note note-info">            <p><strong>说明</strong><br>使用COUNT(*)函数统计满足过滤条件的行数。<br>注意运用通配符通配搜索时，需要用LIKE操作符匹配，而不是用相等匹配。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(*) <span class="hljs-keyword">FROM</span> Teacher<br><span class="hljs-keyword">WHERE</span> Tname <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;李%&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="6-查询学过「张三」老师授课的同学的信息"><a href="#6-查询学过「张三」老师授课的同学的信息" class="headerlink" title="6 查询学过「张三」老师授课的同学的信息"></a>6 查询学过「张三」老师授课的同学的信息</h3><div class="note note-info">            <p><strong>说明</strong><br>方法1：使用传统的INNER JOIN内联结来汇总四张表格。<br>方法2：使用等值联结来汇总四张表格。<br>另：由于查询Student表格中的所有列，因此可以简写为Student.*。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.SId, Sname, Sage, Ssex <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> SC <span class="hljs-keyword">ON</span><br>Student.SId = SC.SId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span><br>Course.CId = SC.CId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Teacher <span class="hljs-keyword">ON</span> <br>Teacher.TId = Course.TId<br><span class="hljs-keyword">WHERE</span> Teacher.Tname = <span class="hljs-string">&#x27;张三&#x27;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SELECT Student.* FROM Student, <span class="hljs-keyword">SC, </span>Course, Teacher<br>WHERE Student.SId = <span class="hljs-keyword">SC.SId</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">AND </span>Course.CId = <span class="hljs-keyword">SC.CId</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">AND </span>Teacher.TId = Course.TId<br><span class="hljs-keyword">AND </span>Teacher.Tname = <span class="hljs-string">&#x27;张三&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="7-查询没有学全所有课程的同学的信息"><a href="#7-查询没有学全所有课程的同学的信息" class="headerlink" title="7 查询没有学全所有课程的同学的信息"></a>7 查询没有学全所有课程的同学的信息</h3><div class="note note-info">            <p><strong>说明</strong><br>此处使用了嵌套的3个SELECT语句：<br>最内层：查询Course表格中的课程总数（COUNT函数求总数）。<br>中间层：查询SC表格中满足学习课程数等级课程总数的学生ID（GROUP BY+HAVING+COUNT过滤学生ID）。<br>最外层：查询Student表格中，与上述学生ID不符的学生的全部信息（NOT IN取不满足条件的所有学生ID）。<br>特别注意这里不能将Student和SC表格简单联结试图简化语句，联结后会刨去在SC表格中不存在的学生ID。<br>导致输出的结果会少掉学生ID为9-13的五名学生的数据。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Student.SId <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span><br>(<br><span class="hljs-keyword">SELECT</span> SC.SId <span class="hljs-keyword">from</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SC.SId<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(SC.CId) = (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(Course.CId) <span class="hljs-keyword">FROM</span> Course)<br>);<br></code></pre></td></tr></table></figure><h3 id="8-查询至少有一门课与学号为“01”的同学所学相同的同学的信息"><a href="#8-查询至少有一门课与学号为“01”的同学所学相同的同学的信息" class="headerlink" title="8 查询至少有一门课与学号为“01”的同学所学相同的同学的信息"></a>8 查询至少有一门课与学号为“01”的同学所学相同的同学的信息</h3><div class="note note-info">            <p><strong>说明</strong><br>首次查询学号为01的同学所学的课程，之后用IN条件结合子查询查询学习了同样课程的学生ID。<br>因为要查询所有学生的信息，所以使用等值联结SC和Student两张表，再用DISTINCT去重学生ID。<br>需要注意题干潜在含义是查询结果不应再包含学号为01的学生，所以用AND额外添加NOT过滤条件刨去01学生。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> Student.* <span class="hljs-keyword">FROM</span> SC, Student<br><span class="hljs-keyword">WHERE</span> SC.SId = Student.SId<br><span class="hljs-keyword">AND</span> CId <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> CId <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> SC.SId = <span class="hljs-string">&#x27;01&#x27;</span>)<br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> Student.SId = <span class="hljs-string">&#x27;01&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="9-查询和“01”号的同学学习的课程完全相同的其他同学的信息"><a href="#9-查询和“01”号的同学学习的课程完全相同的其他同学的信息" class="headerlink" title="9 查询和“01”号的同学学习的课程完全相同的其他同学的信息"></a>9 查询和“01”号的同学学习的课程完全相同的其他同学的信息</h3><div class="note note-danger">            <p><strong>说明</strong><br>难题，与01学生学习课程完全相同，需要满足两个条件：<br>条件1.所学习的课程中，任意一项课程都包含在01学生所学课程的范围内。<br>条件2.学习的课程总数与01学生的课程总数相同。<br>对于条件1，查询时不能粗暴使用IN，因为IN代表只要学生所学课程中有一项在01学生学习课程区间内即可。<br>因此需要换个思路，改为首先用NOT IN查询所学课程中存在与01学生所学课程不符的学生。<br>之后再用一次NOT IN，将这些课程与01学生不符的学生刨去，剩下学生学习的课程都在01学生的区间内。<br>对于条件2，使用GROUP BY+HAVING COUNT的组合过滤出课程总数与01学生相等的学生。<br>用AND连接上述两个条件，过滤出的学生即同时满足条件1和条件2，再刨去学生01本人，即达成目的。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> Student <br><span class="hljs-keyword">WHERE</span> SId <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> SId <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> CId <br><span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> CId <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> SId = <span class="hljs-string">&#x27;01&#x27;</span>)<br>)<br><span class="hljs-keyword">AND</span> SId <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> SId <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> SId<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(CId) = (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(CId) <span class="hljs-keyword">FROM</span> SC <span class="hljs-keyword">WHERE</span> SId = <span class="hljs-string">&#x27;01&#x27;</span>)<br>)<br><span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> SId = <span class="hljs-string">&#x27;01&#x27;</span> ;<br></code></pre></td></tr></table></figure><h3 id="10-查询没学过「张三」老师讲授的任一门课程的学生姓名"><a href="#10-查询没学过「张三」老师讲授的任一门课程的学生姓名" class="headerlink" title="10 查询没学过「张三」老师讲授的任一门课程的学生姓名"></a>10 查询没学过「张三」老师讲授的任一门课程的学生姓名</h3><div class="note note-info">            <p><strong>说明</strong><br>方法1：用子查询嵌套，由内到外先查询老师叫张三的老师ID，再通过老师ID查询课程ID。<br>然后再通过课程ID查询学了该课程的学生ID，最后用NOT IN查询没学过课程的学生姓名。<br>方法2：使用联结将SC、Course和Teacher四张表联结，查询学习了张三老师课程的学生ID。<br>再嵌套一个子查询用NOT IN刨去这些学生。</p>          </div><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Sname <span class="hljs-keyword">FROM</span> Student <span class="hljs-keyword">WHERE</span><br>Student.SId <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> SC.Sid <span class="hljs-keyword">FROM</span> SC <br><span class="hljs-keyword">WHERE</span> SC.CID <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> Course.CID <span class="hljs-keyword">FROM</span> Course <br><span class="hljs-keyword">WHERE</span> COURSE.TId <span class="hljs-keyword">IN</span> <br>(<span class="hljs-keyword">SELECT</span> Teacher.TId <span class="hljs-keyword">FROM</span> Teacher <span class="hljs-keyword">WHERE</span> Tname = <span class="hljs-string">&#x27;张三&#x27;</span>)<br>)<br>);<br></code></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> Student.Sname <span class="hljs-keyword">FROM</span> Student<br><span class="hljs-keyword">WHERE</span> Student.Sid <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<br><span class="hljs-keyword">SELECT</span> SC.SId <span class="hljs-keyword">FROM</span> SC<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Course <span class="hljs-keyword">ON</span> SC.CId =Course.CId<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> Teacher <span class="hljs-keyword">ON</span> Course.TId =Teacher.TId<br><span class="hljs-keyword">WHERE</span> Tname = <span class="hljs-string">&#x27;张三&#x27;</span> );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL50题（索引）</title>
    <link href="/2022/10/17/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89/"/>
    <url>/2022/10/17/%E7%AC%94%E8%AE%B0/SQL50%E9%A2%98%EF%BC%88%E7%B4%A2%E5%BC%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<span id="more"></span> <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p align="justify">对于SQL语句的练习题，网上流传最广的就是这套所谓经典50题，并且这套50题也有相当多的解答文章。可能是因为流传度太广，不同文章中这套题的源数据、题目内容以及顺序会有出入，大致分为两个版本。本文选择成绩表格被命名为SC（而不是Score），且前几题有额外附加题的版本，给出自己练习时的解答。在解答题目的同时，也会加入注释来说明每一题的思路及特别需要注意的地方，方便自己进行回顾。<p><h2 id="解答索引"><a href="#解答索引" class="headerlink" title="解答索引"></a>解答索引</h2><p>01-10题：<a href="https://inarimoe.top/2022/10/19/SQL50%E9%A2%98%EF%BC%8801-10%E9%A2%98%EF%BC%89/">点我</a><br>11-20题：<a href="https://inarimoe.top/2022/10/19/SQL50%E9%A2%98%EF%BC%8811-20%E9%A2%98%EF%BC%89/">点我</a><br>21-30题：<a href="https://inarimoe.top/2022/10/21/SQL50%E9%A2%98%EF%BC%8821-30%E9%A2%98%EF%BC%89/">点我</a><br>31-50题：<a href="https://inarimoe.top/2022/10/21/SQL50%E9%A2%98%EF%BC%8831-50%E9%A2%98%EF%BC%89/">点我</a></p><h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><p>解答1（By Kaidi_G）：<a href="https://www.jianshu.com/p/476b52ee4f1b">点我</a><br>解答2（By 不高冷面包人）：<a href="https://blog.csdn.net/weixin_43348955/article/details/120481733?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-120481733-blog-106930311.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3">点我</a><br>解答3（By 胖熊酱）：<a href="https://zhuanlan.zhihu.com/p/67645448">点我</a><br>解答4（By Roar）：<a href="https://zhuanlan.zhihu.com/p/72223558">点我</a><br>解答5（By GodSuzzZ）：<a href="https://blog.csdn.net/GodSuzzZ/article/details/106930311">点我</a><br>视频（By 陆小亮）：<a href="https://www.bilibili.com/video/BV1q4411G7Lw?p=1">点我</a></p><h2 id="数据样例"><a href="#数据样例" class="headerlink" title="数据样例"></a>数据样例</h2><h3 id="课程表（Course）"><a href="#课程表（Course）" class="headerlink" title="课程表（Course）"></a>课程表（Course）</h3><p>CId-课程编号 丨 Cname-课程名字 丨 TId-教师编号       </p><table><thead><tr><th align="center">CId</th><th align="center">Cname</th><th align="center">TId</th></tr></thead><tbody><tr><td align="center">01</td><td align="center">语文</td><td align="center">02</td></tr><tr><td align="center">02</td><td align="center">数学</td><td align="center">01</td></tr><tr><td align="center">03</td><td align="center">英语</td><td align="center">03</td></tr></tbody></table><h3 id="学生表（Student）"><a href="#学生表（Student）" class="headerlink" title="学生表（Student）"></a>学生表（Student）</h3><p>SId-学生编号 丨 Sname-学生姓名 丨 Sage-出生年月 丨 Ssex-学生性别</p><table><thead><tr><th align="center">SId</th><th align="center">Sname</th><th align="center">Sage</th><th align="center">Ssex</th></tr></thead><tbody><tr><td align="center">01</td><td align="center">赵雷</td><td align="center">1990-01-01</td><td align="center">男</td></tr><tr><td align="center">02</td><td align="center">钱电</td><td align="center">1990-12-21</td><td align="center">男</td></tr><tr><td align="center">03</td><td align="center">孙风</td><td align="center">1990-12-20</td><td align="center">男</td></tr><tr><td align="center">04</td><td align="center">李云</td><td align="center">1990-12-06</td><td align="center">男</td></tr><tr><td align="center">05</td><td align="center">周梅</td><td align="center">1991-12-01</td><td align="center">女</td></tr><tr><td align="center">06</td><td align="center">吴兰</td><td align="center">1992-01-01</td><td align="center">女</td></tr><tr><td align="center">07</td><td align="center">郑竹</td><td align="center">1989-01-01</td><td align="center">女</td></tr><tr><td align="center">09</td><td align="center">张三</td><td align="center">2017-12-20</td><td align="center">女</td></tr><tr><td align="center">10</td><td align="center">李四</td><td align="center">2017-12-25</td><td align="center">女</td></tr><tr><td align="center">11</td><td align="center">李四</td><td align="center">2012-06-06</td><td align="center">女</td></tr><tr><td align="center">12</td><td align="center">赵六</td><td align="center">2013-06-13</td><td align="center">女</td></tr><tr><td align="center">13</td><td align="center">孙七</td><td align="center">2014-06-01</td><td align="center">女</td></tr></tbody></table><h3 id="教师表（Teacher）"><a href="#教师表（Teacher）" class="headerlink" title="教师表（Teacher）"></a>教师表（Teacher）</h3><p>TId-教师编号 丨 Tname-教师姓名</p><table><thead><tr><th align="center">TId</th><th align="center">Tname</th></tr></thead><tbody><tr><td align="center">01</td><td align="center">张三</td></tr><tr><td align="center">02</td><td align="center">李四</td></tr><tr><td align="center">03</td><td align="center">王五</td></tr></tbody></table><h3 id="成绩表（SC）"><a href="#成绩表（SC）" class="headerlink" title="成绩表（SC）"></a>成绩表（SC）</h3><p>SId-学生编号 丨 CId-课程编号 丨 score-分数</p><table><thead><tr><th align="center">SId</th><th align="center">CId</th><th align="center">score</th></tr></thead><tbody><tr><td align="center">01</td><td align="center">01</td><td align="center">80</td></tr><tr><td align="center">01</td><td align="center">02</td><td align="center">90</td></tr><tr><td align="center">01</td><td align="center">03</td><td align="center">99</td></tr><tr><td align="center">02</td><td align="center">01</td><td align="center">70</td></tr><tr><td align="center">02</td><td align="center">02</td><td align="center">60</td></tr><tr><td align="center">02</td><td align="center">03</td><td align="center">80</td></tr><tr><td align="center">03</td><td align="center">01</td><td align="center">80</td></tr><tr><td align="center">03</td><td align="center">02</td><td align="center">80</td></tr><tr><td align="center">03</td><td align="center">03</td><td align="center">80</td></tr><tr><td align="center">04</td><td align="center">01</td><td align="center">50</td></tr><tr><td align="center">04</td><td align="center">02</td><td align="center">30</td></tr><tr><td align="center">04</td><td align="center">03</td><td align="center">20</td></tr><tr><td align="center">05</td><td align="center">01</td><td align="center">76</td></tr><tr><td align="center">05</td><td align="center">02</td><td align="center">87</td></tr><tr><td align="center">06</td><td align="center">01</td><td align="center">31</td></tr><tr><td align="center">06</td><td align="center">03</td><td align="center">34</td></tr><tr><td align="center">07</td><td align="center">02</td><td align="center">89</td></tr><tr><td align="center">07</td><td align="center">03</td><td align="center">98</td></tr></tbody></table><h2 id="题目内容"><a href="#题目内容" class="headerlink" title="题目内容"></a>题目内容</h2><p>1-0 查询“01”课程比“02”课程成绩高的学生的信息及课程分数<br>1-1 查询同时存在“01”课程和“02”课程的情况<br>1-2 查询存在“01”课程但可能不存在“02”课程的情况（不存在时显示为 Null )<br>1-3 查询不存在“01”课程但存在“02”课程的情况<br>2 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩<br>3 查询在SC表存在成绩的学生信息<br>4-0 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩（没成绩的显示为Null）<br>4-1 查有成绩的学生信息<br>5 查询「李」姓老师的数量<br>6 查询学过「张三」老师授课的同学的信息<br>7 查询没有学全所有课程的同学的信息<br>8 查询至少有一门课与学号为“01”的同学所学相同的同学的信息<br>9 查询和“01”号的同学学习的课程完全相同的其他同学的信息<br>10 查询没学过「张三」老师讲授的任一门课程的学生姓名<br>11 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩<br>12 检索“01”课程分数小于60，按分数降序排列的学生信息<br>13 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩<br>14 查询各科成绩最高分、最低分和平均分：<br>以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率<br>及格为&gt;&#x3D;60，中等为：70-80，优良为：80-90，优秀为：&gt;&#x3D;90<br>要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列<br>15-0 按各科成绩进行排序，并显示排名，Score 重复时保留名次空缺<br>15-1 按各科成绩进行排序，并显示排名，Score 重复时合并名次<br>16-0 查询学生的总成绩，并进行排名，总分重复时保留名次空缺<br>16-1 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺<br>17 统计各科成绩各分数段人数：<br>需要统计课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比<br>18 查询各科成绩前三名的记录<br>19 查询每门课程被选修的学生数<br>20 查询出只选修两门课程的学生学号和姓名<br>21 查询男生、女生人数<br>22 查询名字中含有「风」字的学生信息<br>23 查询同名同性学生名单，并统计同名人数<br>24 查询1990年出生的学生名单<br>25 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列<br>26 查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩<br>27 查询课程名称为「数学」，且分数低于60的学生姓名和分数<br>28 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）<br>29 查询任何一门课程成绩在70分以上的姓名、课程名称和分数<br>30 查询不及格的课程<br>31 查询课程编号为01且课程成绩在80分以上的学生的学号和姓名<br>32 求每门课程的学生人数<br>33 成绩不重复，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩<br>34 成绩有重复的情况下，查询「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩<br>35 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩<br>36 查询每门功课成绩最好的前两名<br>37 统计每门课程的学生选修人数（超过5人的课程才统计）。<br>38 检索至少选修两门课程的学生学号<br>39 查询选修了全部课程的学生信息<br>40 查询各学生的年龄，只按年份来算<br>41 按照出生日期来算，当前月日出生年月的月日则，则年龄减一<br>42 查询本周过生日的学生<br>43 查询下周过生日的学生<br>44 查询本月过生日的学生<br>45 查询下月过生日的学生</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最后吐槽一下，这个所谓的经典50题感觉质量挺一般的：<br>难度曲线相当诡异，第一题就开幕雷击，前20题平均难度比后30题明显要高得多，纯纯劝退。<br>比较好的组合套题应该是循序渐进的过程，难度逐步上升才合理。<br>后期题目出得很水，很多题的要点都是很相近甚至完全一致的，像是强行凑50题（而且最后也没凑满）。<br>有一些学到的SQL的知识在套题里没有出现，感觉也不是相当全面的样子。<br>不过50题做完回顾下来感觉还是比较有意义的，最大的意义是学了一些教材上没有提到的SQL语句用法。<br>尤其是CASE WHEN和窗口函数，教科书上完全没有出现过，但实践下来都是相当实用的语法。<br>今后还会再找一些SQL相关的题目练练手做做总结，这套50题的解答和要点就留在这里方便回顾了。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/11/%E6%9D%82%E8%B0%88/HelloWorld/"/>
    <url>/2022/10/11/%E6%9D%82%E8%B0%88/HelloWorld/</url>
    
    <content type="html"><![CDATA[<p>　</p><blockquote><p align="justify">　　象征性打一遍Hello World，有一说一，还挺有仪式感的。希望今后一切顺利吧。<p></blockquote><span id="more"></span><h2 id="突发奇想"><a href="#突发奇想" class="headerlink" title="突发奇想"></a>突发奇想</h2><p align="justify">　　居家办公闲来无事突然脑洞大开想整个私人页面记录一些生活中的日常。<p><p align="justify">　　打开百度搜索了建立私人网站页面，然后就跳出来各种教程，随便点开一个，首先看到的就是大量不知所谓的复杂代码，瞬间就有些退缩了。<p>  <p align="justify">　　一想到自己好歹也学过C#以及SQL（虽然全部半途而废了），还是硬着头皮找了个看起来没那么复杂的教程折腾了一下午，中间经历了无数次报错，最后靠着不断百度终于是解决了各种乱七八糟的问题，通过套了个Hexo框架下最常用的Next主题，终于是把这个简易的个人站点建立了起来。 <p>  <p align="justify">　　回顾这一下午的经历，说实话感觉整个流程并不是很复杂，走的弯路更多是因为教程年代相对早了一些与现在的环境不太匹配，才产生了问题，如果教程再更细致一些，相信没有任何编程基础也是可以快速完成网站建设的。<p><h2 id="突发奇想之后？"><a href="#突发奇想之后？" class="headerlink" title="突发奇想之后？"></a>突发奇想之后？</h2><p align="justify">　　建立个人页面的初衷是想有个私密性质相对强一点的开放平台来记录一些感想，包括通关的游戏、看完的动画及小说等等，并放置自己自制游戏的文档，记录这日复一日无趣社畜生活历程。   <p align="justify">　　既然现在网站的框架已经搭建好了，今后会尝试持续性地更新内容，增加更多文章，并长期完善这个也不能算是来之不易的站点，如果能做好的话，象征性买个域名也说不定？借着完善网站这个契机，今后也会长期持续性地学习一些代码相关的知识，扩充一下知识储备。　<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p align="justify">　　象征性打一遍Hello World，有一说一，还挺有仪式感的。希望今后一切顺利吧。]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>碎碎念</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
